import{C as ot,V as ne,a as He,b as pt,M as cc,c as Jo,E as Qo,d as ei,L as qn,S as uc,e as lc,I as dc,f as hc,D as Tn,g as pc,h as mc,i as gc,F as ti,W as si,j as $n,N as po,k as fc,l as Vs,m as ni,n as oi,o as Nc,B as yc,p as Sn,q as xc,R as St,P as vc,T as mo,O as Tc,r as Sc,s as Vc,t as _c,A as Rc,u as Ac,H as wc,v as ii,w as ai,x as ri,y as _s,z as Mc,G as Cc,J as ci,K as Ec,Q as Lc,U as ui,X as Ic,Y as li,Z as Oc,_ as bc,$ as zc,a0 as Dc,a1 as Pc,a2 as Fc,a3 as Uc,a4 as Bc,a5 as kc,a6 as Gc,a7 as go,a8 as Wc,a9 as fo}from"./three.module-09def97d.js";const Hc=`precision highp float;
#define GLSLIFY 1
#define PI 3.14159265359

uniform float uTime;
uniform vec2 uResolution;
uniform vec2 uMouse;

uniform sampler2D tBackground;

uniform vec3 uOutlineColor;
uniform float uOutlineThickness;

uniform vec2 uRectangleSize;

uniform float uWarpStrength;

uniform vec2 uBigWarpScale;
uniform vec2 uDetailWarpScale;

uniform float uNoiseStrength;

uniform int uNumberOfRectangles;

varying vec2 vUv;

uniform bool uNoWarp;

float map(float value, float min1, float max1, float min2, float max2) {
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float blendSoftLight(float base, float blend) {
	return (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));
}

vec3 blendSoftLight(vec3 base, vec3 blend) {
	return vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));
}

vec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {
	return (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));
}

float random(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * 443.8975);
	p3 += dot(p3, p3.yzx + 19.19);
	return fract((p3.x + p3.y) * p3.z);
}

float random(float n) {
    return fract(sin(n) * 43758.5453123);
}

vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

float cnoise(vec3 P){
    vec3 Pi0 = floor(P); 
    vec3 Pi1 = Pi0 + vec3(1.0); 
    Pi0 = mod(Pi0, 289.0);
    Pi1 = mod(Pi1, 289.0);
    vec3 Pf0 = fract(P); 
    vec3 Pf1 = Pf0 - vec3(1.0); 
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = Pi0.zzzz;
    vec4 iz1 = Pi1.zzzz;

    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);

    vec4 gx0 = ixy0 / 7.0;
    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);

    vec4 gx1 = ixy1 / 7.0;
    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);

    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;

    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);

    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 2.2 * n_xyz;
}

float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

void main() {

    vec2 mousePosition = vec2(0.5);

    vec2 centerUV = vUv - 0.5;
    centerUV *= 2.0;

    
    float rectangleWidth = uRectangleSize.x;
    float rectangleHeight = uRectangleSize.y;

    float distanceX = abs(centerUV.x - uMouse.x);
    float distanceY = abs(centerUV.y - uMouse.y);

    float outlineThickness = uOutlineThickness * 0.01;

    float sdShape = sdBox(centerUV-uMouse, vec2(rectangleWidth, rectangleHeight));
    float shape = 1.0 - step(0.0, sdShape);
    float outline = smoothstep(-outlineThickness, 0.0, sdShape) * (1.0 - smoothstep(0.0, outlineThickness, sdShape));

    float rectShape = 0.0;
    float rectOutline = 0.0;
    
    for(int i = 0; i < uNumberOfRectangles; i++) {
        
        vec2 randomPosition = vec2(
            random(step(0.7, sin(float(i) * PI * 2.0 + uTime * 0.002)) + float(i) + 1.0), 
            random(step(0.7, cos(float(i + 2) * PI * 2.0 + uTime * 0.0015)) + float(i + 3) + 1.0)
        );

        randomPosition -= 0.5; 
        randomPosition *= 2.0; 

        
        vec2 rectCenter = randomPosition;

        float rectWidth = random(float(i) + 2.0) * 0.25 * map( step(0.7, sin(uTime * 0.005 + float(i) * 0.5)), 0., 1., 0.7, 1.0);
        float rectHeight = random(float(i * i) + 3.0) * 0.25 * map( step(0.9, cos(uTime * 0.002 + float(i) * 1.5)), 0., 1., 0.7, 1.0);;

        float sdRectBox = sdBox(centerUV-rectCenter, vec2(rectWidth, rectHeight));

        float hideAnimation = step(0.0, sin(uTime * 0.00025 + float(i + 10) + float(i + 5) * PI * 2.0));

        rectShape += 1.0 - step(0.0, sdRectBox) * hideAnimation;
        rectOutline += smoothstep(-outlineThickness, 0.0, sdRectBox) * (1.0 - smoothstep(0.0, outlineThickness, sdRectBox)) * hideAnimation;
    }

    
    vec2 uv = vUv;

    if(!uNoWarp) {
        vec2 warpUV = vUv;

        float bigNoise = cnoise(vec3(warpUV * uBigWarpScale, uTime * 0.0005 + 45684.));
        warpUV += bigNoise * uWarpStrength;

        
        float noise = cnoise(vec3((vUv) * uDetailWarpScale, uTime * 0.0007));
        warpUV += noise * uWarpStrength * 1.5;

        
        

        

        
        
        
        

        

        
        

        

        uv = mix(warpUV, uv, shape); 
        
        uv = mix(uv, vUv, rectShape);

    }

    vec3 outputColor = texture2D(tBackground, uv).rgb;

    
    float flicker = random(step(0.0, sin(uTime * 0.005)));

    rectOutline *= mix(1.0, flicker, step(0.0, sin(uTime * 0.01) * cos(uTime * 0.01 + 45864.)));
    outline *= mix(1.0, flicker, step(0.3, sin(uTime * 0.01 + 421.) * cos(uTime * 0.01 + 45864.)));

    outputColor = mix(outputColor, uOutlineColor, outline); 

    
    outputColor = mix(outputColor, uOutlineColor, rectOutline);

    gl_FragColor = vec4(vec3(outputColor), 1.0);

    float noiseFactor = mix(uNoiseStrength, 0.0, shape); 
    gl_FragColor.rgb = blendSoftLight(gl_FragColor.rgb, vec3(random(vUv * 5.) - 0.5), noiseFactor);
}`,qc=`precision highp float;
#define GLSLIFY 1

uniform float uTime;
uniform vec2 uResolution;

uniform vec3 uColor1; 
uniform vec3 uColor2; 
uniform vec3 uColor3; 

uniform float uStep1;
uniform float uStep2;
uniform float uStep3;

varying vec2 vUv;

void main() {

   
   vec3 outputColor = vec3(0.);
   outputColor += mix(uColor3, uColor2, smoothstep(uStep1, uStep2, vUv.y));
   outputColor = mix(outputColor, uColor1, smoothstep(uStep2, uStep3, vUv.y));

   gl_FragColor = vec4(outputColor, 1.0);

}`;function $c(n,e){let t,s;return function(){const o=this,i=arguments;s?(clearTimeout(t),t=setTimeout(function(){Date.now()-s>=e&&(n.apply(o,i),s=Date.now())},e-(Date.now()-s))):(n.apply(o,i),s=Date.now())}}const No={VERTEX:"vertex",FRAGMENT:"fragment"},$={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},Us=["x","y","z","w"];function di(n,e=!1){let t="{";n.isNode===!0&&(t+=n.id);for(const{property:s,childNode:o}of Rs(n))t+=","+s.slice(0,-4)+":"+o.getCacheKey(e);return t+="}",t}function*Rs(n,e=!1){for(const t in n){if(t.startsWith("_")===!0)continue;const s=n[t];if(Array.isArray(s)===!0)for(let o=0;o<s.length;o++){const i=s[o];i&&(i.isNode===!0||e&&typeof i.toJSON=="function")&&(yield{property:t,index:o,childNode:i})}else if(s&&s.isNode===!0)yield{property:t,childNode:s};else if(typeof s=="object")for(const o in s){const i=s[o];i&&(i.isNode===!0||e&&typeof i.toJSON=="function")&&(yield{property:t,index:o,childNode:i})}}}function dt(n){if(n==null)return null;const e=typeof n;return n.isNode===!0?"node":e==="number"?"float":e==="boolean"?"bool":e==="string"?"string":e==="function"?"shader":n.isVector2===!0?"vec2":n.isVector3===!0?"vec3":n.isVector4===!0?"vec4":n.isMatrix3===!0?"mat3":n.isMatrix4===!0?"mat4":n.isColor===!0?"color":n instanceof ArrayBuffer?"ArrayBuffer":null}function hi(n,...e){const t=n?n.slice(-4):void 0;return e.length===1&&(t==="vec2"?e=[e[0],e[0]]:t==="vec3"?e=[e[0],e[0],e[0]]:t==="vec4"&&(e=[e[0],e[0],e[0],e[0]])),n==="color"?new ot(...e):t==="vec2"?new ne(...e):t==="vec3"?new He(...e):t==="vec4"?new pt(...e):t==="mat3"?new cc(...e):t==="mat4"?new Jo(...e):n==="bool"?e[0]||!1:n==="float"||n==="int"||n==="uint"?e[0]||0:n==="string"?e[0]||"":n==="ArrayBuffer"?mi(e[0]):null}function pi(n){let e="";const t=new Uint8Array(n);for(let s=0;s<t.length;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function mi(n){return Uint8Array.from(atob(n),e=>e.charCodeAt(0)).buffer}const yo=new Map;let Xc=0;class L extends Qo{constructor(e=null){super(),this.nodeType=e,this.updateType=$.NONE,this.updateBeforeType=$.NONE,this.uuid=ei.generateUUID(),this.version=0,this._cacheKey=null,this._cacheKeyVersion=0,this.isNode=!0,Object.defineProperty(this,"id",{value:Xc++})}set needsUpdate(e){e===!0&&this.version++}get type(){return this.constructor.type}onUpdate(e,t){return this.updateType=t,this.update=e.bind(this.getSelf()),this}onFrameUpdate(e){return this.onUpdate(e,$.FRAME)}onRenderUpdate(e){return this.onUpdate(e,$.RENDER)}onObjectUpdate(e){return this.onUpdate(e,$.OBJECT)}onReference(e){return this.updateReference=e.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return!1}*getChildren(){for(const{childNode:e}of Rs(this))yield e}dispose(){this.dispatchEvent({type:"dispose"})}traverse(e){e(this);for(const t of this.getChildren())t.traverse(e)}getCacheKey(e=!1){return e=e||this.version!==this._cacheKeyVersion,(e===!0||this._cacheKey===null)&&(this._cacheKey=di(this,e),this._cacheKeyVersion=this.version),this._cacheKey}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode?t.outputNode.getNodeType(e):this.nodeType}getShared(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}setup(e){const t=e.getNodeProperties(this);for(const s of this.getChildren())t["_node"+s.id]=s;return null}construct(e){return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."),this.setup(e)}increaseUsage(e){const t=e.getDataFromNode(this);return t.usageCount=t.usageCount===void 0?1:t.usageCount+1,t.usageCount}analyze(e){if(this.increaseUsage(e)===1){const s=e.getNodeProperties(this);for(const o of Object.values(s))o&&o.isNode===!0&&o.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&s.isNode===!0)return s.build(e,t)}updateBefore(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const s=this.getShared(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let o=null;const i=e.getBuildStage();if(i==="setup"){this.updateReference(e);const a=e.getNodeProperties(this);if(a.initialized!==!0||e.context.tempRead===!1){const r=e.stack.nodes.length;a.initialized=!0,a.outputNode=this.setup(e),a.outputNode!==null&&e.stack.nodes.length!==r&&(a.outputNode=e.stack);for(const c of Object.values(a))c&&c.isNode===!0&&c.build(e)}}else if(i==="analyze")this.analyze(e);else if(i==="generate")if(this.generate.length===1){const r=this.getNodeType(e),c=e.getDataFromNode(this);o=c.snippet,o===void 0&&(o=this.generate(e)||"",c.snippet=o),o=e.format(o,r,t)}else o=this.generate(e,t)||"";return e.removeChain(this),o}getSerializeChildren(){return Rs(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:o,index:i,childNode:a}of t)i!==void 0?(s[o]===void 0&&(s[o]=Number.isInteger(i)?[]:{}),s[o][i]=a.toJSON(e.meta).uuid):s[o]=a.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(e.inputNodes!==void 0){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const o=[];for(const i of e.inputNodes[s])o.push(t[i]);this[s]=o}else if(typeof e.inputNodes[s]=="object"){const o={};for(const i in e.inputNodes[s]){const a=e.inputNodes[s][i];o[i]=t[a]}this[s]=o}else{const o=e.inputNodes[s];this[s]=t[o]}}}toJSON(e){const{uuid:t,type:s}=this,o=e===void 0||typeof e=="string";o&&(e={textures:{},images:{},nodes:{}});let i=e.nodes[t];i===void 0&&(i={uuid:t,type:s,meta:e,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},o!==!0&&(e.nodes[i.uuid]=i),this.serialize(i),delete i.meta);function a(r){const c=[];for(const u in r){const l=r[u];delete l.metadata,c.push(l)}return c}if(o){const r=a(e.textures),c=a(e.images),u=a(e.nodes);r.length>0&&(i.textures=r),c.length>0&&(i.images=c),u.length>0&&(i.nodes=u)}return i}}function T(n,e){if(typeof e!="function"||!n)throw new Error(`Node class ${n} is not a class`);if(yo.has(n)){console.warn(`Redefinition of node class ${n}`);return}yo.set(n,e),e.type=n}class j extends L{constructor(e){super(e),this.isTempNode=!0}hasDependencies(e){return e.getDataFromNode(this).usageCount>1}build(e,t){if(e.getBuildStage()==="generate"){const o=e.getVectorType(this.getNodeType(e,t)),i=e.getDataFromNode(this);if(e.context.tempRead!==!1&&i.propertyName!==void 0)return e.format(i.propertyName,o,t);if(e.context.tempWrite!==!1&&o!=="void"&&t!=="void"&&this.hasDependencies(e)){const a=super.build(e,o),r=e.getVarFromNode(this,null,o),c=e.getPropertyName(r);return e.addLineFlowCode(`${c} = ${a}`),i.snippet=a,i.propertyName=c,e.format(i.propertyName,o,t)}}return super.build(e,t)}}T("TempNode",j);class Wt extends L{constructor(e,t){super(),this.node=e,this.indexNode=t,this.isArrayElementNode=!0}getNodeType(e){return this.node.getNodeType(e)}generate(e){const t=this.node.build(e),s=this.indexNode.build(e,"uint");return`${t}[ ${s} ]`}}T("ArrayElementNode",Wt);class Xn extends L{constructor(e,t){super(),this.node=e,this.convertTo=t}getNodeType(e){const t=this.node.getNodeType(e);let s=null;for(const o of this.convertTo.split("|"))(s===null||e.getTypeLength(t)===e.getTypeLength(o))&&(s=o);return s}serialize(e){super.serialize(e),e.convertTo=this.convertTo}deserialize(e){super.deserialize(e),this.convertTo=e.convertTo}generate(e,t){const s=this.node,o=this.getNodeType(e),i=s.build(e,o);return e.format(i,o,t)}}T("ConvertNode",Xn);class gi extends j{constructor(e=[],t=null){super(t),this.nodes=e}getNodeType(e){return this.nodeType!==null?e.getVectorType(this.nodeType):e.getTypeFromLength(this.nodes.reduce((t,s)=>t+e.getTypeLength(s.getNodeType(e)),0))}generate(e,t){const s=this.getNodeType(e),o=this.nodes,i=e.getComponentType(s),a=[];for(const c of o){let u=c.build(e);const l=e.getComponentType(c.getNodeType(e));l!==i&&(u=e.format(u,l,i)),a.push(u)}const r=`${e.getType(s)}( ${a.join(", ")} )`;return e.format(r,s,t)}}T("JoinNode",gi);const jc=Us.join("");class Vn extends L{constructor(e,t="x"){super(),this.node=e,this.components=t,this.isSplitNode=!0}getVectorLength(){let e=this.components.length;for(const t of this.components)e=Math.max(Us.indexOf(t)+1,e);return e}getComponentType(e){return e.getComponentType(this.node.getNodeType(e))}getNodeType(e){return e.getTypeFromLength(this.components.length,this.getComponentType(e))}generate(e,t){const s=this.node,o=e.getTypeLength(s.getNodeType(e));let i=null;if(o>1){let a=null;this.getVectorLength()>=o&&(a=e.getTypeFromLength(this.getVectorLength(),this.getComponentType(e)));const c=s.build(e,a);this.components.length===o&&this.components===jc.slice(0,this.components.length)?i=e.format(c,a,t):i=e.format(`${c}.${this.components}`,this.getNodeType(e),t)}else i=s.build(e,t);return i}serialize(e){super.serialize(e),e.components=this.components}deserialize(e){super.deserialize(e),this.components=e.components}}T("SplitNode",Vn);class fi extends j{constructor(e,t,s){super(),this.sourceNode=e,this.components=t,this.targetNode=s}getNodeType(e){return this.sourceNode.getNodeType(e)}generate(e){const{sourceNode:t,components:s,targetNode:o}=this,i=this.getNodeType(e),a=e.getTypeFromLength(s.length),r=o.build(e,a),c=t.build(e,i),u=e.getTypeLength(i),l=[];for(let p=0;p<u;p++){const g=Us[p];g===s[0]?(l.push(r),p+=s.length-1):l.push(c+"."+g)}return`${e.getType(i)}( ${l.join(", ")} )`}}T("SetNode",fi);class Bs extends L{constructor(e,t=null){super(t),this.isInputNode=!0,this.value=e,this.precision=null}getNodeType(){return this.nodeType===null?dt(this.value):this.nodeType}getInputType(e){return this.getNodeType(e)}setPrecision(e){return this.precision=e,this}serialize(e){super.serialize(e),e.value=this.value,this.value&&this.value.toArray&&(e.value=this.value.toArray()),e.valueType=dt(this.value),e.nodeType=this.nodeType,e.valueType==="ArrayBuffer"&&(e.value=pi(e.value)),e.precision=this.precision}deserialize(e){super.deserialize(e),this.nodeType=e.nodeType,this.value=Array.isArray(e.value)?hi(e.valueType,...e.value):e.value,this.precision=e.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(e.value))}generate(){console.warn("Abstract function.")}}T("InputNode",Bs);class ke extends Bs{constructor(e,t=null){super(e,t),this.isConstNode=!0}generateConst(e){return e.generateConst(this.getNodeType(e),this.value)}generate(e,t){const s=this.getNodeType(e);return e.format(this.generateConst(e),s,t)}}T("ConstNode",ke);let Bt=null;const Et=new Map;function N(n,e){if(Et.has(n)){console.warn(`Redefinition of node element ${n}`);return}if(typeof e!="function")throw new Error(`Node element ${n} is not a function`);Et.set(n,e)}const xo=n=>n.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),Ni={setup(n,e){const t=e.shift();return n(Ws(t),...e)},get(n,e,t){if(typeof e=="string"&&n[e]===void 0){if(n.isStackNode!==!0&&e==="assign")return(...s)=>(Bt.assign(t,...s),t);if(Et.has(e)){const s=Et.get(e);return n.isStackNode?(...o)=>t.add(s(...o)):(...o)=>s(t,...o)}else{if(e==="self")return n;if(e.endsWith("Assign")&&Et.has(e.slice(0,e.length-6))){const s=Et.get(e.slice(0,e.length-6));return n.isStackNode?(...o)=>t.assign(o[0],s(...o)):(...o)=>t.assign(s(t,...o))}else{if(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0)return e=xo(e),A(new Vn(t,e));if(/^set[XYZWRGBASTPQ]{1,4}$/.test(e)===!0)return e=xo(e.slice(3).toLowerCase()),e=e.split("").sort().join(""),s=>A(new fi(n,e,s));if(e==="width"||e==="height"||e==="depth")return e==="width"?e="x":e==="height"?e="y":e==="depth"&&(e="z"),A(new Vn(n,e));if(/^\d+$/.test(e)===!0)return A(new Wt(t,new ke(Number(e),"uint")))}}}return Reflect.get(n,e,t)},set(n,e,t,s){return typeof e=="string"&&n[e]===void 0&&(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0||e==="width"||e==="height"||e==="depth"||/^\d+$/.test(e)===!0)?(s[e].assign(t),!0):Reflect.set(n,e,t,s)}},tn=new WeakMap,vo=new WeakMap,Yc=function(n,e=null){const t=dt(n);if(t==="node"){let s=tn.get(n);return s===void 0&&(s=new Proxy(n,Ni),tn.set(n,s),tn.set(s,s)),s}else{if(e===null&&(t==="float"||t==="boolean")||t&&t!=="shader"&&t!=="string")return A(_n(n,e));if(t==="shader")return x(n)}return n},Zc=function(n,e=null){for(const t in n)n[t]=A(n[t],e);return n},Kc=function(n,e=null){const t=n.length;for(let s=0;s<t;s++)n[s]=A(n[s],e);return n},Jc=function(n,e=null,t=null,s=null){const o=i=>A(s!==null?Object.assign(i,s):i);return e===null?(...i)=>o(new n(...bt(i))):t!==null?(t=A(t),(...i)=>o(new n(e,...bt(i),t))):(...i)=>o(new n(e,...bt(i)))},Qc=function(n,...e){return A(new n(...bt(e)))};class eu extends L{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t}getNodeType(e){const{outputNode:t}=e.getNodeProperties(this);return t?t.getNodeType(e):super.getNodeType(e)}call(e){const{shaderNode:t,inputNodes:s}=this;if(t.layout){let a=vo.get(e.constructor);a===void 0&&(a=new WeakMap,vo.set(e.constructor,a));let r=a.get(t);return r===void 0&&(r=A(e.buildFunctionNode(t)),a.set(t,r)),e.currentFunctionNode!==null&&e.currentFunctionNode.includes.push(r),A(r.call(s))}const o=t.jsFunc,i=s!==null?o(s,e.stack,e):o(e.stack,e);return A(i)}setup(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);return s===null?this.call(e).build(e,t):super.generate(e,t)}}class tu extends L{constructor(e){super(),this.jsFunc=e,this.layout=null}get isArrayInput(){return/^\((\s+)?\[/.test(this.jsFunc.toString())}setLayout(e){return this.layout=e,this}call(e=null){return Ws(e),A(new eu(this,e))}setup(){return this.call()}}const su=[!1,!0],nu=[0,1,2,3],ou=[-1,-2],yi=[.5,1.5,1/3,1e-6,1e6,Math.PI,Math.PI*2,1/Math.PI,2/Math.PI,1/(Math.PI*2),Math.PI/2],jn=new Map;for(const n of su)jn.set(n,new ke(n));const Yn=new Map;for(const n of nu)Yn.set(n,new ke(n,"uint"));const Zn=new Map([...Yn].map(n=>new ke(n.value,"int")));for(const n of ou)Zn.set(n,new ke(n,"int"));const ks=new Map([...Zn].map(n=>new ke(n.value)));for(const n of yi)ks.set(n,new ke(n));for(const n of yi)ks.set(-n,new ke(-n));const Gs={bool:jn,uint:Yn,ints:Zn,float:ks},To=new Map([...jn,...ks]),_n=(n,e)=>To.has(n)?To.get(n):n.isNode===!0?n:new ke(n,e),iu=n=>{try{return n.getNodeType()}catch{return}},H=function(n,e=null){return(...t)=>{if((t.length===0||!["bool","float","int","uint"].includes(n)&&t.every(o=>typeof o!="object"))&&(t=[hi(n,...t)]),t.length===1&&e!==null&&e.has(t[0]))return A(e.get(t[0]));if(t.length===1){const o=_n(t[0],n);return iu(o)===n?A(o):A(new Xn(o,n))}const s=t.map(o=>_n(o));return A(new gi(s,n))}},So=n=>n&&n.value,au=n=>n!=null?n.nodeType||n.convertTo||(typeof n=="string"?n:null):null;function es(n){return new Proxy(new tu(n),Ni)}const A=(n,e=null)=>Yc(n,e),Ws=(n,e=null)=>new Zc(n,e),bt=(n,e=null)=>new Kc(n,e),y=(...n)=>new Jc(...n),S=(...n)=>new Qc(...n),x=n=>{const e=new es(n),t=(...s)=>{let o;return Ws(s),s[0]&&s[0].isNode?o=[...s]:o=s[0],e.call(o)};return t.shaderNode=e,t.setLayout=s=>(e.setLayout(s),t),t};T("ShaderNode",es);const Vo=n=>{Bt=n},ru=()=>Bt,P=(...n)=>Bt.if(...n);function cu(n){return Bt&&Bt.add(n),n}N("append",cu);const uu=new H("color"),d=new H("float",Gs.float),h=new H("int",Gs.ints),w=new H("uint",Gs.uint),Vt=new H("bool",Gs.bool),E=new H("vec2"),Tt=new H("ivec2"),lu=new H("uvec2"),du=new H("bvec2"),f=new H("vec3"),hu=new H("ivec3"),ls=new H("uvec3"),xi=new H("bvec3"),M=new H("vec4"),pu=new H("ivec4"),mu=new H("uvec4"),gu=new H("bvec4"),Kn=new H("mat2"),fu=new H("imat2"),Nu=new H("umat2"),yu=new H("bmat2"),Xe=new H("mat3"),xu=new H("imat3"),vu=new H("umat3"),Tu=new H("bmat3"),zt=new H("mat4"),Su=new H("imat4"),Vu=new H("umat4"),_u=new H("bmat4"),Ru=(n="")=>A(new ke(n,"string")),Au=n=>A(new ke(n,"ArrayBuffer"));N("color",uu);N("float",d);N("int",h);N("uint",w);N("bool",Vt);N("vec2",E);N("ivec2",Tt);N("uvec2",lu);N("bvec2",du);N("vec3",f);N("ivec3",hu);N("uvec3",ls);N("bvec3",xi);N("vec4",M);N("ivec4",pu);N("uvec4",mu);N("bvec4",gu);N("mat2",Kn);N("imat2",fu);N("umat2",Nu);N("bmat2",yu);N("mat3",Xe);N("imat3",xu);N("umat3",vu);N("bmat3",Tu);N("mat4",zt);N("imat4",Su);N("umat4",Vu);N("bmat4",_u);N("string",Ru);N("arrayBuffer",Au);const wu=y(Wt),Mu=(n,e)=>A(new Xn(A(n),e));N("element",wu);N("convert",Mu);class vi extends j{constructor(e,t){super(),this.targetNode=e,this.sourceNode=t}hasDependencies(){return!1}getNodeType(e,t){return t!=="void"?this.targetNode.getNodeType(e):"void"}needsSplitAssign(e){const{targetNode:t}=this;if(e.isAvailable("swizzleAssign")===!1&&t.isSplitNode&&t.components.length>1){const s=e.getTypeLength(t.node.getNodeType(e));return Us.join("").slice(0,s)!==t.components}return!1}generate(e,t){const{targetNode:s,sourceNode:o}=this,i=this.needsSplitAssign(e),a=s.getNodeType(e),r=s.context({assign:!0}).build(e),c=o.build(e,a),u=o.getNodeType(e),l=e.getDataFromNode(this);let p;if(l.initialized===!0)t!=="void"&&(p=r);else if(i){const g=e.getVarFromNode(this,null,a),_=e.getPropertyName(g);e.addLineFlowCode(`${_} = ${c}`);const V=s.node.context({assign:!0}).build(e);for(let R=0;R<s.components.length;R++){const I=s.components[R];e.addLineFlowCode(`${V}.${I} = ${_}[ ${R} ]`)}t!=="void"&&(p=r)}else p=`${r} = ${c}`,(t==="void"||u==="void")&&(e.addLineFlowCode(p),t!=="void"&&(p=r));return l.initialized=!0,e.format(p,a,t)}}const Cu=y(vi);T("AssignNode",vi);N("assign",Cu);class Ti extends L{constructor(e,t=null){super(),this.node=e,this.name=t,this.isVaryingNode=!0}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{name:t,node:s}=this,o=this.getNodeType(e),i=e.getVaryingFromNode(this,t,o);i.needsInterpolation||(i.needsInterpolation=e.shaderStage==="fragment");const a=e.getPropertyName(i,No.VERTEX);return e.flowNodeFromShaderStage(No.VERTEX,s,o,a),e.getPropertyName(i)}}const oe=y(Ti);N("varying",oe);T("VaryingNode",Ti);class Hs extends L{constructor(e,t=null){super(t),this._attributeName=e}isGlobal(){return!0}getHash(e){return this.getAttributeName(e)}getNodeType(e){let t=super.getNodeType(e);if(t===null){const s=this.getAttributeName(e);if(e.hasGeometryAttribute(s)){const o=e.geometry.getAttribute(s);t=e.getTypeFromAttribute(o)}else t="float"}return t}setAttributeName(e){return this._attributeName=e,this}getAttributeName(){return this._attributeName}generate(e){const t=this.getAttributeName(e),s=this.getNodeType(e);if(e.hasGeometryAttribute(t)===!0){const i=e.geometry.getAttribute(t),a=e.getTypeFromAttribute(i),r=e.getAttribute(t,a);return e.shaderStage==="vertex"?e.format(r.name,a,s):oe(this).build(e,s)}else return console.warn(`AttributeNode: Vertex attribute "${t}" not found on geometry.`),e.generateConst(s)}}const Te=(n,e)=>A(new Hs(n,e));T("AttributeNode",Hs);class Si extends L{constructor(e,t){super(),this.isBypassNode=!0,this.outputNode=e,this.callNode=t}getNodeType(e){return this.outputNode.getNodeType(e)}generate(e){const t=this.callNode.build(e,"void");return t!==""&&e.addLineFlowCode(t),this.outputNode.build(e)}}const Vi=y(Si);N("bypass",Vi);T("BypassNode",Si);let Eu=0;class Lu{constructor(){this.id=Eu++,this.nodesData=new WeakMap}getNodeData(e){return this.nodesData.get(e)}setNodeData(e,t){this.nodesData.set(e,t)}}class _i extends L{constructor(e,t=new Lu){super(),this.isCacheNode=!0,this.node=e,this.cache=t}getNodeType(e){return this.node.getNodeType(e)}build(e,...t){const s=e.getCache(),o=this.cache||e.globalCache;e.setCache(o);const i=this.node.build(e,...t);return e.setCache(s),i}}const As=y(_i),Iu=n=>As(n,null);N("cache",As);N("globalCache",Iu);T("CacheNode",_i);class Jn extends L{constructor(e,t={}){super(),this.isContextNode=!0,this.node=e,this.context=t}getNodeType(e){return this.node.getNodeType(e)}setup(e){const t=e.getContext();e.setContext({...e.context,...this.context});const s=this.node.build(e);return e.setContext(t),s}generate(e,t){const s=e.getContext();e.setContext({...e.context,...this.context});const o=this.node.build(e,t);return e.setContext(s),o}}const it=y(Jn),Ou=(n,e)=>it(n,{label:e});N("context",it);N("label",Ou);T("ContextNode",Jn);class et extends L{constructor(e){super("uint"),this.scope=e,this.isInstanceIndexNode=!0}generate(e){const t=this.getNodeType(e),s=this.scope;let o;if(s===et.VERTEX)o=e.getVertexIndex();else if(s===et.INSTANCE)o=e.getInstanceIndex();else throw new Error("THREE.IndexNode: Unknown scope: "+s);let i;return e.shaderStage==="vertex"||e.shaderStage==="compute"?i=o:i=oe(this).build(e,t),i}}et.VERTEX="vertex";et.INSTANCE="instance";const bu=S(et,et.VERTEX),Ri=S(et,et.INSTANCE);T("IndexNode",et);class Qn{start(){}finish(){}direct(){}indirectDiffuse(){}indirectSpecular(){}ambientOcclusion(){}}class Ai extends L{constructor(e,t=null){super(),this.node=e,this.name=t,this.isVarNode=!0}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{node:t,name:s}=this,o=e.getVarFromNode(this,s,e.getVectorType(this.getNodeType(e))),i=e.getPropertyName(o),a=t.build(e,o.type);return e.addLineFlowCode(`${i} = ${a}`),i}}const os=y(Ai);N("temp",os);N("toVar",(...n)=>os(...n).append());T("VarNode",Ai);class W extends L{constructor(e,t=null,s=!1){super(e),this.name=t,this.varying=s,this.isPropertyNode=!0}getHash(e){return this.name||super.getHash(e)}isGlobal(){return!0}generate(e){let t;return this.varying===!0?(t=e.getVaryingFromNode(this,this.name),t.needsInterpolation=!0):t=e.getVarFromNode(this,this.name),e.getPropertyName(t)}}const fe=(n,e)=>A(new W(n,e)),Ze=(n,e)=>A(new W(n,e,!0)),te=S(W,"vec4","DiffuseColor"),ht=S(W,"float","Roughness"),ws=S(W,"float","Metalness"),Rn=S(W,"float","Clearcoat"),Ms=S(W,"float","ClearcoatRoughness"),Lt=S(W,"vec3","Sheen"),eo=S(W,"float","SheenRoughness"),to=S(W,"float","Iridescence"),wi=S(W,"float","IridescenceIOR"),Mi=S(W,"float","IridescenceThickness"),An=S(W,"float","AlphaT"),xt=S(W,"float","Anisotropy"),vs=S(W,"vec3","AnisotropyT"),Dt=S(W,"vec3","AnisotropyB"),We=S(W,"color","SpecularColor"),Cs=S(W,"float","SpecularF90"),wn=S(W,"float","Shininess"),zu=S(W,"vec4","Output"),Pt=S(W,"float","dashSize"),Es=S(W,"float","gapSize");S(W,"float","pointWidth");const Ts=S(W,"float","IOR"),Mn=S(W,"float","Transmission"),Ci=S(W,"float","Thickness"),Ei=S(W,"float","AttenuationDistance"),Li=S(W,"color","AttenuationColor");T("PropertyNode",W);class Du extends W{constructor(e,t=null){super(e,t),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}T("ParameterNode",Du);class so extends L{constructor(e="",t=[],s=""){super("code"),this.isCodeNode=!0,this.code=e,this.language=s,this.includes=t}isGlobal(){return!0}setIncludes(e){return this.includes=e,this}getIncludes(){return this.includes}generate(e){const t=this.getIncludes(e);for(const o of t)o.build(e);const s=e.getCodeFromNode(this,this.getNodeType(e));return s.code=this.code,s.code}serialize(e){super.serialize(e),e.code=this.code,e.language=this.language}deserialize(e){super.deserialize(e),this.code=e.code,this.language=e.language}}y(so);T("CodeNode",so);class Pu extends so{constructor(e="",t=[],s=""){super(e,t,s),this.keywords={}}getNodeType(e){return this.getNodeFunction(e).type}getInputs(e){return this.getNodeFunction(e).inputs}getNodeFunction(e){const t=e.getDataFromNode(this);let s=t.nodeFunction;return s===void 0&&(s=e.parser.parseFunction(this.code),t.nodeFunction=s),s}generate(e,t){super.generate(e);const s=this.getNodeFunction(e),o=s.name,i=s.type,a=e.getCodeFromNode(this,i);o!==""&&(a.name=o);const r=e.getPropertyName(a);let c=this.getNodeFunction(e).getCode(r);const u=this.keywords,l=Object.keys(u);if(l.length>0)for(const p of l){const g=new RegExp(`\\b${p}\\b`,"g"),_=u[p].build(e,"property");c=c.replace(g,_)}return a.code=c+`
`,t==="property"?r:e.format(`${r}()`,i,t)}}T("FunctionNode",Pu);class no extends L{constructor(e,t=!1){super("string"),this.name=e,this.version=0,this.shared=t,this.isUniformGroup=!0}set needsUpdate(e){e===!0&&this.version++}}const Fu=n=>new no(n),Ii=n=>new no(n,!0);Ii("frame");Ii("render");const Uu=Fu("object");T("UniformGroupNode",no);class At extends Bs{constructor(e,t=null){super(e,t),this.isUniformNode=!0,this.groupNode=Uu}setGroup(e){return this.groupNode=e,this}getGroup(){return this.groupNode}getUniformHash(e){return this.getHash(e)}onUpdate(e,t){const s=this.getSelf();return e=e.bind(s),super.onUpdate(o=>{const i=e(o,s);i!==void 0&&(this.value=i)},t)}generate(e,t){const s=this.getNodeType(e),o=this.getUniformHash(e);let i=e.getNodeFromHash(o);i===void 0&&(e.setHashNode(this,o),i=this);const a=i.getInputType(e),r=e.getUniformFromNode(i,a,e.shaderStage,e.context.label),c=e.getPropertyName(r);return e.context.label!==void 0&&delete e.context.label,e.format(c,s,t)}}const X=(n,e)=>{const t=au(e||n),s=n&&n.isNode===!0?n.node&&n.node.value||n.value:n;return A(new At(s,t))};T("UniformNode",At);class Oi extends Hs{constructor(e=0){super(null,"vec2"),this.isUVNode=!0,this.index=e}getAttributeName(){const e=this.index;return"uv"+(e>0?e:"")}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}const st=(...n)=>A(new Oi(...n));T("UVNode",Oi);class bi extends L{constructor(e,t=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=e,this.levelNode=t}generate(e,t){const s=this.textureNode.build(e,"property"),o=this.levelNode.build(e,"int");return e.format(`${e.getMethod("textureDimensions")}( ${s}, ${o} )`,this.getNodeType(e),t)}}const oo=y(bi);N("textureSize",oo);T("TextureSizeNode",bi);class ee extends j{constructor(e,t,s,...o){if(super(),this.op=e,o.length>0){let i=s;for(let a=0;a<o.length;a++)i=new ee(e,i,o[a]);s=i}this.aNode=t,this.bNode=s}getNodeType(e,t){const s=this.op,o=this.aNode,i=this.bNode,a=o.getNodeType(e),r=typeof i<"u"?i.getNodeType(e):null;if(a==="void"||r==="void")return"void";if(s==="%")return a;if(s==="~"||s==="&"||s==="|"||s==="^"||s===">>"||s==="<<")return e.getIntegerType(a);if(s==="!"||s==="=="||s==="&&"||s==="||"||s==="^^")return"bool";if(s==="<"||s===">"||s==="<="||s===">="){const c=t?e.getTypeLength(t):Math.max(e.getTypeLength(a),e.getTypeLength(r));return c>1?`bvec${c}`:"bool"}else return a==="float"&&e.isMatrix(r)?r:e.isMatrix(a)&&e.isVector(r)?e.getVectorFromMatrix(a):e.isVector(a)&&e.isMatrix(r)?e.getVectorFromMatrix(r):e.getTypeLength(r)>e.getTypeLength(a)?r:a}generate(e,t){const s=this.op,o=this.aNode,i=this.bNode,a=this.getNodeType(e,t);let r=null,c=null;a!=="void"?(r=o.getNodeType(e),c=typeof i<"u"?i.getNodeType(e):null,s==="<"||s===">"||s==="<="||s===">="||s==="=="?e.isVector(r)?c=r:r=c="float":s===">>"||s==="<<"?(r=a,c=e.changeComponentType(c,"uint")):e.isMatrix(r)&&e.isVector(c)?c=e.getVectorFromMatrix(r):e.isVector(r)&&e.isMatrix(c)?r=e.getVectorFromMatrix(c):r=c=a):r=c=a;const u=o.build(e,r),l=typeof i<"u"?i.build(e,c):null,p=e.getTypeLength(t),g=e.getFunctionOperator(s);if(t!=="void")return s==="<"&&p>1?e.format(`${e.getMethod("lessThan")}( ${u}, ${l} )`,a,t):s==="<="&&p>1?e.format(`${e.getMethod("lessThanEqual")}( ${u}, ${l} )`,a,t):s===">"&&p>1?e.format(`${e.getMethod("greaterThan")}( ${u}, ${l} )`,a,t):s===">="&&p>1?e.format(`${e.getMethod("greaterThanEqual")}( ${u}, ${l} )`,a,t):s==="!"||s==="~"?e.format(`(${s}${u})`,r,t):g?e.format(`${g}( ${u}, ${l} )`,a,t):e.format(`( ${u} ${s} ${l} )`,a,t);if(r!=="void")return g?e.format(`${g}( ${u}, ${l} )`,a,t):e.format(`${u} ${s} ${l}`,a,t)}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}const De=y(ee,"+"),re=y(ee,"-"),U=y(ee,"*"),mt=y(ee,"/"),Bu=y(ee,"%"),ku=y(ee,"=="),Gu=y(ee,"!="),Wu=y(ee,"<"),zi=y(ee,">"),Hu=y(ee,"<="),qu=y(ee,">="),$u=y(ee,"&&"),Xu=y(ee,"||"),ju=y(ee,"!"),Yu=y(ee,"^^"),Zu=y(ee,"&"),Ku=y(ee,"~"),Ju=y(ee,"|"),Qu=y(ee,"^"),el=y(ee,"<<"),tl=y(ee,">>");N("add",De);N("sub",re);N("mul",U);N("div",mt);N("remainder",Bu);N("equal",ku);N("notEqual",Gu);N("lessThan",Wu);N("greaterThan",zi);N("lessThanEqual",Hu);N("greaterThanEqual",qu);N("and",$u);N("or",Xu);N("not",ju);N("xor",Yu);N("bitAnd",Zu);N("bitNot",Ku);N("bitOr",Ju);N("bitXor",Qu);N("shiftLeft",el);N("shiftRight",tl);T("OperatorNode",ee);class m extends j{constructor(e,t,s=null,o=null){super(),this.method=e,this.aNode=t,this.bNode=s,this.cNode=o}getInputType(e){const t=this.aNode.getNodeType(e),s=this.bNode?this.bNode.getNodeType(e):null,o=this.cNode?this.cNode.getNodeType(e):null,i=e.isMatrix(t)?0:e.getTypeLength(t),a=e.isMatrix(s)?0:e.getTypeLength(s),r=e.isMatrix(o)?0:e.getTypeLength(o);return i>a&&i>r?t:a>r?s:r>i?o:t}getNodeType(e){const t=this.method;return t===m.LENGTH||t===m.DISTANCE||t===m.DOT?"float":t===m.CROSS?"vec3":t===m.ALL?"bool":t===m.EQUALS?e.changeComponentType(this.aNode.getNodeType(e),"bool"):t===m.MOD?this.aNode.getNodeType(e):this.getInputType(e)}generate(e,t){const s=this.method,o=this.getNodeType(e),i=this.getInputType(e),a=this.aNode,r=this.bNode,c=this.cNode,u=e.renderer.isWebGLRenderer===!0;if(s===m.TRANSFORM_DIRECTION){let l=a,p=r;e.isMatrix(l.getNodeType(e))?p=M(f(p),0):l=M(f(l),0);const g=U(l,p).xyz;return _e(g).build(e,t)}else{if(s===m.NEGATE)return e.format("( - "+a.build(e,i)+" )",o,t);if(s===m.ONE_MINUS)return re(1,a).build(e,t);if(s===m.RECIPROCAL)return mt(1,a).build(e,t);if(s===m.DIFFERENCE)return ue(re(a,r)).build(e,t);{const l=[];return s===m.CROSS||s===m.MOD?l.push(a.build(e,o),r.build(e,o)):s===m.STEP?l.push(a.build(e,e.getTypeLength(a.getNodeType(e))===1?"float":i),r.build(e,i)):u&&(s===m.MIN||s===m.MAX)||s===m.MOD?l.push(a.build(e,i),r.build(e,e.getTypeLength(r.getNodeType(e))===1?"float":i)):s===m.REFRACT?l.push(a.build(e,i),r.build(e,i),c.build(e,"float")):s===m.MIX?l.push(a.build(e,i),r.build(e,i),c.build(e,e.getTypeLength(c.getNodeType(e))===1?"float":i)):(l.push(a.build(e,i)),r!==null&&l.push(r.build(e,i)),c!==null&&l.push(c.build(e,i))),e.format(`${e.getMethod(s,o)}( ${l.join(", ")} )`,o,t)}}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}m.ALL="all";m.ANY="any";m.EQUALS="equals";m.RADIANS="radians";m.DEGREES="degrees";m.EXP="exp";m.EXP2="exp2";m.LOG="log";m.LOG2="log2";m.SQRT="sqrt";m.INVERSE_SQRT="inversesqrt";m.FLOOR="floor";m.CEIL="ceil";m.NORMALIZE="normalize";m.FRACT="fract";m.SIN="sin";m.COS="cos";m.TAN="tan";m.ASIN="asin";m.ACOS="acos";m.ATAN="atan";m.ABS="abs";m.SIGN="sign";m.LENGTH="length";m.NEGATE="negate";m.ONE_MINUS="oneMinus";m.DFDX="dFdx";m.DFDY="dFdy";m.ROUND="round";m.RECIPROCAL="reciprocal";m.TRUNC="trunc";m.FWIDTH="fwidth";m.BITCAST="bitcast";m.ATAN2="atan2";m.MIN="min";m.MAX="max";m.MOD="mod";m.STEP="step";m.REFLECT="reflect";m.DISTANCE="distance";m.DIFFERENCE="difference";m.DOT="dot";m.CROSS="cross";m.POW="pow";m.TRANSFORM_DIRECTION="transformDirection";m.MIX="mix";m.CLAMP="clamp";m.REFRACT="refract";m.SMOOTHSTEP="smoothstep";m.FACEFORWARD="faceforward";const Di=d(1e-6);d(1e6);const _o=d(Math.PI);d(Math.PI*2);const Pi=y(m,m.ALL),sl=y(m,m.ANY),nl=y(m,m.EQUALS),ol=y(m,m.RADIANS),il=y(m,m.DEGREES),Fi=y(m,m.EXP),Cn=y(m,m.EXP2),Ui=y(m,m.LOG),qs=y(m,m.LOG2),wt=y(m,m.SQRT),al=y(m,m.INVERSE_SQRT),Ht=y(m,m.FLOOR),Bi=y(m,m.CEIL),_e=y(m,m.NORMALIZE),$s=y(m,m.FRACT),nt=y(m,m.SIN),ct=y(m,m.COS),rl=y(m,m.TAN),cl=y(m,m.ASIN),ul=y(m,m.ACOS),ll=y(m,m.ATAN),ue=y(m,m.ABS),io=y(m,m.SIGN),ts=y(m,m.LENGTH),dl=y(m,m.NEGATE),hl=y(m,m.ONE_MINUS),pl=y(m,m.DFDX),ml=y(m,m.DFDY),gl=y(m,m.ROUND),fl=y(m,m.RECIPROCAL),ki=y(m,m.TRUNC),Nl=y(m,m.FWIDTH);y(m,m.BITCAST);const yl=y(m,m.ATAN2),kt=y(m,m.MIN),Pe=y(m,m.MAX),xl=y(m,m.MOD),vl=y(m,m.STEP),Tl=y(m,m.REFLECT),Sl=y(m,m.DISTANCE),Vl=y(m,m.DIFFERENCE),qt=y(m,m.DOT),Gi=y(m,m.CROSS),Qe=y(m,m.POW),Wi=y(m,m.POW,2),_l=y(m,m.POW,3),Rl=y(m,m.POW,4),Al=y(m,m.TRANSFORM_DIRECTION),wl=n=>U(io(n),Qe(ue(n),1/3)),Ml=n=>qt(n,n),xe=y(m,m.MIX),Gt=(n,e=0,t=1)=>A(new m(m.CLAMP,A(n),A(e),A(t))),Cl=n=>Gt(n),Hi=y(m,m.REFRACT),at=y(m,m.SMOOTHSTEP),El=y(m,m.FACEFORWARD),Ll=(n,e,t)=>xe(e,t,n),Il=(n,e,t)=>at(e,t,n);N("all",Pi);N("any",sl);N("equals",nl);N("radians",ol);N("degrees",il);N("exp",Fi);N("exp2",Cn);N("log",Ui);N("log2",qs);N("sqrt",wt);N("inverseSqrt",al);N("floor",Ht);N("ceil",Bi);N("normalize",_e);N("fract",$s);N("sin",nt);N("cos",ct);N("tan",rl);N("asin",cl);N("acos",ul);N("atan",ll);N("abs",ue);N("sign",io);N("length",ts);N("lengthSq",Ml);N("negate",dl);N("oneMinus",hl);N("dFdx",pl);N("dFdy",ml);N("round",gl);N("reciprocal",fl);N("trunc",ki);N("fwidth",Nl);N("atan2",yl);N("min",kt);N("max",Pe);N("mod",xl);N("step",vl);N("reflect",Tl);N("distance",Sl);N("dot",qt);N("cross",Gi);N("pow",Qe);N("pow2",Wi);N("pow3",_l);N("pow4",Rl);N("transformDirection",Al);N("mix",Ll);N("clamp",Gt);N("refract",Hi);N("smoothstep",Il);N("faceForward",El);N("difference",Vl);N("saturate",Cl);N("cbrt",wl);T("MathNode",m);const Ol=x(n=>{const{value:e}=n,{rgb:t}=e,s=t.mul(.9478672986).add(.0521327014).pow(2.4),o=t.mul(.0773993808),i=t.lessThanEqual(.04045),a=xe(s,o,i);return M(a,e.a)}),bl=x(n=>{const{value:e}=n,{rgb:t}=e,s=t.pow(.41666).mul(1.055).sub(.055),o=t.mul(12.92),i=t.lessThanEqual(.0031308),a=xe(s,o,i);return M(a,e.a)}),Ro=n=>{let e=null;return n===qn?e="Linear":n===uc&&(e="sRGB"),e},qi=(n,e)=>Ro(n)+"To"+Ro(e);class Le extends j{constructor(e,t){super("vec4"),this.method=e,this.node=t}setup(){const{method:e,node:t}=this;return e===Le.LINEAR_TO_LINEAR?t:zl[e]({value:t})}}Le.LINEAR_TO_LINEAR="LinearToLinear";Le.LINEAR_TO_sRGB="LinearTosRGB";Le.sRGB_TO_LINEAR="sRGBToLinear";const zl={[Le.LINEAR_TO_sRGB]:bl,[Le.sRGB_TO_LINEAR]:Ol},Dl=(n,e)=>A(new Le(qi(qn,e),A(n))),$i=(n,e)=>A(new Le(qi(e,qn),A(n))),Pl=y(Le,Le.LINEAR_TO_sRGB),Fl=y(Le,Le.sRGB_TO_LINEAR);N("linearTosRGB",Pl);N("sRGBToLinear",Fl);N("linearToColorSpace",Dl);N("colorSpaceToLinear",$i);T("ColorSpaceNode",Le);class Xi extends L{constructor(e="",t="void"){super(t),this.snippet=e}generate(e,t){const s=this.getNodeType(e),o=this.snippet;if(s==="void")e.addLineFlowCode(o);else return e.format(`( ${o} )`,s,t)}}const Xs=y(Xi);T("ExpressionNode",Xi);class ji extends At{constructor(e){super(0),this.textureNode=e,this.updateType=$.FRAME}get texture(){return this.textureNode.value}update(){const e=this.texture,t=e.images,s=t&&t.length>0?t[0]&&t[0].image||t[0]:e.image;if(s&&s.width!==void 0){const{width:o,height:i}=s;this.value=Math.log2(Math.max(o,i))}}}const Ul=y(ji);T("MaxMipLevelNode",ji);class $t extends At{constructor(e,t=null,s=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=s,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=$.NONE,this.referenceNode=null,this._value=e,this.setUpdateMatrix(t===null)}set value(e){this.referenceNode?this.referenceNode.value=e:this._value=e}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return this.value.isDepthTexture===!0?"float":"vec4"}getInputType(){return"texture"}getDefaultUV(){return st(this.value.channel)}updateReference(){return this.value}getTransformedUV(e){const t=this.value;return X(t.matrix).mul(f(e,1)).xy}setUpdateMatrix(e){return this.updateMatrix=e,this.updateType=e?$.FRAME:$.NONE,this}setupUV(e,t){const s=this.value;return e.isFlipY()&&(s.isRenderTargetTexture===!0||s.isFramebufferTexture===!0||s.isDepthTexture===!0)&&(t=t.setY(t.y.oneMinus())),t}setup(e){const t=e.getNodeProperties(this);let s=this.uvNode;(s===null||e.context.forceUVContext===!0)&&e.context.getUV&&(s=e.context.getUV(this)),s||(s=this.getDefaultUV()),this.updateMatrix===!0&&(s=this.getTransformedUV(s)),s=this.setupUV(e,s);let o=this.levelNode;o===null&&e.context.getTextureLevel&&(o=e.context.getTextureLevel(this)),t.uvNode=s,t.levelNode=o,t.compareNode=this.compareNode,t.gradNode=this.gradNode,t.depthNode=this.depthNode}generateUV(e,t){return t.build(e,this.sampler===!0?"vec2":"ivec2")}generateSnippet(e,t,s,o,i,a,r){const c=this.value;let u;return o?u=e.generateTextureLevel(c,t,s,o,i):r?u=e.generateTextureGrad(c,t,s,r,i):a?u=e.generateTextureCompare(c,t,s,a,i):this.sampler===!1?u=e.generateTextureLoad(c,t,s,i):u=e.generateTexture(c,t,s,i),u}generate(e,t){const s=e.getNodeProperties(this),o=this.value;if(!o||o.isTexture!==!0)throw new Error("TextureNode: Need a three.js texture.");const i=super.generate(e,"property");if(t==="sampler")return i+"_sampler";if(e.isReference(t))return i;{const a=e.getDataFromNode(this);let r=a.propertyName;if(r===void 0){const{uvNode:l,levelNode:p,compareNode:g,depthNode:_,gradNode:V}=s,R=this.generateUV(e,l),I=p?p.build(e,"float"):null,C=_?_.build(e,"int"):null,z=g?g.build(e,"float"):null,O=V?[V[0].build(e,"vec2"),V[1].build(e,"vec2")]:null,B=e.getVarFromNode(this);r=e.getPropertyName(B);const K=this.generateSnippet(e,i,R,I,C,z,O);e.addLineFlowCode(`${r} = ${K}`),e.context.tempWrite!==!1&&(a.snippet=K,a.propertyName=r)}let c=r;const u=this.getNodeType(e);return e.needsColorSpaceToLinear(o)&&(c=$i(Xs(c,u),o.colorSpace).setup(e).build(e,u)),e.format(c,u,t)}}setSampler(e){return this.sampler=e,this}getSampler(){return this.sampler}uv(e){const t=this.clone();return t.uvNode=e,t.referenceNode=this,A(t)}blur(e){const t=this.clone();return t.levelNode=e.mul(Ul(t)),t.referenceNode=this,A(t)}level(e){const t=this.clone();return t.levelNode=e,t.referenceNode=this,t}size(e){return oo(this,e)}compare(e){const t=this.clone();return t.compareNode=A(e),t.referenceNode=this,A(t)}grad(e,t){const s=this.clone();return s.gradNode=[A(e),A(t)],s.referenceNode=this,A(s)}depth(e){const t=this.clone();return t.depthNode=A(e),t.referenceNode=this,A(t)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value]}update(){const e=this.value;e.matrixAutoUpdate===!0&&e.updateMatrix()}clone(){const e=new this.constructor(this.value,this.uvNode,this.levelNode);return e.sampler=this.sampler,e}}const ze=y($t),vt=(...n)=>ze(...n).setSampler(!1);N("texture",ze);T("TextureNode",$t);class js extends At{constructor(e,t,s=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferCount=s}getInputType(){return"buffer"}}const ao=(n,e,t)=>A(new js(n,e,t));T("BufferNode",js);class Bl extends Wt{constructor(e,t){super(e,t),this.isArrayBufferElementNode=!0}getNodeType(e){return this.node.getElementType(e)}generate(e){const t=super.generate(e),s=this.getNodeType();return e.format(t,"vec4",s)}}class Yi extends js{constructor(e,t=null){super(null,"vec4"),this.array=e,this.elementType=t,this._elementType=null,this._elementLength=0,this.updateType=$.RENDER,this.isArrayBufferNode=!0}getElementType(){return this.elementType||this._elementType}getElementLength(){return this._elementLength}update(){const{array:e,value:t}=this,s=this.getElementLength(),o=this.getElementType();if(s===1)for(let i=0;i<e.length;i++){const a=i*4;t[a]=e[i]}else if(o==="color")for(let i=0;i<e.length;i++){const a=i*4,r=e[i];t[a]=r.r,t[a+1]=r.g,t[a+2]=r.b||0}else for(let i=0;i<e.length;i++){const a=i*4,r=e[i];t[a]=r.x,t[a+1]=r.y,t[a+2]=r.z||0,t[a+3]=r.w||0}}setup(e){const t=this.array.length;return this._elementType=this.elementType===null?dt(this.array[0]):this.elementType,this._elementLength=e.getTypeLength(this._elementType),this.value=new Float32Array(t*4),this.bufferCount=t,super.setup(e)}element(e){return A(new Bl(this,A(e)))}}const En=(n,e)=>A(new Yi(n,e));T("UniformsNode",Yi);class kl extends Wt{constructor(e,t){super(e,t),this.referenceNode=e,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(e){const t=super.generate(e),s=this.referenceNode.getNodeType(),o=this.getNodeType();return e.format(t,s,o)}}class Xt extends L{constructor(e,t,s=null,o=null){super(),this.property=e,this.uniformType=t,this.object=s,this.count=o,this.properties=e.split("."),this.reference=null,this.node=null,this.updateType=$.OBJECT}element(e){return A(new kl(this,A(e)))}setNodeType(e){let t=null;this.count!==null?t=ao(null,e,this.count):Array.isArray(this.getValueFromReference())?t=En(null,e):e==="texture"?t=ze(null):t=X(null,e),this.node=t}getNodeType(e){return this.node.getNodeType(e)}getValueFromReference(e=this.reference){const{properties:t}=this;let s=e[t[0]];for(let o=1;o<t.length;o++)s=s[t[o]];return s}updateReference(e){return this.reference=this.object!==null?this.object:e.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const e=this.getValueFromReference();Array.isArray(e)?this.node.array=e:this.node.value=e}}const je=(n,e,t)=>A(new Xt(n,e,t)),Gl=(n,e,t,s)=>A(new Xt(n,e,s,t));T("ReferenceNode",Xt);class Zi extends Xt{constructor(e,t,s=null){super(e,t,s),this.material=s}updateReference(e){return this.reference=this.material!==null?this.material:e.material,this.reference}}const Ki=(n,e,t)=>A(new Zi(n,e,t));T("MaterialReferenceNode",Zi);class b extends L{constructor(e=b.VIEW_MATRIX,t=null){super(),this.scope=e,this.object3d=t,this.updateType=$.OBJECT,this._uniformNode=new At(null)}getNodeType(){const e=this.scope;if(e===b.WORLD_MATRIX||e===b.VIEW_MATRIX)return"mat4";if(e===b.NORMAL_MATRIX)return"mat3";if(e===b.POSITION||e===b.VIEW_POSITION||e===b.DIRECTION||e===b.SCALE)return"vec3"}update(e){const t=this.object3d,s=this._uniformNode,o=this.scope;if(o===b.VIEW_MATRIX)s.value=t.modelViewMatrix;else if(o===b.NORMAL_MATRIX)s.value=t.normalMatrix;else if(o===b.WORLD_MATRIX)s.value=t.matrixWorld;else if(o===b.POSITION)s.value=s.value||new He,s.value.setFromMatrixPosition(t.matrixWorld);else if(o===b.SCALE)s.value=s.value||new He,s.value.setFromMatrixScale(t.matrixWorld);else if(o===b.DIRECTION)s.value=s.value||new He,t.getWorldDirection(s.value);else if(o===b.VIEW_POSITION){const i=e.camera;s.value=s.value||new He,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(i.matrixWorldInverse)}}generate(e){const t=this.scope;return t===b.WORLD_MATRIX||t===b.VIEW_MATRIX?this._uniformNode.nodeType="mat4":t===b.NORMAL_MATRIX?this._uniformNode.nodeType="mat3":(t===b.POSITION||t===b.VIEW_POSITION||t===b.DIRECTION||t===b.SCALE)&&(this._uniformNode.nodeType="vec3"),this._uniformNode.build(e)}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}b.VIEW_MATRIX="viewMatrix";b.NORMAL_MATRIX="normalMatrix";b.WORLD_MATRIX="worldMatrix";b.POSITION="position";b.SCALE="scale";b.VIEW_POSITION="viewPosition";b.DIRECTION="direction";y(b,b.DIRECTION);y(b,b.VIEW_MATRIX);y(b,b.NORMAL_MATRIX);y(b,b.WORLD_MATRIX);const Ln=y(b,b.POSITION);y(b,b.SCALE);const Ji=y(b,b.VIEW_POSITION);T("Object3DNode",b);class D extends b{constructor(e=D.POSITION){super(e),this.updateType=$.RENDER}getNodeType(e){const t=this.scope;return t===D.PROJECTION_MATRIX||t===D.PROJECTION_MATRIX_INVERSE?"mat4":t===D.NEAR||t===D.FAR||t===D.LOG_DEPTH?"float":super.getNodeType(e)}update(e){const t=e.camera,s=this._uniformNode,o=this.scope;o===D.VIEW_MATRIX?s.value=t.matrixWorldInverse:o===D.PROJECTION_MATRIX?s.value=t.projectionMatrix:o===D.PROJECTION_MATRIX_INVERSE?s.value=t.projectionMatrixInverse:o===D.NEAR?s.value=t.near:o===D.FAR?s.value=t.far:o===D.LOG_DEPTH?s.value=2/(Math.log(t.far+1)/Math.LN2):(this.object3d=t,super.update(e))}generate(e){const t=this.scope;return t===D.PROJECTION_MATRIX||t===D.PROJECTION_MATRIX_INVERSE?this._uniformNode.nodeType="mat4":(t===D.NEAR||t===D.FAR||t===D.LOG_DEPTH)&&(this._uniformNode.nodeType="float"),super.generate(e)}}D.PROJECTION_MATRIX="projectionMatrix";D.PROJECTION_MATRIX_INVERSE="projectionMatrixInverse";D.NEAR="near";D.FAR="far";D.LOG_DEPTH="logDepth";const Ke=S(D,D.PROJECTION_MATRIX);S(D,D.PROJECTION_MATRIX_INVERSE);const sn=S(D,D.NEAR),nn=S(D,D.FAR),Wl=S(D,D.LOG_DEPTH),rt=S(D,D.VIEW_MATRIX);S(D,D.NORMAL_MATRIX);S(D,D.WORLD_MATRIX);const Hl=S(D,D.POSITION);T("CameraNode",D);class ve extends b{constructor(e=ve.VIEW_MATRIX){super(e)}update(e){this.object3d=e.object,super.update(e)}}S(ve,ve.DIRECTION);const _t=S(ve,ve.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix"),Qi=S(ve,ve.NORMAL_MATRIX),is=S(ve,ve.WORLD_MATRIX);S(ve,ve.POSITION);S(ve,ve.SCALE);S(ve,ve.VIEW_POSITION);T("ModelNode",ve);class de extends L{constructor(e=de.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`normal-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===de.GEOMETRY)e.hasGeometryAttribute("normal")===!1?s=f(0,1,0):s=Te("normal","vec3");else if(t===de.LOCAL)s=oe(Ls);else if(t===de.VIEW){const o=Qi.mul(Ye);s=_e(oe(o))}else if(t===de.WORLD){const o=gt.transformDirection(rt);s=_e(oe(o))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}de.GEOMETRY="geometry";de.LOCAL="local";de.VIEW="view";de.WORLD="world";const Ls=S(de,de.GEOMETRY),Ye=S(de,de.LOCAL).temp("Normal"),gt=S(de,de.VIEW),ea=S(de,de.WORLD),ie=fe("vec3","TransformedNormalView"),ta=ie.transformDirection(rt).normalize(),It=fe("vec3","TransformedClearcoatNormalView");T("NormalNode",de);const Ao=new Map;class v extends L{constructor(e){super(),this.scope=e}getCache(e,t){let s=Ao.get(e);return s===void 0&&(s=Ki(e,t),Ao.set(e,s)),s}getFloat(e){return this.getCache(e,"float")}getColor(e){return this.getCache(e,"color")}getTexture(e){return this.getCache(e==="map"?"map":e+"Map","texture")}setup(e){const t=e.context.material,s=this.scope;let o=null;if(s===v.COLOR){const i=this.getColor(s);t.map&&t.map.isTexture===!0?o=i.mul(this.getTexture("map")):o=i}else if(s===v.OPACITY){const i=this.getFloat(s);t.alphaMap&&t.alphaMap.isTexture===!0?o=i.mul(this.getTexture("alpha")):o=i}else if(s===v.SPECULAR_STRENGTH)t.specularMap&&t.specularMap.isTexture===!0?o=this.getTexture("specular").r:o=d(1);else if(s===v.SPECULAR_INTENSITY){const i=this.getFloat(s);t.specularMap?o=i.mul(this.getTexture(s).a):o=i}else if(s===v.SPECULAR_COLOR){const i=this.getColor(s);t.specularColorMap&&t.specularColorMap.isTexture===!0?o=i.mul(this.getTexture(s).rgb):o=i}else if(s===v.ROUGHNESS){const i=this.getFloat(s);t.roughnessMap&&t.roughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).g):o=i}else if(s===v.METALNESS){const i=this.getFloat(s);t.metalnessMap&&t.metalnessMap.isTexture===!0?o=i.mul(this.getTexture(s).b):o=i}else if(s===v.EMISSIVE){const i=this.getColor(s);t.emissiveMap&&t.emissiveMap.isTexture===!0?o=i.mul(this.getTexture(s)):o=i}else if(s===v.NORMAL)t.normalMap?o=this.getTexture("normal").normalMap(this.getCache("normalScale","vec2")):t.bumpMap?o=this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")):o=gt;else if(s===v.CLEARCOAT){const i=this.getFloat(s);t.clearcoatMap&&t.clearcoatMap.isTexture===!0?o=i.mul(this.getTexture(s).r):o=i}else if(s===v.CLEARCOAT_ROUGHNESS){const i=this.getFloat(s);t.clearcoatRoughnessMap&&t.clearcoatRoughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).r):o=i}else if(s===v.CLEARCOAT_NORMAL)t.clearcoatNormalMap?o=this.getTexture(s).normalMap(this.getCache(s+"Scale","vec2")):o=gt;else if(s===v.SHEEN){const i=this.getColor("sheenColor").mul(this.getFloat("sheen"));t.sheenColorMap&&t.sheenColorMap.isTexture===!0?o=i.mul(this.getTexture("sheenColor").rgb):o=i}else if(s===v.SHEEN_ROUGHNESS){const i=this.getFloat(s);t.sheenRoughnessMap&&t.sheenRoughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).a):o=i,o=o.clamp(.07,1)}else if(s===v.ANISOTROPY)if(t.anisotropyMap&&t.anisotropyMap.isTexture===!0){const i=this.getTexture(s);o=Kn(Kt.x,Kt.y,Kt.y.negate(),Kt.x).mul(i.rg.mul(2).sub(E(1)).normalize().mul(i.b))}else o=Kt;else if(s===v.IRIDESCENCE_THICKNESS){const i=je("1","float",t.iridescenceThicknessRange);if(t.iridescenceThicknessMap){const a=je("0","float",t.iridescenceThicknessRange);o=i.sub(a).mul(this.getTexture(s).g).add(a)}else o=i}else if(s===v.TRANSMISSION){const i=this.getFloat(s);t.transmissionMap?o=i.mul(this.getTexture(s).r):o=i}else if(s===v.THICKNESS){const i=this.getFloat(s);t.thicknessMap?o=i.mul(this.getTexture(s).g):o=i}else if(s===v.IOR)o=this.getFloat(s);else{const i=this.getNodeType(e);o=this.getCache(s,i)}return o}}v.ALPHA_TEST="alphaTest";v.COLOR="color";v.OPACITY="opacity";v.SHININESS="shininess";v.SPECULAR="specular";v.SPECULAR_STRENGTH="specularStrength";v.SPECULAR_INTENSITY="specularIntensity";v.SPECULAR_COLOR="specularColor";v.REFLECTIVITY="reflectivity";v.ROUGHNESS="roughness";v.METALNESS="metalness";v.NORMAL="normal";v.CLEARCOAT="clearcoat";v.CLEARCOAT_ROUGHNESS="clearcoatRoughness";v.CLEARCOAT_NORMAL="clearcoatNormal";v.EMISSIVE="emissive";v.ROTATION="rotation";v.SHEEN="sheen";v.SHEEN_ROUGHNESS="sheenRoughness";v.ANISOTROPY="anisotropy";v.IRIDESCENCE="iridescence";v.IRIDESCENCE_IOR="iridescenceIOR";v.IRIDESCENCE_THICKNESS="iridescenceThickness";v.IOR="ior";v.TRANSMISSION="transmission";v.THICKNESS="thickness";v.ATTENUATION_DISTANCE="attenuationDistance";v.ATTENUATION_COLOR="attenuationColor";v.LINE_SCALE="scale";v.LINE_DASH_SIZE="dashSize";v.LINE_GAP_SIZE="gapSize";v.LINE_WIDTH="linewidth";v.LINE_DASH_OFFSET="dashOffset";v.POINT_WIDTH="pointWidth";const ql=S(v,v.ALPHA_TEST),as=S(v,v.COLOR),$l=S(v,v.SHININESS),Xl=S(v,v.EMISSIVE),sa=S(v,v.OPACITY),jl=S(v,v.SPECULAR),wo=S(v,v.SPECULAR_INTENSITY),Yl=S(v,v.SPECULAR_COLOR),Zl=S(v,v.SPECULAR_STRENGTH);S(v,v.REFLECTIVITY);const Kl=S(v,v.ROUGHNESS),Jl=S(v,v.METALNESS),Ql=S(v,v.NORMAL),ed=S(v,v.CLEARCOAT),td=S(v,v.CLEARCOAT_ROUGHNESS),sd=S(v,v.CLEARCOAT_NORMAL),nd=S(v,v.ROTATION),od=S(v,v.SHEEN),id=S(v,v.SHEEN_ROUGHNESS),ad=S(v,v.ANISOTROPY),rd=S(v,v.IRIDESCENCE),cd=S(v,v.IRIDESCENCE_IOR),ud=S(v,v.IRIDESCENCE_THICKNESS),ld=S(v,v.TRANSMISSION),dd=S(v,v.THICKNESS),hd=S(v,v.IOR),pd=S(v,v.ATTENUATION_DISTANCE),md=S(v,v.ATTENUATION_COLOR),In=S(v,v.LINE_SCALE),na=S(v,v.LINE_DASH_SIZE),oa=S(v,v.LINE_GAP_SIZE),on=S(v,v.LINE_WIDTH),Mo=S(v,v.LINE_DASH_OFFSET),gd=S(v,v.POINT_WIDTH),Kt=X(new ne).onReference(function(n){return n.material}).onRenderUpdate(function({material:n}){this.value.set(n.anisotropy*Math.cos(n.anisotropyRotation),n.anisotropy*Math.sin(n.anisotropyRotation))});T("MaterialNode",v);class q extends L{constructor(e=q.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`position-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===q.GEOMETRY)s=Te("position","vec3");else if(t===q.LOCAL)s=oe(Ae);else if(t===q.WORLD){const o=is.mul(Se);s=oe(o)}else if(t===q.VIEW){const o=_t.mul(Se);s=oe(o)}else if(t===q.VIEW_DIRECTION){const o=Oe.negate();s=_e(oe(o))}else if(t===q.WORLD_DIRECTION){const o=Se.transformDirection(is);s=_e(oe(o))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}q.GEOMETRY="geometry";q.LOCAL="local";q.WORLD="world";q.WORLD_DIRECTION="worldDirection";q.VIEW="view";q.VIEW_DIRECTION="viewDirection";const Ae=S(q,q.GEOMETRY),Se=S(q,q.LOCAL).temp("Position"),On=S(q,q.WORLD),fd=S(q,q.WORLD_DIRECTION),Oe=S(q,q.VIEW),se=S(q,q.VIEW_DIRECTION);T("PositionNode",q);class ia extends j{constructor(e=null){super("vec4"),this.positionNode=e}setup(e){if(e.shaderStage==="fragment")return oe(e.context.mvp);const t=this.positionNode||Se;return Ke.mul(_t).mul(t)}}const Co=y(ia);T("ModelViewProjectionNode",ia);class aa extends Bs{constructor(e,t=null,s=0,o=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferStride=s,this.bufferOffset=o,this.usage=lc,this.instanced=!1,this.attribute=null,e&&e.isBufferAttribute===!0&&(this.attribute=e,this.usage=e.usage,this.instanced=e.isInstancedBufferAttribute)}getNodeType(e){return this.bufferType===null&&(this.bufferType=e.getTypeFromAttribute(this.attribute)),this.bufferType}setup(e){if(this.attribute!==null)return;const t=this.getNodeType(e),s=this.value,o=e.getTypeLength(t),i=this.bufferStride||o,a=this.bufferOffset,r=s.isInterleavedBuffer===!0?s:new dc(s,i),c=new hc(r,o,a);r.setUsage(this.usage),this.attribute=c,this.attribute.isInstancedBufferAttribute=this.instanced}generate(e){const t=this.getNodeType(e),s=e.getBufferAttributeFromNode(this,t),o=e.getPropertyName(s);let i=null;return e.shaderStage==="vertex"||e.shaderStage==="compute"?(this.name=o,i=o):i=oe(this).build(e,t),i}getInputType(){return"bufferAttribute"}setUsage(e){return this.usage=e,this}setInstanced(e){return this.instanced=e,this}}const Ys=(n,e,t,s)=>A(new aa(n,e,t,s)),Nd=(n,e,t,s)=>Ys(n,e,t,s).setUsage(Tn),Eo=(n,e,t,s)=>Ys(n,e,t,s).setInstanced(!0),Lo=(n,e,t,s)=>Nd(n,e,t,s).setInstanced(!0);N("toAttribute",n=>Ys(n.value));T("BufferAttributeNode",aa);class ra extends L{constructor(e){super("void"),this.instanceMesh=e,this.instanceMatrixNode=null,this.instanceColorNode=null}setup(){let e=this.instanceMatrixNode;const t=this.instanceMesh;if(e===null){const c=t.instanceMatrix,u=new pc(c.array,16,1),l=c.usage===Tn?Lo:Eo,p=[l(u,"vec4",16,0),l(u,"vec4",16,4),l(u,"vec4",16,8),l(u,"vec4",16,12)];e=zt(...p),this.instanceMatrixNode=e}const s=t.instanceColor;if(s&&this.instanceColorNode===null){const c=new mc(s.array,3),u=s.usage===Tn?Lo:Eo;this.instanceColorNode=f(u(c,"vec3",3,0))}const o=e.mul(Se).xyz,i=Xe(e[0].xyz,e[1].xyz,e[2].xyz),a=Ye.div(f(i[0].dot(i[0]),i[1].dot(i[1]),i[2].dot(i[2]))),r=i.mul(a).xyz;Se.assign(o),Ye.assign(r),this.instanceColorNode!==null&&Ze("vec3","vInstanceColor").assign(this.instanceColorNode)}}const yd=y(ra);T("InstanceNode",ra);class le extends L{constructor(e=le.LOCAL){super(),this.scope=e}getHash(){return`tangent-${this.scope}`}getNodeType(){return this.scope===le.GEOMETRY?"vec4":"vec3"}generate(e){const t=this.scope;let s=null;if(t===le.GEOMETRY)s=Te("tangent","vec4"),e.geometry.hasAttribute("tangent")===!1&&e.geometry.computeTangents();else if(t===le.LOCAL)s=oe(Is.xyz);else if(t===le.VIEW){const o=_t.mul(M(Zs,0)).xyz;s=_e(oe(o))}else if(t===le.WORLD){const o=Ks.transformDirection(rt);s=_e(oe(o))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}le.GEOMETRY="geometry";le.LOCAL="local";le.VIEW="view";le.WORLD="world";const Is=S(le,le.GEOMETRY),Zs=S(le,le.LOCAL),Ks=S(le,le.VIEW),xd=S(le,le.WORLD),ca=os(Ks,"TransformedTangentView");_e(ca.transformDirection(rt));T("TangentNode",le);class ua extends L{constructor(e){super("void"),this.batchMesh=e,this.instanceColorNode=null,this.batchingIdNode=null}setup(e){this.batchingIdNode===null&&(this.batchingIdNode=Te("batchId"));const t=this.batchMesh._matricesTexture,s=oo(vt(t),0),o=d(h(this.batchingIdNode)).mul(4).toVar(),i=h(o.mod(s)),a=h(o).div(h(s)),r=zt(vt(t,Tt(i,a)),vt(t,Tt(i.add(1),a)),vt(t,Tt(i.add(2),a)),vt(t,Tt(i.add(3),a))),c=Xe(r[0].xyz,r[1].xyz,r[2].xyz);Se.assign(r.mul(Se));const u=Ye.div(f(c[0].dot(c[0]),c[1].dot(c[1]),c[2].dot(c[2]))),l=c.mul(u).xyz;Ye.assign(l),e.hasGeometryAttribute("tangent")&&Zs.mulAssign(c)}}const vd=y(ua);T("batch",ua);class la extends L{constructor(e,t=!1){super("void"),this.skinnedMesh=e,this.useReference=t,this.updateType=$.OBJECT,this.skinIndexNode=Te("skinIndex","uvec4"),this.skinWeightNode=Te("skinWeight","vec4");let s,o,i;t?(s=je("bindMatrix","mat4"),o=je("bindMatrixInverse","mat4"),i=Gl("skeleton.boneMatrices","mat4",e.skeleton.bones.length)):(s=X(e.bindMatrix,"mat4"),o=X(e.bindMatrixInverse,"mat4"),i=ao(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)),this.bindMatrixNode=s,this.bindMatrixInverseNode=o,this.boneMatricesNode=i}setup(e){const{skinIndexNode:t,skinWeightNode:s,bindMatrixNode:o,bindMatrixInverseNode:i,boneMatricesNode:a}=this,r=a.element(t.x),c=a.element(t.y),u=a.element(t.z),l=a.element(t.w),p=o.mul(Se),g=De(r.mul(s.x).mul(p),c.mul(s.y).mul(p),u.mul(s.z).mul(p),l.mul(s.w).mul(p)),_=i.mul(g).xyz;let V=De(s.x.mul(r),s.y.mul(c),s.z.mul(u),s.w.mul(l));V=i.mul(V).mul(o);const R=V.transformDirection(Ye).xyz;Se.assign(_),Ye.assign(R),e.hasGeometryAttribute("tangent")&&Zs.assign(R)}generate(e,t){if(t!=="void")return Se.build(e,t)}update(e){(this.useReference?e.object:this.skinnedMesh).skeleton.update()}}const Td=n=>A(new la(n,!0));T("SkinningNode",la);class da extends L{constructor(e=[]){super(),this.params=e}getVarName(e){return String.fromCharCode("i".charCodeAt()+e)}getProperties(e){const t=e.getNodeProperties(this);if(t.stackNode!==void 0)return t;const s={};for(let o=0,i=this.params.length-1;o<i;o++){const a=this.params[o],r=a.isNode!==!0&&a.name||this.getVarName(o),c=a.isNode!==!0&&a.type||"int";s[r]=Xs(r,c)}return t.returnsNode=this.params[this.params.length-1](s,e.addStack(),e),t.stackNode=e.removeStack(),t}getNodeType(e){const{returnsNode:t}=this.getProperties(e);return t?t.getNodeType(e):"void"}setup(e){this.getProperties(e)}generate(e){const t=this.getProperties(e),s={tempWrite:!1},o=this.params,i=t.stackNode;for(let c=0,u=o.length-1;c<u;c++){const l=o[c];let p=null,g=null,_=null,V=null,R=null,I=null;l.isNode?(V="int",_=this.getVarName(c),p="0",g=l.build(e,V),R="<"):(V=l.type||"int",_=l.name||this.getVarName(c),p=l.start,g=l.end,R=l.condition,I=l.update,typeof p=="number"?p=p.toString():p&&p.isNode&&(p=p.build(e,V)),typeof g=="number"?g=g.toString():g&&g.isNode&&(g=g.build(e,V)),p!==void 0&&g===void 0?(p=p+" - 1",g="0",R=">="):g!==void 0&&p===void 0&&(p="0",R="<"),R===void 0&&(Number(p)>Number(g)?R=">=":R="<"));const C={start:p,end:g,condition:R},z=C.start,O=C.end;let B="",K="",F="";I||(V==="int"||V==="uint"?R.includes("<")?I="++":I="--":R.includes("<")?I="+= 1.":I="-= 1."),B+=e.getVar(V,_)+" = "+z,K+=_+" "+R+" "+O,F+=_+" "+I;const Y=`for ( ${B}; ${K}; ${F} )`;e.addFlowCode((c===0?`
`:"")+e.tab+Y+` {

`).addFlowTab()}const a=it(i,s).build(e,"void"),r=t.returnsNode?t.returnsNode.build(e):"";e.removeFlowTab().addFlowCode(`
`+e.tab+a);for(let c=0,u=this.params.length-1;c<u;c++)e.addFlowCode((c===0?"":e.tab)+`}

`).removeFlowTab();return e.addFlowTab(),r}}const Z=(...n)=>A(new da(bt(n,"int"))).append(),Sd=()=>Xs("break").append();N("loop",(n,...e)=>Vi(n,Z(...e)));T("LoopNode",da);const an=new WeakMap,Ie=new pt,Io=x(({bufferMap:n,influence:e,stride:t,width:s,depth:o,offset:i})=>{const a=h(bu).mul(t).add(i),r=a.div(s),c=a.sub(r.mul(s));return vt(n,Tt(c,r)).depth(o).mul(e)});function Vd(n){const e=n.morphAttributes.position!==void 0,t=n.morphAttributes.normal!==void 0,s=n.morphAttributes.color!==void 0,o=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,i=o!==void 0?o.length:0;let a=an.get(n);if(a===void 0||a.count!==i){let C=function(){R.dispose(),an.delete(n),n.removeEventListener("dispose",C)};a!==void 0&&a.texture.dispose();const r=n.morphAttributes.position||[],c=n.morphAttributes.normal||[],u=n.morphAttributes.color||[];let l=0;e===!0&&(l=1),t===!0&&(l=2),s===!0&&(l=3);let p=n.attributes.position.count*l,g=1;const _=4096;p>_&&(g=Math.ceil(p/_),p=_);const V=new Float32Array(p*g*4*i),R=new gc(V,p,g,i);R.type=ti,R.needsUpdate=!0;const I=l*4;for(let z=0;z<i;z++){const O=r[z],B=c[z],K=u[z],F=p*g*4*z;for(let Y=0;Y<O.count;Y++){const J=Y*I;e===!0&&(Ie.fromBufferAttribute(O,Y),V[F+J+0]=Ie.x,V[F+J+1]=Ie.y,V[F+J+2]=Ie.z,V[F+J+3]=0),t===!0&&(Ie.fromBufferAttribute(B,Y),V[F+J+4]=Ie.x,V[F+J+5]=Ie.y,V[F+J+6]=Ie.z,V[F+J+7]=0),s===!0&&(Ie.fromBufferAttribute(K,Y),V[F+J+8]=Ie.x,V[F+J+9]=Ie.y,V[F+J+10]=Ie.z,V[F+J+11]=K.itemSize===4?Ie.w:1)}}a={count:i,texture:R,stride:l,size:new ne(p,g)},an.set(n,a),n.addEventListener("dispose",C)}return a}class ha extends L{constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=X(1),this.updateType=$.OBJECT}setup(e){const{geometry:t}=e,s=t.morphAttributes.position!==void 0,o=t.morphAttributes.normal!==void 0,i=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,a=i!==void 0?i.length:0,{texture:r,stride:c,size:u}=Vd(t);s===!0&&Se.mulAssign(this.morphBaseInfluence),o===!0&&Ye.mulAssign(this.morphBaseInfluence);const l=h(u.width);Z(a,({i:p})=>{const g=d(0).toVar();this.mesh.isInstancedMesh===!0&&this.mesh.morphTexture!==null&&this.mesh.morphTexture!==void 0?g.assign(vt(this.mesh.morphTexture,Tt(h(p).add(1),h(Ri))).r):g.assign(je("morphTargetInfluences","float").element(p).toVar()),s===!0&&Se.addAssign(Io({bufferMap:r,influence:g,stride:c,width:l,depth:p,offset:h(0)})),o===!0&&Ye.addAssign(Io({bufferMap:r,influence:g,stride:c,width:l,depth:p,offset:h(1)}))})}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce((t,s)=>t+s,0)}}const _d=y(ha);T("MorphNode",ha);class pa extends L{constructor(){super("vec3")}getHash(){return"reflectVector"}setup(){return se.negate().reflect(ie).transformDirection(rt)}}const Rd=S(pa);T("ReflectVectorNode",pa);class ma extends $t{constructor(e,t=null,s=null){super(e,t,s),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){return Rd}setUpdateMatrix(){}setupUV(e,t){const s=this.value;return e.renderer.coordinateSystem===si||!s.isRenderTargetTexture?f(t.x.negate(),t.yz):t}generateUV(e,t){return t.build(e,"vec3")}}const ga=y(ma);N("cubeTexture",ga);T("CubeTextureNode",ma);class ds extends L{constructor(){super("vec3")}generate(){console.warn("Abstract function.")}}T("LightingNode",ds);let Jt=null;class Mt extends ds{constructor(e=null){super(),this.updateType=$.FRAME,this.light=e,this.rtt=null,this.shadowNode=null,this.shadowMaskNode=null,this.color=new ot,this._defaultColorNode=X(this.color),this.colorNode=this._defaultColorNode,this.isAnalyticLightNode=!0}getCacheKey(){return super.getCacheKey()+"-"+(this.light.id+"-"+(this.light.castShadow?"1":"0"))}getHash(){return this.light.uuid}setupShadow(e){const{object:t}=e;if(t.receiveShadow===!1)return;let s=this.shadowNode;if(s===null){Jt===null&&(Jt=e.createNodeMaterial(),Jt.fragmentNode=M(0,0,0,1),Jt.isShadowNodeMaterial=!0);const o=this.light.shadow,i=e.createRenderTarget(o.mapSize.width,o.mapSize.height),a=new $n;a.minFilter=po,a.magFilter=po,a.image.width=o.mapSize.width,a.image.height=o.mapSize.height,a.compareFunction=fc,i.depthTexture=a,o.camera.updateProjectionMatrix();const r=je("bias","float",o),c=je("normalBias","float",o),u=t.material.shadowPositionNode||On;let l=X(o.matrix).mul(u.add(ea.mul(c)));l=l.xyz.div(l.w);const p=l.x.greaterThanEqual(0).and(l.x.lessThanEqual(1)).and(l.y.greaterThanEqual(0)).and(l.y.lessThanEqual(1)).and(l.z.lessThanEqual(1));let g=l.z.add(r);e.renderer.coordinateSystem===si&&(g=g.mul(2).sub(1)),l=f(l.x,l.y.oneMinus(),g),s=((I,C,z)=>ze(I,C).compare(z))(a,l.xy,l.z);const V=ze(i.texture,l),R=p.mix(1,s.mix(V.a.mix(1,V),1));this.rtt=i,this.colorNode=this.colorNode.mul(R),this.shadowNode=s,this.shadowMaskNode=R,this.updateBeforeType=$.RENDER}}setup(e){this.light.castShadow?this.setupShadow(e):this.shadowNode!==null&&this.disposeShadow()}updateShadow(e){const{rtt:t,light:s}=this,{renderer:o,scene:i}=e,a=i.overrideMaterial;i.overrideMaterial=Jt,t.setSize(s.shadow.mapSize.width,s.shadow.mapSize.height),s.shadow.updateMatrices(s);const r=o.toneMapping,c=o.getRenderTarget(),u=o.getRenderObjectFunction();o.setRenderObjectFunction((l,...p)=>{l.castShadow===!0&&o.renderObject(l,...p)}),o.setRenderTarget(t),o.toneMapping=Vs,o.render(i,s.shadow.camera),o.setRenderTarget(c),o.setRenderObjectFunction(u),o.toneMapping=r,i.overrideMaterial=a}disposeShadow(){this.rtt.dispose(),this.shadowNode=null,this.shadowMaskNode=null,this.rtt=null,this.colorNode=this._defaultColorNode}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(){const{light:e}=this;this.color.copy(e.color).multiplyScalar(e.intensity)}}T("AnalyticLightNode",Mt);const Os=new WeakMap,Ad=n=>n.sort((e,t)=>e.id-t.id);class wd extends L{constructor(e=[]){super("vec3"),this.totalDiffuseNode=f().temp("totalDiffuse"),this.totalSpecularNode=f().temp("totalSpecular"),this.outgoingLightNode=f().temp("outgoingLight"),this.lightNodes=e,this._hash=null}get hasLight(){return this.lightNodes.length>0}getHash(){if(this._hash===null){const e=[];for(const t of this.lightNodes)e.push(t.getHash());this._hash="lights-"+e.join(",")}return this._hash}setup(e){const t=e.context,s=t.lightingModel;let o=this.outgoingLightNode;if(s){const{lightNodes:i,totalDiffuseNode:a,totalSpecularNode:r}=this;t.outgoingLight=o;const c=e.addStack();s.start(t,c,e);for(const I of i)I.build(e);s.indirectDiffuse(t,c,e),s.indirectSpecular(t,c,e),s.ambientOcclusion(t,c,e);const{backdrop:u,backdropAlpha:l}=t,{directDiffuse:p,directSpecular:g,indirectDiffuse:_,indirectSpecular:V}=t.reflectedLight;let R=p.add(_);u!==null&&(l!==null?R=f(l.mix(R,u)):R=f(u),t.material.transparent=!0),a.assign(R),r.assign(g.add(V)),o.assign(a.add(r)),s.finish(t,c,e),o=o.bypass(e.removeStack())}return o}_getLightNodeById(e){for(const t of this.lightNodes)if(t.isAnalyticLightNode&&t.light.id===e)return t;return null}fromLights(e=[]){const t=[];e=Ad(e);for(const s of e){let o=this._getLightNodeById(s.id);if(o===null){const i=s.constructor,a=Os.has(i)?Os.get(i):Mt;o=A(new a(s))}t.push(o)}return this.lightNodes=t,this._hash=null,this}}const Md=y(wd);function jt(n,e){if(Os.has(n)){console.warn(`Redefinition of light node ${e.type}`);return}if(typeof n!="function")throw new Error(`Light ${n.name} is not a class`);if(typeof e!="function"||!e.type)throw new Error(`Light node ${e.type} is not a class`);Os.set(n,e)}class fa extends ds{constructor(e=null){super(),this.aoNode=e}setup(e){const s=this.aoNode.x.sub(1).mul(1).add(1);e.context.ambientOcclusion.mulAssign(s)}}T("AONode",fa);class Na extends Jn{constructor(e,t=null,s=null,o=null){super(e),this.lightingModel=t,this.backdropNode=s,this.backdropAlphaNode=o,this._context=null}getContext(){const{backdropNode:e,backdropAlphaNode:t}=this,s=f().temp("directDiffuse"),o=f().temp("directSpecular"),i=f().temp("indirectDiffuse"),a=f().temp("indirectSpecular"),r={directDiffuse:s,directSpecular:o,indirectDiffuse:i,indirectSpecular:a};return{radiance:f().temp("radiance"),irradiance:f().temp("irradiance"),iblIrradiance:f().temp("iblIrradiance"),ambientOcclusion:d(1).temp("ambientOcclusion"),reflectedLight:r,backdrop:e,backdropAlpha:t}}setup(e){return this.context=this._context||(this._context=this.getContext()),this.context.lightingModel=this.lightingModel||e.context.lightingModel,super.setup(e)}}const ya=y(Na);N("lightingContext",ya);T("LightingContextNode",Na);class he extends L{constructor(e=he.LOCAL){super("vec3"),this.scope=e}getHash(){return`bitangent-${this.scope}`}generate(e){const t=this.scope;let s;t===he.GEOMETRY?s=Ls.cross(Is):t===he.LOCAL?s=Ye.cross(Zs):t===he.VIEW?s=gt.cross(Ks):t===he.WORLD&&(s=ea.cross(xd));const o=s.mul(Is.w).xyz;return _e(oe(o)).build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}he.GEOMETRY="geometry";he.LOCAL="local";he.VIEW="view";he.WORLD="world";S(he,he.GEOMETRY);S(he,he.LOCAL);const Cd=S(he,he.VIEW);S(he,he.WORLD);const Ed=_e(ie.cross(ca).mul(Is.w));_e(Ed.transformDirection(rt));T("BitangentNode",he);const Ot=Xe(Ks,Cd,gt);se.mul(Ot);const Ld=(()=>{let n=Dt.cross(se);return n=n.cross(Dt).normalize(),n=xe(n,ie,xt.mul(ht.oneMinus()).oneMinus().pow2().pow2()).normalize(),n})();class ro extends L{constructor(e,t,s=null){super(),this.condNode=e,this.ifNode=t,this.elseNode=s}getNodeType(e){const t=this.ifNode.getNodeType(e);if(this.elseNode!==null){const s=this.elseNode.getNodeType(e);if(e.getTypeLength(s)>e.getTypeLength(t))return s}return t}generate(e,t){const s=this.getNodeType(e),o={tempWrite:!1},i=e.getDataFromNode(this);if(i.nodeProperty!==void 0)return i.nodeProperty;const{ifNode:a,elseNode:r}=this,c=t!=="void",u=c?fe(s).build(e):"";i.nodeProperty=u;const l=it(this.condNode).build(e,"bool");e.addFlowCode(`
${e.tab}if ( ${l} ) {

`).addFlowTab();let p=it(a,o).build(e,s);if(p&&(c?p=u+" = "+p+";":p="return "+p+";"),e.removeFlowTab().addFlowCode(e.tab+"	"+p+`

`+e.tab+"}"),r!==null){e.addFlowCode(` else {

`).addFlowTab();let g=it(r,o).build(e,s);g&&(c?g=u+" = "+g+";":g="return "+g+";"),e.removeFlowTab().addFlowCode(e.tab+"	"+g+`

`+e.tab+`}

`)}else e.addFlowCode(`

`);return e.format(u,s,t)}}const be=y(ro);N("cond",be);T("CondNode",ro);const Oo=d(1),bn=d(-2),gs=d(.8),rn=d(-1),fs=d(.4),cn=d(2),Ns=d(.305),un=d(3),bo=d(.21),Id=d(4),zo=d(4),Od=d(16),bd=x(([n])=>{const e=f(ue(n)).toVar(),t=d(-1).toVar();return P(e.x.greaterThan(e.z),()=>{P(e.x.greaterThan(e.y),()=>{t.assign(be(n.x.greaterThan(0),0,3))}).else(()=>{t.assign(be(n.y.greaterThan(0),1,4))})}).else(()=>{P(e.z.greaterThan(e.y),()=>{t.assign(be(n.z.greaterThan(0),2,5))}).else(()=>{t.assign(be(n.y.greaterThan(0),1,4))})}),t}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),zd=x(([n,e])=>{const t=E().toVar();return P(e.equal(0),()=>{t.assign(E(n.z,n.y).div(ue(n.x)))}).elseif(e.equal(1),()=>{t.assign(E(n.x.negate(),n.z.negate()).div(ue(n.y)))}).elseif(e.equal(2),()=>{t.assign(E(n.x.negate(),n.y).div(ue(n.z)))}).elseif(e.equal(3),()=>{t.assign(E(n.z.negate(),n.y).div(ue(n.x)))}).elseif(e.equal(4),()=>{t.assign(E(n.x.negate(),n.z).div(ue(n.y)))}).else(()=>{t.assign(E(n.x,n.y).div(ue(n.z)))}),U(.5,t.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),Dd=x(([n])=>{const e=d(0).toVar();return P(n.greaterThanEqual(gs),()=>{e.assign(Oo.sub(n).mul(rn.sub(bn)).div(Oo.sub(gs)).add(bn))}).elseif(n.greaterThanEqual(fs),()=>{e.assign(gs.sub(n).mul(cn.sub(rn)).div(gs.sub(fs)).add(rn))}).elseif(n.greaterThanEqual(Ns),()=>{e.assign(fs.sub(n).mul(un.sub(cn)).div(fs.sub(Ns)).add(cn))}).elseif(n.greaterThanEqual(bo),()=>{e.assign(Ns.sub(n).mul(Id.sub(un)).div(Ns.sub(bo)).add(un))}).else(()=>{e.assign(d(-2).mul(qs(U(1.16,n))))}),e}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]});x(([n,e])=>{const t=n.toVar();t.assign(U(2,t).sub(1));const s=f(t,1).toVar();return P(e.equal(0),()=>{s.assign(s.zyx)}).elseif(e.equal(1),()=>{s.assign(s.xzy),s.xz.mulAssign(-1)}).elseif(e.equal(2),()=>{s.x.mulAssign(-1)}).elseif(e.equal(3),()=>{s.assign(s.zyx),s.xz.mulAssign(-1)}).elseif(e.equal(4),()=>{s.assign(s.xzy),s.xy.mulAssign(-1)}).elseif(e.equal(5),()=>{s.z.mulAssign(-1)}),s}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]});const Pd=x(([n,e,t,s,o,i])=>{const a=d(t),r=f(e),c=Gt(Dd(a),bn,i),u=$s(c),l=Ht(c),p=f(zn(n,r,l,s,o,i)).toVar();return P(u.notEqual(0),()=>{const g=f(zn(n,r,l.add(1),s,o,i)).toVar();p.assign(xe(p,g,u))}),p}),zn=x(([n,e,t,s,o,i])=>{const a=d(t).toVar(),r=f(e),c=d(bd(r)).toVar(),u=d(Pe(zo.sub(a),0)).toVar();a.assign(Pe(a,zo));const l=d(Cn(a)).toVar(),p=E(zd(r,c).mul(l.sub(2)).add(1)).toVar();return P(c.greaterThan(2),()=>{p.y.addAssign(l),c.subAssign(3)}),p.x.addAssign(c.mul(l)),p.x.addAssign(u.mul(U(3,Od))),p.y.addAssign(U(4,Cn(i).sub(l))),p.x.mulAssign(s),p.y.mulAssign(o),n.uv(p).grad(E(),E())}),ln=x(({envMap:n,mipInt:e,outputDirection:t,theta:s,axis:o,CUBEUV_TEXEL_WIDTH:i,CUBEUV_TEXEL_HEIGHT:a,CUBEUV_MAX_MIP:r})=>{const c=ct(s),u=t.mul(c).add(o.cross(t).mul(nt(s))).add(o.mul(o.dot(t).mul(c.oneMinus())));return zn(n,u,e,i,a,r)});x(({n,latitudinal:e,poleAxis:t,outputDirection:s,weights:o,samples:i,dTheta:a,mipInt:r,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p})=>{const g=f(be(e,t,Gi(t,s))).toVar();P(Pi(g.equals(f(0))),()=>{g.assign(f(s.z,0,s.x.negate()))}),g.assign(_e(g));const _=f().toVar();return _.addAssign(o.element(h(0)).mul(ln({theta:0,axis:g,outputDirection:s,mipInt:r,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p}))),Z({start:h(1),end:n},({i:V})=>{P(V.greaterThanEqual(i),()=>{Sd()});const R=d(a.mul(d(V))).toVar();_.addAssign(o.element(V).mul(ln({theta:R.mul(-1),axis:g,outputDirection:s,mipInt:r,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p}))),_.addAssign(o.element(V).mul(ln({theta:R,axis:g,outputDirection:s,mipInt:r,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p})))}),M(_,1)});let bs=null;const Do=new WeakMap;function Fd(n){const e=Math.log2(n)-2,t=1/n;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:t,maxMip:e}}function Ud(n){let e=Do.get(n);if((e!==void 0?e.pmremVersion:-1)!==n.pmremVersion){if(n.isCubeTexture){if(n.source.data.some(s=>s===void 0))throw new Error("PMREMNode: Undefined texture in CubeTexture. Use onLoad callback or async loader");e=bs.fromCubemap(n,e)}else{if(n.image===void 0)throw new Error("PMREMNode: Undefined image in Texture. Use onLoad callback or async loader");e=bs.fromEquirectangular(n,e)}e.pmremVersion=n.pmremVersion,Do.set(n,e)}return e.texture}class xa extends j{constructor(e,t=null,s=null){super("vec3"),this._value=e,this._pmrem=null,this.uvNode=t,this.levelNode=s,this._generator=null,this._texture=ze(null),this._width=X(0),this._height=X(0),this._maxMip=X(0),this.updateBeforeType=$.RENDER}set value(e){this._value=e,this._pmrem=null}get value(){return this._value}updateFromTexture(e){const t=Fd(e.image.height);this._texture.value=e,this._width.value=t.texelWidth,this._height.value=t.texelHeight,this._maxMip.value=t.maxMip}updateBefore(){let e=this._pmrem;const t=e?e.pmremVersion:-1,s=this._value;t!==s.pmremVersion&&(s.isPMREMTexture===!0?e=s:e=Ud(s),this._pmrem=e,this.updateFromTexture(e))}setup(e){bs===null&&(bs=e.createPMREMGenerator()),this.updateBefore(e);let t=this.uvNode;t===null&&e.context.getUV&&(t=e.context.getUV(this));const s=this.value;e.renderer.coordinateSystem===ni&&s.isPMREMTexture!==!0&&s.isRenderTargetTexture===!0&&(t=f(t.x.negate(),t.yz));let o=this.levelNode;return o===null&&e.context.getTextureLevel&&(o=e.context.getTextureLevel(this)),Pd(this._texture,t,o,this._width,this._height,this._maxMip)}}const Bd=y(xa);T("PMREMNode",xa);const Po=new WeakMap;class va extends ds{constructor(e=null){super(),this.envNode=e}setup(e){let t=this.envNode;if(t.isTextureNode){let g=Po.get(t.value);g===void 0&&(g=Bd(t.value),Po.set(t.value,g)),t=g}const{material:s}=e,i=s.envMap?je("envMapIntensity","float",e.material):je("environmentIntensity","float",e.scene),r=s.useAnisotropy===!0||s.anisotropy>0?Ld:ie,c=it(t,Fo(ht,r)).mul(i),u=it(t,kd(ta)).mul(Math.PI).mul(i),l=As(c);e.context.radiance.addAssign(l),e.context.iblIrradiance.addAssign(u);const p=e.context.lightingModel.clearcoatRadiance;if(p){const g=it(t,Fo(Ms,It)).mul(i),_=As(g);p.addAssign(_)}}}const Fo=(n,e)=>{let t=null;return{getUV:()=>(t===null&&(t=se.negate().reflect(e),t=n.mul(n).mix(t,e).normalize(),t=t.transformDirection(rt)),t),getTextureLevel:()=>n}},kd=n=>({getUV:()=>n,getTextureLevel:()=>d(1)});T("EnvironmentNode",va);class Ta extends ds{constructor(e){super(),this.node=e}setup(e){e.context.irradiance.addAssign(this.node)}}T("IrradianceNode",Ta);let dn,hn;class k extends L{constructor(e){super(),this.scope=e,this.isViewportNode=!0}getNodeType(){return this.scope===k.VIEWPORT?"vec4":this.scope===k.COORDINATE?"vec3":"vec2"}getUpdateType(){let e=$.NONE;return(this.scope===k.RESOLUTION||this.scope===k.VIEWPORT)&&(e=$.FRAME),this.updateType=e,e}update({renderer:e}){this.scope===k.VIEWPORT?e.getViewport(hn):e.getDrawingBufferSize(dn)}setup(){const e=this.scope;let t=null;if(e===k.RESOLUTION)t=X(dn||(dn=new ne));else if(e===k.VIEWPORT)t=X(hn||(hn=new pt));else{t=Gd.div(Dn);let s=t.x,o=t.y;/bottom/i.test(e)&&(o=o.oneMinus()),/right/i.test(e)&&(s=s.oneMinus()),t=E(s,o)}return t}generate(e){if(this.scope===k.COORDINATE){let t=e.getFragCoord();if(e.isFlipY()){const s=e.getNodeProperties(Dn).outputNode.build(e);t=`${e.getType("vec3")}( ${t}.x, ${s}.y - ${t}.y, ${t}.z )`}return t}return super.generate(e)}}k.COORDINATE="coordinate";k.RESOLUTION="resolution";k.VIEWPORT="viewport";k.TOP_LEFT="topLeft";k.BOTTOM_LEFT="bottomLeft";k.TOP_RIGHT="topRight";k.BOTTOM_RIGHT="bottomRight";const Gd=S(k,k.COORDINATE),Dn=S(k,k.RESOLUTION),Ft=S(k,k.VIEWPORT),rs=S(k,k.TOP_LEFT);S(k,k.BOTTOM_LEFT);S(k,k.TOP_RIGHT);S(k,k.BOTTOM_RIGHT);T("ViewportNode",k);const Qt=new ne;class hs extends $t{constructor(e=rs,t=null,s=null){s===null&&(s=new oi,s.minFilter=Nc),super(s,e,t),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=$.FRAME}updateBefore(e){const t=e.renderer;t.getDrawingBufferSize(Qt);const s=this.value;(s.image.width!==Qt.width||s.image.height!==Qt.height)&&(s.image.width=Qt.width,s.image.height=Qt.height,s.needsUpdate=!0);const o=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,t.copyFramebufferToTexture(s),s.generateMipmaps=o}clone(){const e=new this.constructor(this.uvNode,this.levelNode,this.value);return e.generateMipmaps=this.generateMipmaps,e}}const Wd=y(hs),Sa=y(hs,null,null,{generateMipmaps:!0});N("viewportTexture",Wd);N("viewportMipTexture",Sa);T("ViewportTextureNode",hs);let pn=null;class Va extends hs{constructor(e=rs,t=null){pn===null&&(pn=new $n),super(e,t,pn)}}const _a=y(Va);N("viewportDepthTexture",_a);T("ViewportDepthTextureNode",Va);class Ne extends L{constructor(e,t=null){super("float"),this.scope=e,this.valueNode=t,this.isViewportDepthNode=!0}generate(e){const{scope:t}=this;return t===Ne.DEPTH_PIXEL?e.getFragDepth():super.generate(e)}setup(){const{scope:e}=this;let t=null;if(e===Ne.DEPTH)t=Pn(Oe.z,sn,nn);else if(e===Ne.DEPTH_TEXTURE){const s=this.valueNode||_a(),o=Ra(s,sn,nn);t=Pn(o,sn,nn)}else e===Ne.DEPTH_PIXEL&&this.valueNode!==null&&(t=Aa().assign(this.valueNode));return t}}const Pn=(n,e,t)=>n.add(e).div(e.sub(t)),Ra=(n,e,t)=>e.mul(t).div(t.sub(e).mul(n).sub(t));Ne.DEPTH="depth";Ne.DEPTH_TEXTURE="depthTexture";Ne.DEPTH_PIXEL="depthPixel";const Aa=y(Ne,Ne.DEPTH_PIXEL);S(Ne,Ne.DEPTH);y(Ne,Ne.DEPTH_TEXTURE);const wa=S(Ne,Ne.DEPTH_PIXEL);wa.assign=n=>Aa(n);T("ViewportDepthNode",Ne);class ft extends L{constructor(e=ft.DEFAULT){super(),this.scope=e}setup(e){super.setup(e);const t=e.clippingContext,{localClipIntersection:s,localClippingCount:o,globalClippingCount:i}=t,a=i+o,r=s?a-o:a;return this.scope===ft.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(t.planes,a,r):this.setupDefault(t.planes,a,r)}setupAlphaToCoverage(e,t,s){return x(()=>{const o=En(e),i=fe("float","distanceToPlane"),a=fe("float","distanceToGradient"),r=fe("float","clipOpacity");r.assign(1);let c;if(Z(s,({i:u})=>{c=o.element(u),i.assign(Oe.dot(c.xyz).negate().add(c.w)),a.assign(i.fwidth().div(2)),r.mulAssign(at(a.negate(),a,i)),r.equal(0).discard()}),s<t){const u=fe("float","unionclipOpacity");u.assign(1),Z({start:s,end:t},({i:l})=>{c=o.element(l),i.assign(Oe.dot(c.xyz).negate().add(c.w)),a.assign(i.fwidth().div(2)),u.mulAssign(at(a.negate(),a,i).oneMinus())}),r.mulAssign(u.oneMinus())}te.a.mulAssign(r),te.a.equal(0).discard()})()}setupDefault(e,t,s){return x(()=>{const o=En(e);let i;if(Z(s,({i:a})=>{i=o.element(a),Oe.dot(i.xyz).greaterThan(i.w).discard()}),s<t){const a=fe("bool","clipped");a.assign(!0),Z({start:s,end:t},({i:r})=>{i=o.element(r),a.assign(Oe.dot(i.xyz).greaterThan(i.w).and(a))}),a.discard()}})()}}ft.ALPHA_TO_COVERAGE="alphaToCoverage";ft.DEFAULT="default";const Hd=()=>A(new ft),qd=()=>A(new ft(ft.ALPHA_TO_COVERAGE));class Ma extends L{constructor(){super("bool"),this.isFrontFacingNode=!0}generate(e){const{renderer:t,material:s}=e;return t.coordinateSystem===ni&&s.side===yc?"false":e.getFrontFacing()}}const $d=S(Ma),zs=d($d).mul(2).sub(1);T("FrontFacingNode",Ma);const Fn=new Map;class Fe extends Sn{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!0,this.normals=!0,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.depthNode=null,this.shadowNode=null,this.shadowPositionNode=null,this.outputNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+di(this)}build(e){this.setup(e)}setup(e){e.addStack(),e.stack.outputNode=this.vertexNode||this.setupPosition(e),e.addFlow("vertex",e.removeStack()),e.addStack();let t;const s=this.setupClipping(e);if(this.depthWrite===!0&&this.setupDepth(e),this.fragmentNode===null){this.normals===!0&&this.setupNormal(e),this.setupDiffuseColor(e),this.setupVariants(e);const o=this.setupLighting(e);s!==null&&e.stack.add(s);const i=M(o,te.a).max(0);t=this.setupOutput(e,i),zu.assign(t),this.outputNode!==null&&(t=this.outputNode)}else{let o=this.fragmentNode;o.isOutputStructNode!==!0&&(o=M(o)),t=this.setupOutput(e,o)}e.stack.outputNode=t,e.addFlow("fragment",e.removeStack())}setupClipping(e){if(e.clippingContext===null)return null;const{globalClippingCount:t,localClippingCount:s}=e.clippingContext;let o=null;return(t||s)&&(this.alphaToCoverage?o=qd():e.stack.add(Hd())),o}setupDepth(e){const{renderer:t}=e;let s=this.depthNode;s===null&&t.logarithmicDepthBuffer===!0&&(s=Co().w.add(1).log2().mul(Wl).mul(.5)),s!==null&&wa.assign(s).append()}setupPosition(e){const{object:t}=e,s=t.geometry;e.addStack(),(s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&_d(t).append(),t.isSkinnedMesh===!0&&Td(t).append(),t.isBatchedMesh&&vd(t).append(),t.instanceMatrix&&t.instanceMatrix.isInstancedBufferAttribute===!0&&e.isAvailable("instance")===!0&&yd(t).append(),this.positionNode!==null&&Se.assign(this.positionNode);const o=Co();return e.context.vertex=e.removeStack(),e.context.mvp=o,o}setupDiffuseColor({object:e,geometry:t}){let s=this.colorNode?M(this.colorNode):as;this.vertexColors===!0&&t.hasAttribute("color")&&(s=M(s.xyz.mul(Te("color","vec3")),s.a)),e.instanceColor&&(s=Ze("vec3","vInstanceColor").mul(s)),te.assign(s);const o=this.opacityNode?d(this.opacityNode):sa;if(te.a.assign(te.a.mul(o)),this.alphaTestNode!==null||this.alphaTest>0){const i=this.alphaTestNode!==null?d(this.alphaTestNode):ql;te.a.lessThanEqual(i).discard()}}setupVariants(){}setupNormal(){if(this.flatShading===!0){const e=Oe.dFdx().cross(Oe.dFdy()).normalize();ie.assign(e.mul(zs))}else{const e=this.normalNode?f(this.normalNode):Ql;ie.assign(e.mul(zs))}}getEnvNode(e){let t=null;return this.envNode?t=this.envNode:this.envMap?t=this.envMap.isCubeTexture?ga(this.envMap):ze(this.envMap):e.environmentNode&&(t=e.environmentNode),t}setupLights(e){const t=this.getEnvNode(e),s=[];if(t&&s.push(new va(t)),e.material.lightMap&&s.push(new Ta(Ki("lightMap","texture"))),this.aoNode!==null||e.material.aoMap){const i=this.aoNode!==null?this.aoNode:ze(e.material.aoMap);s.push(new fa(i))}let o=this.lightsNode||e.lightsNode;return s.length>0&&(o=Md([...o.lightNodes,...s])),o}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:s,backdropAlphaNode:o,emissiveNode:i}=this,r=this.lights===!0||this.lightsNode!==null?this.setupLights(e):null;let c=te.rgb;if(r&&r.hasLight!==!1){const u=this.setupLightingModel(e);c=ya(r,u,s,o)}else s!==null&&(c=f(o!==null?xe(c,s,o):s));return(i&&i.isNode===!0||t.emissive&&t.emissive.isColor===!0)&&(c=c.add(f(i||Xl))),c}setupOutput(e,t){const s=e.fogNode;return s&&(t=M(s.mix(t.rgb,s.colorNode),t.a)),t}setDefaultValues(e){for(const s in e){const o=e[s];this[s]===void 0&&(this[s]=o,o&&o.clone&&(this[s]=o.clone()))}Object.assign(this.defines,e.defines);const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const s in t)Object.getOwnPropertyDescriptor(this.constructor.prototype,s)===void 0&&t[s].get!==void 0&&Object.defineProperty(this.constructor.prototype,s,t[s])}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{},nodes:{}});const s=xc.prototype.toJSON.call(this,e),o=Rs(this);s.inputNodes={};for(const{property:a,childNode:r}of o)s.inputNodes[a]=r.toJSON(e).uuid;function i(a){const r=[];for(const c in a){const u=a[c];delete u.metadata,r.push(u)}return r}if(t){const a=i(e.textures),r=i(e.images),c=i(e.nodes);a.length>0&&(s.textures=a),r.length>0&&(s.images=r),c.length>0&&(s.nodes=c)}return s}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.positionNode=e.positionNode,this.depthNode=e.depthNode,this.shadowNode=e.shadowNode,this.shadowPositionNode=e.shadowPositionNode,this.outputNode=e.outputNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}static fromMaterial(e){if(e.isNodeMaterial===!0)return e;const t=e.type.replace("Material","NodeMaterial"),s=Xd(t);if(s===void 0)throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);for(const o in e)s[o]=e[o];return s}}function Re(n,e){if(typeof e!="function"||!n)throw new Error(`Node material ${n} is not a class`);if(Fn.has(n)){console.warn(`Redefinition of node material ${n}`);return}Fn.set(n,e),e.type=n}function Xd(n){const e=Fn.get(n);if(e!==void 0)return new e}Re("NodeMaterial",Fe);class Ca extends L{constructor(e=null){super(),this.nodes=[],this.outputNode=null,this.parent=e,this._currentCond=null,this.isStackNode=!0}getNodeType(e){return this.outputNode?this.outputNode.getNodeType(e):"void"}add(e){return this.nodes.push(e),this}if(e,t){const s=new es(t);return this._currentCond=be(e,s),this.add(this._currentCond)}elseif(e,t){const s=new es(t),o=be(e,s);return this._currentCond.elseNode=o,this._currentCond=o,this}else(e){return this._currentCond.elseNode=new es(e),this}build(e,...t){const s=ru();Vo(this);for(const o of this.nodes)o.build(e,"void");return Vo(s),this.outputNode?this.outputNode.build(e,...t):super.build(e,...t)}}y(Ca);T("StackNode",Ca);class Ea extends j{constructor(e=fd){super("vec2"),this.dirNode=e}setup(){const e=this.dirNode,t=e.z.atan2(e.x).mul(1/(Math.PI*2)).add(.5),s=e.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return E(t,s)}}y(Ea);T("EquirectUVNode",Ea);class La extends L{constructor(e){super(),this.types=e,this.isStructTypeNode=!0}getMemberTypes(){return this.types}}T("StructTypeNode",La);class Ia extends L{constructor(...e){super(),this.members=e,this.isOutputStructNode=!0}setup(e){super.setup(e);const t=this.members,s=[];for(let o=0;o<t.length;o++)s.push(t[o].getNodeType(e));this.nodeType=e.getStructTypeFromNode(new La(s)).name}generate(e,t){const s=e.getVarFromNode(this);s.isOutputStructVar=!0;const o=e.getPropertyName(s),i=this.members,a=o!==""?o+".":"";for(let r=0;r<i.length;r++){const c=i[r].build(e,t);e.addLineFlowCode(`${a}m${r} = ${c}`)}return o}}y(Ia);T("OutputStructNode",Ia);class Oa extends L{constructor(e){super(),this.seedNode=e}setup(){const e=this.seedNode.uint().mul(747796405).add(2891336453),t=e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);return t.shiftRight(22).bitXor(t).float().mul(1/2**32)}}const jd=y(Oa);N("hash",jd);T("HashNode",Oa);const Un=(n,e)=>Qe(U(4,n.mul(re(1,n))),e),Yd=(n,e)=>n.lessThan(.5)?Un(n.mul(2),e).div(2):re(1,Un(U(re(1,n),2),e).div(2)),Zd=(n,e,t)=>Qe(mt(Qe(n,e),De(Qe(n,e),Qe(re(1,n),t))),1/e),Kd=(n,e)=>nt(_o.mul(e.mul(n).sub(1))).div(_o.mul(e.mul(n).sub(1)));N("parabola",Un);N("gain",Yd);N("pcurve",Zd);N("sinc",Kd);const Je=x(([n])=>n.fract().sub(.5).abs()),ba=x(([n])=>f(Je(n.z.add(Je(n.y.mul(1)))),Je(n.z.add(Je(n.x.mul(1)))),Je(n.y.add(Je(n.x.mul(1)))))),Jd=x(([n,e,t])=>{const s=f(n).toVar(),o=d(1.4).toVar(),i=d(0).toVar(),a=f(s).toVar();return Z({start:d(0),end:d(3),type:"float",condition:"<="},()=>{const r=f(ba(a.mul(2))).toVar();s.addAssign(r.add(t.mul(d(.1).mul(e)))),a.mulAssign(1.8),o.mulAssign(1.5),s.mulAssign(1.2);const c=d(Je(s.z.add(Je(s.x.add(Je(s.y)))))).toVar();i.addAssign(c.div(o)),a.addAssign(.14)}),i});Je.setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]});ba.setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]});Jd.setLayout({name:"triNoise3D",type:"float",inputs:[{name:"p",type:"vec3"},{name:"spd",type:"float"},{name:"time",type:"float"}]});let mn;class za extends ro{constructor(e){mn=mn||Xs("discard"),super(e,mn)}}const Qd=y(za),eh=n=>Qd(n).append();N("discard",eh);T("DiscardNode",za);class Da extends L{constructor(e=[],...t){super(),this.functionNodes=e,this.parametersNodes=t,this._candidateFnCall=null}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(e){const t=this.parametersNodes;let s=this._candidateFnCall;if(s===null){let o=null,i=-1;for(const a of this.functionNodes){const c=a.shaderNode.layout;if(c===null)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const u=c.inputs;if(t.length===u.length){let l=0;for(let p=0;p<t.length;p++){const g=t[p],_=u[p];g.getNodeType(e)===_.type?l++:l=0}l>i&&(o=a,i=l)}}this._candidateFnCall=s=o(...t)}return s}}const th=y(Da),Ge=n=>(...e)=>th(n,...e);T("FunctionOverloadingNode",Da);class Pa extends j{constructor(){super("vec2")}setup(){const e=f(se.z,0,se.x.negate()).normalize(),t=se.cross(e);return E(e.dot(ie),t.dot(ie)).mul(.495).add(.5)}}S(Pa);T("MatcapUVNode",Pa);class Ce extends At{constructor(e=Ce.LOCAL,t=1,s=0){super(s),this.scope=e,this.scale=t,this.updateType=$.FRAME}update(e){const t=this.scope,s=this.scale;t===Ce.LOCAL?this.value+=e.deltaTime*s:t===Ce.DELTA?this.value=e.deltaTime*s:t===Ce.FRAME?this.value=e.frameId:this.value=e.time*s}serialize(e){super.serialize(e),e.scope=this.scope,e.scale=this.scale}deserialize(e){super.deserialize(e),this.scope=e.scope,this.scale=e.scale}}Ce.LOCAL="local";Ce.GLOBAL="global";Ce.DELTA="delta";Ce.FRAME="frame";const sh=(n,e=0)=>A(new Ce(Ce.LOCAL,n,e));S(Ce,Ce.FRAME).uint();T("TimerNode",Ce);class pe extends L{constructor(e=pe.SINE,t=sh()){super(),this.method=e,this.timeNode=t}getNodeType(e){return this.timeNode.getNodeType(e)}setup(){const e=this.method,t=A(this.timeNode);let s=null;return e===pe.SINE?s=t.add(.75).mul(Math.PI*2).sin().mul(.5).add(.5):e===pe.SQUARE?s=t.fract().round():e===pe.TRIANGLE?s=t.add(.5).fract().mul(2).sub(1).abs():e===pe.SAWTOOTH&&(s=t.fract()),s}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}pe.SINE="sine";pe.SQUARE="square";pe.TRIANGLE="triangle";pe.SAWTOOTH="sawtooth";y(pe,pe.SINE);y(pe,pe.SQUARE);y(pe,pe.TRIANGLE);y(pe,pe.SAWTOOTH);T("OscNode",pe);class tt extends j{constructor(e,t){super(),this.scope=e,this.node=t}getNodeType(e){return this.node.getNodeType(e)}setup(){const{scope:e,node:t}=this;let s=null;return e===tt.DIRECTION_TO_COLOR?s=t.mul(.5).add(.5):e===tt.COLOR_TO_DIRECTION&&(s=t.mul(2).sub(1)),s}}tt.DIRECTION_TO_COLOR="directionToColor";tt.COLOR_TO_DIRECTION="colorToDirection";const Fa=y(tt,tt.DIRECTION_TO_COLOR),nh=y(tt,tt.COLOR_TO_DIRECTION);N("directionToColor",Fa);N("colorToDirection",nh);T("PackingNode",tt);class co extends L{constructor(e,t,s,o=d(0),i=d(1)){super(),this.node=e,this.inLowNode=t,this.inHighNode=s,this.outLowNode=o,this.outHighNode=i,this.doClamp=!0}setup(){const{node:e,inLowNode:t,inHighNode:s,outLowNode:o,outHighNode:i,doClamp:a}=this;let r=e.sub(t).div(s.sub(t));return a===!0&&(r=r.clamp()),r.mul(i.sub(o)).add(o)}}const oh=y(co,null,null,{doClamp:!1}),ih=y(co);N("remap",oh);N("remapClamp",ih);T("RemapNode",co);class Ua extends j{constructor(e,t,s=E(.5)){super("vec2"),this.uvNode=e,this.rotationNode=t,this.centerNode=s}setup(){const{uvNode:e,rotationNode:t,centerNode:s}=this;return e.sub(s).rotate(t).add(s)}}const ah=y(Ua);N("rotateUV",ah);T("RotateUVNode",Ua);class Ba extends j{constructor(e,t){super(),this.positionNode=e,this.rotationNode=t}getNodeType(e){return this.positionNode.getNodeType(e)}setup(e){const{rotationNode:t,positionNode:s}=this;if(this.getNodeType(e)==="vec2"){const i=t.cos(),a=t.sin();return Kn(i,a,a.negate(),i).mul(s)}else{const i=t,a=zt(M(1,0,0,0),M(0,ct(i.x),nt(i.x).negate(),0),M(0,nt(i.x),ct(i.x),0),M(0,0,0,1)),r=zt(M(ct(i.y),0,nt(i.y),0),M(0,1,0,0),M(nt(i.y).negate(),0,ct(i.y),0),M(0,0,0,1)),c=zt(M(ct(i.z),nt(i.z).negate(),0,0),M(nt(i.z),ct(i.z),0,0),M(0,0,1,0),M(0,0,0,1));return a.mul(r).mul(c).mul(M(s,1)).xyz}}}const rh=y(Ba);N("rotate",rh);T("RotateNode",Ba);class ka extends L{constructor(e,t=st(),s=d(0)){super("vec2"),this.countNode=e,this.uvNode=t,this.frameNode=s}setup(){const{frameNode:e,uvNode:t,countNode:s}=this,{width:o,height:i}=s,a=e.mod(o.mul(i)).floor(),r=a.mod(o),c=i.sub(a.add(1).div(o).ceil()),u=s.reciprocal(),l=E(r,c);return t.add(l).mul(u)}}y(ka);T("SpriteSheetUVNode",ka);class Ga extends Wt{constructor(e,t){super(e,t),this.isStorageArrayElementNode=!0}set storageBufferNode(e){this.node=e}get storageBufferNode(){return this.node}setup(e){return e.isAvailable("storageBuffer")===!1&&!this.node.instanceIndex&&this.node.bufferObject===!0&&e.setupPBO(this.node),super.setup(e)}generate(e,t){let s;const o=e.context.assign;if(e.isAvailable("storageBuffer")===!1){const{node:i}=this;!i.instanceIndex&&this.node.bufferObject===!0&&o!==!0?s=e.generatePBO(this):s=i.build(e)}else s=super.generate(e);if(o!==!0){const i=this.getNodeType(e);s=e.format(s,i,t)}return s}}const Wa=y(Ga);N("storageElement",Wa);T("StorageArrayElementNode",Ga);class Ha extends L{constructor(e,t=null,s=null,o=d(1),i=Se,a=Ye){super("vec4"),this.textureXNode=e,this.textureYNode=t,this.textureZNode=s,this.scaleNode=o,this.positionNode=i,this.normalNode=a}setup(){const{textureXNode:e,textureYNode:t,textureZNode:s,scaleNode:o,positionNode:i,normalNode:a}=this;let r=a.abs().normalize();r=r.div(r.dot(f(1)));const c=i.yz.mul(o),u=i.zx.mul(o),l=i.xy.mul(o),p=e.value,g=t!==null?t.value:p,_=s!==null?s.value:p,V=ze(p,c).mul(r.x),R=ze(g,u).mul(r.y),I=ze(_,l).mul(r.z);return De(V,R,I)}}const ch=y(Ha),uh=(...n)=>ch(...n);N("triplanarTexture",uh);T("TriplanarTexturesNode",Ha);new vc;new He;new He;new He;new Jo;new He(0,0,-1);new pt;new He;new He;new pt;new ne;new St;E(rs.x.oneMinus(),rs.y);class lh extends Hs{constructor(e=0){super(null,"vec4"),this.isVertexColorNode=!0,this.index=e}getAttributeName(){const e=this.index;return"color"+(e>0?e:"")}generate(e){const t=this.getAttributeName(e),s=e.hasGeometryAttribute(t);let o;return s===!0?o=super.generate(e):o=e.generateConst(this.nodeType,new pt(1,1,1,1)),o}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}T("VertexColorNode",lh);class qa extends Xt{constructor(e,t,s=null){super(e,t,s),this.renderer=s}updateReference(e){return this.reference=this.renderer!==null?this.renderer:e.renderer,this.reference}}const dh=(n,e,t)=>A(new qa(n,e,t));T("RendererReferenceNode",qa);const Js=1/6,$a=n=>U(Js,U(n,U(n,n.negate().add(3)).sub(3)).add(1)),Bn=n=>U(Js,U(n,U(n,U(3,n).sub(6))).add(4)),Xa=n=>U(Js,U(n,U(n,U(-3,n).add(3)).add(3)).add(1)),kn=n=>U(Js,Qe(n,3)),Uo=n=>$a(n).add(Bn(n)),Bo=n=>Xa(n).add(kn(n)),ko=n=>De(-1,Bn(n).div($a(n).add(Bn(n)))),Go=n=>De(1,kn(n).div(Xa(n).add(kn(n)))),Wo=(n,e,t)=>{const s=n.uvNode,o=U(s,e.zw).add(.5),i=Ht(o),a=$s(o),r=Uo(a.x),c=Bo(a.x),u=ko(a.x),l=Go(a.x),p=ko(a.y),g=Go(a.y),_=E(i.x.add(u),i.y.add(p)).sub(.5).mul(e.xy),V=E(i.x.add(l),i.y.add(p)).sub(.5).mul(e.xy),R=E(i.x.add(u),i.y.add(g)).sub(.5).mul(e.xy),I=E(i.x.add(l),i.y.add(g)).sub(.5).mul(e.xy),C=Uo(a.y).mul(De(r.mul(n.uv(_).level(t)),c.mul(n.uv(V).level(t)))),z=Bo(a.y).mul(De(r.mul(n.uv(R).level(t)),c.mul(n.uv(I).level(t))));return C.add(z)},hh=(n,e)=>{const t=E(n.size(h(e))),s=E(n.size(h(e.add(1)))),o=mt(1,t),i=mt(1,s),a=Wo(n,M(o,t),Ht(e)),r=Wo(n,M(i,s),Bi(e));return $s(e).mix(a,r)};class ja extends j{constructor(e,t=d(3)){super("vec4"),this.textureNode=e,this.blurNode=t}setup(){return hh(this.textureNode,this.blurNode)}}const ph=y(ja);N("bicubic",ph);T("TextureBicubicNode",ja);class Ya extends L{constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}S(Ya);T("PointUVNode",Ya);class qe extends L{constructor(e=qe.BACKGROUND_BLURRINESS,t=null){super(),this.scope=e,this.scene=t}setup(e){const t=this.scope,s=this.scene!==null?this.scene:e.scene;let o;return t===qe.BACKGROUND_BLURRINESS?o=je("backgroundBlurriness","float",s):t===qe.BACKGROUND_INTENSITY?o=je("backgroundIntensity","float",s):console.error("THREE.SceneNode: Unknown scope:",t),o}}qe.BACKGROUND_BLURRINESS="backgroundBlurriness";qe.BACKGROUND_INTENSITY="backgroundIntensity";S(qe,qe.BACKGROUND_BLURRINESS);S(qe,qe.BACKGROUND_INTENSITY);T("SceneNode",qe);class mh extends js{constructor(e,t,s=0){super(e,t,s),this.isStorageBufferNode=!0,this.bufferObject=!1,this._attribute=null,this._varying=null,e.isStorageBufferAttribute!==!0&&e.isStorageInstancedBufferAttribute!==!0&&(e.isInstancedBufferAttribute?e.isStorageInstancedBufferAttribute=!0:e.isStorageBufferAttribute=!0)}getInputType(){return"storageBuffer"}element(e){return Wa(this,e)}setBufferObject(e){return this.bufferObject=e,this}generate(e){if(e.isAvailable("storageBuffer"))return super.generate(e);const t=this.getNodeType(e);this._attribute===null&&(this._attribute=Ys(this.value),this._varying=oe(this._attribute));const s=this._varying.build(e,t);return e.registerTransform(s,this._attribute),s}}T("StorageBufferNode",mh);class Za extends $t{constructor(e,t,s=null){super(e,t),this.storeNode=s,this.isStoreTextureNode=!0}getInputType(){return"storageTexture"}setup(e){super.setup(e);const t=e.getNodeProperties(this);t.storeNode=this.storeNode}generate(e,t){let s;return this.storeNode!==null?s=this.generateStore(e):s=super.generate(e,t),s}generateStore(e){const t=e.getNodeProperties(this),{uvNode:s,storeNode:o}=t,i=super.generate(e,"property"),a=s.build(e,"uvec2"),r=o.build(e,"vec4"),c=e.generateTextureStore(e,i,a,r);e.addLineFlowCode(c)}}y(Za);T("TextureStoreNode",Za);class gh extends Xt{constructor(e,t,s=null){super(e,t,s),this.userData=s}update(e){this.reference=this.userData!==null?this.userData:e.object.userData,super.update(e)}}T("UserDataNode",gh);const fh=x(({base:n,blend:e})=>{const t=s=>e[s].lessThan(Di).cond(e[s],n[s].oneMinus().div(e[s]).oneMinus().max(0));return f(t("x"),t("y"),t("z"))}).setLayout({name:"burnColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Nh=x(({base:n,blend:e})=>{const t=s=>e[s].equal(1).cond(e[s],n[s].div(e[s].oneMinus()).max(0));return f(t("x"),t("y"),t("z"))}).setLayout({name:"dodgeColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),yh=x(({base:n,blend:e})=>{const t=s=>n[s].oneMinus().mul(e[s].oneMinus()).oneMinus();return f(t("x"),t("y"),t("z"))}).setLayout({name:"screenColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),xh=x(({base:n,blend:e})=>{const t=s=>n[s].lessThan(.5).cond(n[s].mul(e[s],2),n[s].oneMinus().mul(e[s].oneMinus()).oneMinus());return f(t("x"),t("y"),t("z"))}).setLayout({name:"overlayColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]});class ge extends j{constructor(e,t,s){super(),this.blendMode=e,this.baseNode=t,this.blendNode=s}setup(){const{blendMode:e,baseNode:t,blendNode:s}=this,o={base:t,blend:s};let i=null;return e===ge.BURN?i=fh(o):e===ge.DODGE?i=Nh(o):e===ge.SCREEN?i=yh(o):e===ge.OVERLAY&&(i=xh(o)),i}}ge.BURN="burn";ge.DODGE="dodge";ge.SCREEN="screen";ge.OVERLAY="overlay";const vh=y(ge,ge.BURN),Th=y(ge,ge.DODGE),Sh=y(ge,ge.OVERLAY),Vh=y(ge,ge.SCREEN);N("burn",vh);N("dodge",Th);N("overlay",Sh);N("screen",Vh);T("BlendModeNode",ge);const _h=x(({textureNode:n,bumpScale:e})=>{const t=o=>n.cache().context({getUV:i=>o(i.uvNode||st()),forceUVContext:!0}),s=d(t(o=>o));return E(d(t(o=>o.add(o.dFdx()))).sub(s),d(t(o=>o.add(o.dFdy()))).sub(s)).mul(e)}),Rh=x(n=>{const{surf_pos:e,surf_norm:t,dHdxy:s}=n,o=e.dFdx().normalize(),i=e.dFdy().normalize(),a=t,r=i.cross(a),c=a.cross(o),u=o.dot(r).mul(zs),l=u.sign().mul(s.x.mul(r).add(s.y.mul(c)));return u.abs().mul(t).sub(l).normalize()});class Ka extends j{constructor(e,t=null){super("vec3"),this.textureNode=e,this.scaleNode=t}setup(){const e=this.scaleNode!==null?this.scaleNode:1,t=_h({textureNode:this.textureNode,bumpScale:e});return Rh({surf_pos:Oe,surf_norm:gt,dHdxy:t})}}const Ah=y(Ka);N("bumpMap",Ah);T("BumpMapNode",Ka);const wh=x(({color:n,adjustment:e})=>e.mix(Ja(n.rgb),n.rgb)),Mh=x(({color:n,adjustment:e})=>{const t=De(n.r,n.g,n.b).div(3),s=n.r.max(n.g.max(n.b)),o=s.sub(t).mul(e).mul(-3);return xe(n.rgb,s,o)}),Ch=x(({color:n,adjustment:e})=>{const t=f(.57735,.57735,.57735),s=e.cos();return f(n.rgb.mul(s).add(t.cross(n.rgb).mul(e.sin()).add(t.mul(qt(t,n.rgb).mul(s.oneMinus())))))});class Ee extends j{constructor(e,t,s=d(1)){super("vec3"),this.method=e,this.colorNode=t,this.adjustmentNode=s}setup(){const{method:e,colorNode:t,adjustmentNode:s}=this,o={color:t,adjustment:s};let i=null;return e===Ee.SATURATION?i=wh(o):e===Ee.VIBRANCE?i=Mh(o):e===Ee.HUE?i=Ch(o):console.error(`${this.type}: Method "${this.method}" not supported!`),i}}Ee.SATURATION="saturation";Ee.VIBRANCE="vibrance";Ee.HUE="hue";const Eh=y(Ee,Ee.SATURATION),Lh=y(Ee,Ee.VIBRANCE),Ih=y(Ee,Ee.HUE),Oh=f(.2125,.7154,.0721),Ja=(n,e=Oh)=>qt(n,e),Qa=(n,e)=>xe(f(0),n,Ja(n).sub(e).max(0));N("saturation",Eh);N("vibrance",Lh);N("hue",Ih);N("threshold",Qa);T("ColorAdjustmentNode",Ee);const bh=x(n=>{const{eye_pos:e,surf_norm:t,mapN:s,uv:o}=n,i=e.dFdx(),a=e.dFdy(),r=o.dFdx(),c=o.dFdy(),u=t,l=a.cross(u),p=u.cross(i),g=l.mul(r.x).add(p.mul(c.x)),_=l.mul(r.y).add(p.mul(c.y)),V=g.dot(g).max(_.dot(_)),R=zs.mul(V.inverseSqrt());return De(g.mul(s.x,R),_.mul(s.y,R),u.mul(s.z)).normalize()});class er extends j{constructor(e,t=null){super("vec3"),this.node=e,this.scaleNode=t,this.normalMapType=mo}setup(e){const{normalMapType:t,scaleNode:s}=this;let o=this.node.mul(2).sub(1);s!==null&&(o=f(o.xy.mul(s),o.z));let i=null;return t===Tc?i=Qi.mul(o).normalize():t===mo&&(e.hasGeometryAttribute("tangent")===!0?i=Ot.mul(o).normalize():i=bh({eye_pos:Oe,surf_norm:gt,mapN:o,uv:st()})),i}}const zh=y(er);N("normalMap",zh);T("NormalMapNode",er);class tr extends j{constructor(e,t){super(),this.sourceNode=e,this.stepsNode=t}setup(){const{sourceNode:e,stepsNode:t}=this;return e.mul(t).floor().div(t)}}const Dh=y(tr);N("posterize",Dh);T("PosterizeNode",tr);const Ph=x(({color:n,exposure:e})=>n.mul(e).clamp()),Fh=x(({color:n,exposure:e})=>(n=n.mul(e),n.div(n.add(1)).clamp())),Uh=x(({color:n,exposure:e})=>{n=n.mul(e),n=n.sub(.004).max(0);const t=n.mul(n.mul(6.2).add(.5)),s=n.mul(n.mul(6.2).add(1.7)).add(.06);return t.div(s).pow(2.2)}),Bh=x(({color:n})=>{const e=n.mul(n.add(.0245786)).sub(90537e-9),t=n.mul(n.add(.432951).mul(.983729)).add(.238081);return e.div(t)}),kh=x(({color:n,exposure:e})=>{const t=Xe(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),s=Xe(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return n=n.mul(e).div(.6),n=t.mul(n),n=Bh({color:n}),n=s.mul(n),n.clamp()}),Gh=Xe(f(1.6605,-.1246,-.0182),f(-.5876,1.1329,-.1006),f(-.0728,-.0083,1.1187)),Wh=Xe(f(.6274,.0691,.0164),f(.3293,.9195,.088),f(.0433,.0113,.8956)),Hh=x(([n])=>{const e=f(n).toVar(),t=f(e.mul(e)).toVar(),s=f(t.mul(t)).toVar();return d(15.5).mul(s.mul(t)).sub(U(40.14,s.mul(e))).add(U(31.96,s).sub(U(6.868,t.mul(e))).add(U(.4298,t).add(U(.1191,e).sub(.00232))))}),qh=x(({color:n,exposure:e})=>{const t=f(n).toVar(),s=Xe(f(.856627153315983,.137318972929847,.11189821299995),f(.0951212405381588,.761241990602591,.0767994186031903),f(.0482516061458583,.101439036467562,.811302368396859)),o=Xe(f(1.1271005818144368,-.1413297634984383,-.14132976349843826),f(-.11060664309660323,1.157823702216272,-.11060664309660294),f(-.016493938717834573,-.016493938717834257,1.2519364065950405)),i=d(-12.47393),a=d(4.026069);return t.mulAssign(e),t.assign(Wh.mul(t)),t.assign(s.mul(t)),t.assign(Pe(t,1e-10)),t.assign(qs(t)),t.assign(t.sub(i).div(a.sub(i))),t.assign(Gt(t,0,1)),t.assign(Hh(t)),t.assign(o.mul(t)),t.assign(Qe(Pe(f(0),t),f(2.2))),t.assign(Gh.mul(t)),t.assign(Gt(t,0,1)),t}),$h={[Sc]:Ph,[Vc]:Fh,[_c]:Uh,[Rc]:kh,[Ac]:qh};class sr extends j{constructor(e=Vs,t=jh,s=null){super("vec3"),this.toneMapping=e,this.exposureNode=t,this.colorNode=s}getCacheKey(){let e=super.getCacheKey();return e="{toneMapping:"+this.toneMapping+",nodes:"+e+"}",e}setup(e){const t=this.colorNode||e.context.color,s=this.toneMapping;if(s===Vs)return t;const o={exposure:this.exposureNode,color:t},i=$h[s];let a=null;return i?a=i(o):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",s),a=t),a}}const Xh=(n,e,t)=>A(new sr(n,A(e),A(t))),jh=dh("toneMappingExposure","float");N("toneMapping",(n,e,t)=>Xh(e,t,n));T("ToneMappingNode",sr);let gn=null;class nr extends hs{constructor(e=rs,t=null){gn===null&&(gn=new oi),super(e,t,gn)}updateReference(){return this}}const Yh=y(nr);N("viewportSharedTexture",Yh);T("ViewportSharedTextureNode",nr);class Gn extends $t{constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class ps extends j{constructor(e,t,s){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this._pixelRatio=1,this._width=1,this._height=1;const o=new $n;o.isRenderTargetTexture=!0,o.name="PostProcessingDepth";const i=new St(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:wc});i.texture.name="PostProcessing",i.depthTexture=o,this.renderTarget=i,this.updateBeforeType=$.FRAME,this._textureNode=A(new Gn(this,i.texture)),this._depthTextureNode=A(new Gn(this,o)),this._depthNode=null,this._viewZNode=null,this._cameraNear=X(0),this._cameraFar=X(0),this.isPassNode=!0}isGlobal(){return!0}getTextureNode(){return this._textureNode}getTextureDepthNode(){return this._depthTextureNode}getViewZNode(){if(this._viewZNode===null){const e=this._cameraNear,t=this._cameraFar;this._viewZNode=Ra(this._depthTextureNode,e,t)}return this._viewZNode}getDepthNode(){if(this._depthNode===null){const e=this._cameraNear,t=this._cameraFar;this._depthNode=Pn(this.getViewZNode(),e,t)}return this._depthNode}setup(){return this.scope===ps.COLOR?this.getTextureNode():this.getDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s,camera:o}=this;this._pixelRatio=t.getPixelRatio();const i=t.getSize(new ne);this.setSize(i.width,i.height);const a=t.toneMapping,r=t.toneMappingNode,c=t.getRenderTarget();this._cameraNear.value=o.near,this._cameraFar.value=o.far,t.toneMapping=Vs,t.toneMappingNode=null,t.setRenderTarget(this.renderTarget),t.render(s,o),t.toneMapping=a,t.toneMappingNode=r,t.setRenderTarget(c)}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,o=this._height*this._pixelRatio;this.renderTarget.setSize(s,o)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}ps.COLOR="color";ps.DEPTH="depth";const uo=(n,e)=>A(new Gn(n,e));T("PassNode",ps);const fn=new ii(-1,1,1,-1,0,1);class Zh extends ri{constructor(e=!1){super();const t=e===!1?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new _s([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new _s(t,2))}}const Kh=new Zh;class Jh extends ai{constructor(e=null){super(Kh,e),this.camera=fn}renderAsync(e){return e.renderAsync(this,fn)}render(e){e.render(this,fn)}}const Qs=Jh,Ho=new Qs,qo=new Qs;class Qh extends j{constructor(e,t=2){super("vec4"),this.textureNode=e,this.sigma=t,this.directionNode=E(1),this._invSize=X(new ne),this._passDirection=X(new ne),this._horizontalRT=new St,this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new St,this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=uo(this,this._verticalRT.texture),this.updateBeforeType=$.RENDER,this.resolution=new ne(1,1)}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value,i=t.getRenderTarget(),a=s.value;Ho.material=this._material,qo.material=this._material,this.setSize(o.image.width,o.image.height);const r=o.type;this._horizontalRT.texture.type=r,this._verticalRT.texture.type=r,t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),Ho.render(t),s.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),qo.render(t),t.setRenderTarget(i),s.value=a}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode;if(t.isTextureNode!==!0)return console.error("GaussianBlurNode requires a TextureNode."),M();const s=t.uvNode||st(),o=c=>t.cache().context({getUV:()=>c,forceUVContext:!0}),i=x(()=>{const c=3+2*this.sigma,u=this._getCoefficients(c),l=this._invSize,p=E(this.directionNode).mul(this._passDirection),g=d(u[0]).toVar(),_=M(o(s).mul(g)).toVar();for(let V=1;V<c;V++){const R=d(V),I=d(u[V]),C=E(p.mul(l.mul(R))).toVar(),z=M(o(s.add(C))),O=M(o(s.sub(C)));_.addAssign(z.add(O).mul(I)),g.addAssign(U(2,I))}return _.div(g)}),a=this._material||(this._material=e.createNodeMaterial());a.fragmentNode=i();const r=e.getNodeProperties(this);return r.textureNode=t,this._textureNode}_getCoefficients(e){const t=[];for(let s=0;s<e;s++)t.push(.39894*Math.exp(-.5*s*s/(e*e))/e);return t}}const ep=(n,e)=>A(new Qh(A(n),e));N("gaussianBlur",ep);const $o=new Qs;class tp extends j{constructor(e,t=.96){super(e),this.textureNode=e,this.textureNodeOld=ze(),this.damp=X(t),this._compRT=new St,this._compRT.texture.name="AfterImageNode.comp",this._oldRT=new St,this._oldRT.texture.name="AfterImageNode.old",this._textureNode=uo(this,this._compRT.texture),this.updateBeforeType=$.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._compRT.setSize(e,t),this._oldRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value,i=o.type;this._compRT.texture.type=i,this._oldRT.texture.type=i;const a=t.getRenderTarget(),r=s.value;this.textureNodeOld.value=this._oldRT.texture,t.setRenderTarget(this._compRT),$o.render(t);const c=this._oldRT;this._oldRT=this._compRT,this._compRT=c,this.setSize(o.image.width,o.image.height),t.setRenderTarget(a),s.value=r}setup(e){const t=this.textureNode,s=this.textureNodeOld;if(t.isTextureNode!==!0)return console.error("AfterImageNode requires a TextureNode."),M();const o=t.uvNode||st();s.uvNode=o;const i=l=>t.cache().context({getUV:()=>l,forceUVContext:!0}),a=x(([l,p])=>{const g=d(p).toVar(),_=M(l).toVar();return Pe(io(_.sub(g)),0)}),r=x(()=>{const l=M(s),p=M(i(o));return l.mulAssign(this.damp.mul(a(l,.1))),Pe(p,l)}),c=this._materialComposed||(this._materialComposed=e.createNodeMaterial());c.fragmentNode=r(),$o.material=c;const u=e.getNodeProperties(this);return u.textureNode=t,this._textureNode}}const sp=(n,e)=>A(new tp(A(n),e));N("afterImage",sp);const Xo=new Qs;class np extends j{constructor(e,t,s,o){super("vec4"),this.textureNode=e,this.tresholdNode=t,this.scaleNode=s,this.colorNode=f(.1,0,1),this.samples=o,this.resolution=new ne(1,1),this._renderTarget=new St,this._renderTarget.texture.name="anamorphic",this._invSize=X(new ne),this._textureNode=uo(this,this._renderTarget.texture),this.updateBeforeType=$.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._invSize.value.set(1/e,1/t),e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._renderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value;this._renderTarget.texture.type=o.type;const i=t.getRenderTarget(),a=s.value;Xo.material=this._material,this.setSize(o.image.width,o.image.height),t.setRenderTarget(this._renderTarget),Xo.render(t),t.setRenderTarget(i),s.value=a}setup(e){const t=this.textureNode;if(t.isTextureNode!==!0)return console.error("AnamorphNode requires a TextureNode."),M();const s=t.uvNode||st(),o=c=>t.cache().context({getUV:()=>c,forceUVContext:!0}),i=x(()=>{const c=this.samples,u=Math.floor(c/2),l=f(0).toVar();return Z({start:-u,end:u},({i:p})=>{const g=d(p).abs().div(u).oneMinus(),_=E(s.x.add(this._invSize.x.mul(p).mul(this.scaleNode)),s.y),V=o(_),R=Qa(V,this.tresholdNode).mul(g);l.addAssign(R)}),l.mul(this.colorNode)}),a=this._material||(this._material=e.createNodeMaterial());a.fragmentNode=i();const r=e.getNodeProperties(this);return r.textureNode=t,this._textureNode}}const op=(n,e=.9,t=3,s=32)=>A(new np(A(n),A(e),A(t),s));N("anamorphic",op);class or extends j{constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],s=this.functionNode,o=s.getInputs(e),i=this.parameters;if(Array.isArray(i))for(let r=0;r<i.length;r++){const c=o[r],u=i[r];t.push(u.build(e,c.type))}else for(const r of o){const c=i[r.name];if(c!==void 0)t.push(c.build(e,r.type));else throw new Error(`FunctionCallNode: Input '${r.name}' not found in FunctionNode.`)}return`${s.build(e,"property")}( ${t.join(", ")} )`}}const ip=(n,...e)=>(e=e.length>1||e[0]&&e[0].isNode===!0?bt(e):Ws(e[0]),A(new or(A(n),e)));N("call",ip);T("FunctionCallNode",or);class ir extends L{constructor(e=null){super(),this._value=e,this._cache=null,this.inputType=null,this.outpuType=null,this.events=new Qo,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return this.outputType!==null}set value(e){this._value!==e&&(this._cache&&this.inputType==="URL"&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=e,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const e=this.value;if(e&&this._cache===null&&this.inputType==="URL"&&e.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([e.value]));else if(e&&e.value!==null&&e.value!==void 0&&((this.inputType==="URL"||this.inputType==="String")&&typeof e.value=="string"||this.inputType==="Number"&&typeof e.value=="number"||this.inputType==="Vector2"&&e.value.isVector2||this.inputType==="Vector3"&&e.value.isVector3||this.inputType==="Vector4"&&e.value.isVector4||this.inputType==="Color"&&e.value.isColor||this.inputType==="Matrix3"&&e.value.isMatrix3||this.inputType==="Matrix4"&&e.value.isMatrix4))return e.value;return this._cache||e}getNodeType(e){return this.value&&this.value.isNode?this.value.getNodeType(e):"float"}setup(){return this.value&&this.value.isNode?this.value:d()}serialize(e){super.serialize(e),this.value!==null?this.inputType==="ArrayBuffer"?e.value=pi(this.value):e.value=this.value?this.value.toJSON(e.meta).uuid:null:e.value=null,e.inputType=this.inputType,e.outputType=this.outputType}deserialize(e){super.deserialize(e);let t=null;e.value!==null&&(e.inputType==="ArrayBuffer"?t=mi(e.value):e.inputType==="Texture"?t=e.meta.textures[e.value]:t=e.meta.nodes[e.value]||null),this.value=t,this.inputType=e.inputType,this.outputType=e.outputType}}const Ss=y(ir);N("scriptableValue",Ss);T("ScriptableValueNode",ir);class ar extends Map{get(e,t=null,...s){if(this.has(e))return super.get(e);if(t!==null){const o=t(...s);return this.set(e,o),o}}}class ap{constructor(e){this.scriptableNode=e}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(e){return this.scriptableNode.getInputLayout(e)}get(e){const t=this.parameters[e];return t?t.getValue():null}}const Nn=new ar;class rr extends L{constructor(e=null,t={}){super(),this.codeNode=e,this.parameters=t,this._local=new ar,this._output=Ss(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(e,t){return this._local.set(e,t)}getLocal(e){return this._local.get(e)}onRefresh(){this._refresh()}getInputLayout(e){for(const t of this.getLayout())if(t.inputType&&(t.id===e||t.name===e))return t}getOutputLayout(e){for(const t of this.getLayout())if(t.outputType&&(t.id===e||t.name===e))return t}setOutput(e,t){const s=this._outputs;return s[e]===void 0?s[e]=Ss(t):s[e].value=t,this}getOutput(e){return this._outputs[e]}getParameter(e){return this.parameters[e]}setParameter(e,t){const s=this.parameters;return t&&t.isScriptableNode?(this.deleteParameter(e),s[e]=t,s[e].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):t&&t.isScriptableValueNode?(this.deleteParameter(e),s[e]=t,s[e].events.addEventListener("refresh",this.onRefresh)):s[e]===void 0?(s[e]=Ss(t),s[e].events.addEventListener("refresh",this.onRefresh)):s[e].value=t,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(e){let t=this.parameters[e];return t&&(t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const e of Object.keys(this.parameters))this.deleteParameter(e);return this.needsUpdate=!0,this}call(e,...t){const o=this.getObject()[e];if(typeof o=="function")return o(...t)}async callAsync(e,...t){const o=this.getObject()[e];if(typeof o=="function")return o.constructor.name==="AsyncFunction"?await o(...t):o(...t)}getNodeType(e){return this.getDefaultOutputNode().getNodeType(e)}refresh(e=null){e!==null?this.getOutput(e).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),this._object!==null)return this._object;const e=()=>this.refresh(),t=(u,l)=>this.setOutput(u,l),s=new ap(this),o=Nn.get("THREE"),i=Nn.get("TSL"),a=this.getMethod(this.codeNode),r=[s,this._local,Nn,e,t,o,i];this._object=a(...r);const c=this._object.layout;if(c&&(c.cache===!1&&this._local.clear(),this._output.outputType=c.outputType||null,Array.isArray(c.elements)))for(const u of c.elements){const l=u.id||u.name;u.inputType&&(this.getParameter(l)===void 0&&this.setParameter(l,null),this.getParameter(l).inputType=u.inputType),u.outputType&&(this.getOutput(l)===void 0&&this.setOutput(l,null),this.getOutput(l).outputType=u.outputType)}return this._object}deserialize(e){super.deserialize(e);for(const t in this.parameters){let s=this.parameters[t];s.isScriptableNode&&(s=s.getDefaultOutput()),s.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const e=this.getDefaultOutput().value;return e&&e.isNode?e:d()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),this._method!==null)return this._method;const e=["parameters","local","global","refresh","setOutput","THREE","TSL"],s=["layout","init","main","dispose"].join(", "),o="var "+s+`; var output = {};
`,i=`
return { ...output, `+s+" };",a=o+this.codeNode.code+i;return this._method=new Function(...e,a),this._method}dispose(){this._method!==null&&(this._object&&typeof this._object.dispose=="function"&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}set needsUpdate(e){e===!0&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return this.codeNode===null?this:(this._needsOutputUpdate===!0&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value,this)}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const rp=y(rr);N("scriptable",rp);T("ScriptableNode",rr);class en extends L{constructor(e,t){super("float"),this.isFogNode=!0,this.colorNode=e,this.factorNode=t}getViewZNode(e){let t;const s=e.context.getViewZ;return s!==void 0&&(t=s(this)),(t||Oe.z).negate()}setup(){return this.factorNode}}const cp=y(en);N("fog",cp);T("FogNode",en);class cr extends en{constructor(e,t,s){super(e),this.isFogRangeNode=!0,this.nearNode=t,this.farNode=s}setup(e){const t=this.getViewZNode(e);return at(this.nearNode,this.farNode,t)}}const up=y(cr);N("rangeFog",up);T("FogRangeNode",cr);class ur extends en{constructor(e,t){super(e),this.isFogExp2Node=!0,this.densityNode=t}setup(e){const t=this.getViewZNode(e),s=this.densityNode;return s.mul(s,t,t).negate().exp().oneMinus()}}const lp=y(ur);N("densityFog",lp);T("FogExp2Node",ur);let Nt=null,yt=null;class lr extends L{constructor(e=d(),t=d()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(dt(this.minNode.value)),s=e.getTypeLength(dt(this.maxNode.value));return t>s?t:s}getNodeType(e){return e.object.isInstancedMesh===!0?e.getTypeFromLength(this.getVectorLength(e)):"float"}setup(e){const t=e.object;let s=null;if(t.isInstancedMesh===!0){const o=this.minNode.value,i=this.maxNode.value,a=e.getTypeLength(dt(o)),r=e.getTypeLength(dt(i));Nt=Nt||new pt,yt=yt||new pt,Nt.setScalar(0),yt.setScalar(0),a===1?Nt.setScalar(o):o.isColor?Nt.set(o.r,o.g,o.b):Nt.set(o.x,o.y,o.z||0,o.w||0),r===1?yt.setScalar(i):i.isColor?yt.set(i.r,i.g,i.b):yt.set(i.x,i.y,i.z||0,i.w||0);const c=4,u=c*t.count,l=new Float32Array(u);for(let g=0;g<u;g++){const _=g%c,V=Nt.getComponent(_),R=yt.getComponent(_);l[g]=ei.lerp(V,R,Math.random())}const p=this.getNodeType(e);s=ao(l,"vec4",t.count).element(Ri).convert(p)}else s=d(0);return s}}y(lr);T("RangeNode",lr);class dr extends L{constructor(e,t,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=e,this.count=t,this.workgroupSize=s,this.dispatchCount=0,this.version=1,this.updateBeforeType=$.OBJECT,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}updateDispatchCount(){const{count:e,workgroupSize:t}=this;let s=t[0];for(let o=1;o<t.length;o++)s*=t[o];this.dispatchCount=Math.ceil(e/s)}onInit(){}updateBefore({renderer:e}){e.compute(this)}generate(e){const{shaderStage:t}=e;if(t==="compute"){const s=this.computeNode.build(e,"void");s!==""&&e.addLineFlowCode(s)}}}const dp=(n,e,t)=>A(new dr(A(n),e,t));N("compute",dp);T("ComputeNode",dr);class Rt extends L{constructor(e=Rt.TARGET_DIRECTION,t=null){super(),this.scope=e,this.light=t}setup(){const{scope:e,light:t}=this;let s=null;return e===Rt.TARGET_DIRECTION&&(s=rt.transformDirection(Ln(t).sub(Ln(t.target)))),s}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}Rt.TARGET_DIRECTION="targetDirection";const hr=y(Rt,Rt.TARGET_DIRECTION);T("LightNode",Rt);const pr=x(n=>{const{lightDistance:e,cutoffDistance:t,decayExponent:s}=n,o=e.pow(s).max(.01).reciprocal();return t.greaterThan(0).cond(o.mul(e.div(t).pow4().oneMinus().clamp().pow2()),o)});class mr extends Mt{constructor(e=null){super(e),this.cutoffDistanceNode=X(0),this.decayExponentNode=X(0)}update(e){const{light:t}=this;super.update(e),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}setup(e){const{colorNode:t,cutoffDistanceNode:s,decayExponentNode:o,light:i}=this,a=e.context.lightingModel,r=Ji(i).sub(Oe),c=r.normalize(),u=r.length(),l=pr({lightDistance:u,cutoffDistance:s,decayExponent:o}),p=t.mul(l),g=e.context.reflectedLight;a.direct({lightDirection:c,lightColor:p,reflectedLight:g,shadowMask:this.shadowMaskNode},e.stack,e)}}T("PointLightNode",mr);jt(Mc,mr);class gr extends Mt{constructor(e=null){super(e)}setup(e){super.setup(e);const t=e.context.lightingModel,s=this.colorNode,o=hr(this.light),i=e.context.reflectedLight;t.direct({lightDirection:o,lightColor:s,reflectedLight:i,shadowMask:this.shadowMaskNode},e.stack,e)}}T("DirectionalLightNode",gr);jt(Cc,gr);class lo extends Mt{constructor(e=null){super(e),this.coneCosNode=X(0),this.penumbraCosNode=X(0),this.cutoffDistanceNode=X(0),this.decayExponentNode=X(0)}update(e){super.update(e);const{light:t}=this;this.coneCosNode.value=Math.cos(t.angle),this.penumbraCosNode.value=Math.cos(t.angle*(1-t.penumbra)),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}getSpotAttenuation(e){const{coneCosNode:t,penumbraCosNode:s}=this;return at(t,s,e)}setup(e){super.setup(e);const t=e.context.lightingModel,{colorNode:s,cutoffDistanceNode:o,decayExponentNode:i,light:a}=this,r=Ji(a).sub(Oe),c=r.normalize(),u=c.dot(hr(a)),l=this.getSpotAttenuation(u),p=r.length(),g=pr({lightDistance:p,cutoffDistance:o,decayExponent:i}),_=s.mul(l).mul(g),V=e.context.reflectedLight;t.direct({lightDirection:c,lightColor:_,reflectedLight:V,shadowMask:this.shadowMaskNode},e.stack,e)}}T("SpotLightNode",lo);jt(ci,lo);class hp extends ci{constructor(e,t,s,o,i,a){super(e,t,s,o,i,a),this.iesMap=null}copy(e,t){return super.copy(e,t),this.iesMap=e.iesMap,this}}const pp=hp;class fr extends lo{getSpotAttenuation(e){const t=this.light.iesMap;let s=null;if(t&&t.isTexture===!0){const o=e.acos().mul(1/Math.PI);s=ze(t,E(o,0),0).r}else s=super.getSpotAttenuation(e);return s}}T("IESSpotLightNode",fr);jt(pp,fr);class Nr extends Mt{constructor(e=null){super(e)}setup({context:e}){e.irradiance.addAssign(this.colorNode)}}T("AmbientLightNode",Nr);jt(Ec,Nr);class yr extends Mt{constructor(e=null){super(e),this.lightPositionNode=Ln(e),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=X(new ot)}update(e){const{light:t}=this;super.update(e),this.lightPositionNode.object3d=t,this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity)}setup(e){const{colorNode:t,groundColorNode:s,lightDirectionNode:o}=this,a=gt.dot(o).mul(.5).add(.5),r=xe(s,t,a);e.context.irradiance.addAssign(r)}}T("HemisphereLightNode",yr);jt(Lc,yr);const mp=x(n=>{const e=n.uv.mul(2),t=e.x.floor(),s=e.y.floor();return t.add(s).mod(2).sign()});class xr extends j{constructor(e=st()){super("float"),this.uvNode=e}setup(){return mp({uv:this.uvNode})}}const gp=y(xr);N("checker",gp);T("CheckerNode",xr);const fp=new ui;class Np extends Fe{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.pointWidth=1,this.pointColorNode=null,this.setDefaultValues(fp),this.setupShaders(),this.setValues(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor;this.vertexNode=x(()=>{oe(E(),"vUv").assign(st());const s=Te("instancePosition"),o=fe("vec4","mvPos");o.assign(_t.mul(M(s,1)));const i=Ft.z.div(Ft.w),a=Ke.mul(o),r=fe("vec2","offset");return r.assign(Ae.xy),r.assign(r.mul(gd)),r.assign(r.div(Ft.z)),r.y.assign(r.y.mul(i)),r.assign(r.mul(a.w)),a.assign(a.add(M(r,0,0))),a})(),this.fragmentNode=x(()=>{const s=oe(E(),"vUv"),o=fe("float","alpha");o.assign(1);const i=s.x,a=s.y,r=i.mul(i).add(a.mul(a));if(e){const u=fe("float","dlen");u.assign(r.fwidth()),o.assign(at(u.oneMinus(),u.add(1),r).oneMinus())}else r.greaterThan(1).discard();let c;return this.pointColorNode?c=this.pointColorNode:t?c=Te("instanceColor").mul(as):c=as,M(c,o)})(),this.needsUpdate=!0}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.setupShaders())}}Re("InstancedPointsNodeMaterial",Np);const yp=new Ic;class xp extends Fe{constructor(e){super(),this.isLineBasicNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(yp),this.setValues(e)}}Re("LineBasicNodeMaterial",xp);const vp=new li;class Tp extends Fe{constructor(e){super(),this.isLineDashedNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(vp),this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setupVariants(){const e=this.offsetNode,t=this.dashScaleNode?d(this.dashScaleNode):In,s=this.dashSizeNode?d(this.dashSizeNode):na,o=this.dashSizeNode?d(this.dashGapNode):oa;Pt.assign(s),Es.assign(o);const i=oe(Te("lineDistance").mul(t));(e?i.add(e):i).mod(Pt.add(Es)).greaterThan(Pt).discard()}}Re("LineDashedNodeMaterial",Tp);const Sp=new li;class Vp extends Fe{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.setDefaultValues(Sp),this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.useDash=e.dashed,this.useWorldUnits=!1,this.dashOffset=0,this.lineWidth=1,this.lineColorNode=null,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setup(e){this.setupShaders(),super.setup(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor,s=this.dashed,o=this.worldUnits,i=x(({start:r,end:c})=>{const u=Ke.element(2).element(2),g=Ke.element(3).element(2).mul(-.5).div(u).sub(r.z).div(c.z.sub(r.z));return M(xe(r.xyz,c.xyz,g),c.w)});this.vertexNode=x(()=>{Ze("vec2","vUv").assign(st());const r=Te("instanceStart"),c=Te("instanceEnd"),u=fe("vec4","start"),l=fe("vec4","end");u.assign(_t.mul(M(r,1))),l.assign(_t.mul(M(c,1))),o&&(Ze("vec3","worldStart").assign(u.xyz),Ze("vec3","worldEnd").assign(l.xyz));const p=Ft.z.div(Ft.w),g=Ke.element(2).element(3).equal(-1);P(g,()=>{P(u.z.lessThan(0).and(l.z.greaterThan(0)),()=>{l.assign(i({start:u,end:l}))}).elseif(l.z.lessThan(0).and(u.z.greaterThanEqual(0)),()=>{u.assign(i({start:l,end:u}))})});const _=Ke.mul(u),V=Ke.mul(l),R=_.xyz.div(_.w),I=V.xyz.div(V.w),C=I.xy.sub(R.xy).temp();C.x.assign(C.x.mul(p)),C.assign(C.normalize());const z=os(M());if(o){const O=l.xyz.sub(u.xyz).normalize(),B=xe(u.xyz,l.xyz,.5).normalize(),K=O.cross(B).normalize(),F=O.cross(K),Y=Ze("vec4","worldPos");Y.assign(Ae.y.lessThan(.5).cond(u,l));const J=on.mul(.5);Y.addAssign(M(Ae.x.lessThan(0).cond(K.mul(J),K.mul(J).negate()),0)),s||(Y.addAssign(M(Ae.y.lessThan(.5).cond(O.mul(J).negate(),O.mul(J)),0)),Y.addAssign(M(F.mul(J),0)),P(Ae.y.greaterThan(1).or(Ae.y.lessThan(0)),()=>{Y.subAssign(M(F.mul(2).mul(J),0))})),z.assign(Ke.mul(Y));const Ct=os(f());Ct.assign(Ae.y.lessThan(.5).cond(R,I)),z.z.assign(Ct.z.mul(z.w))}else{const O=fe("vec2","offset");O.assign(E(C.y,C.x.negate())),C.x.assign(C.x.div(p)),O.x.assign(O.x.div(p)),O.assign(Ae.x.lessThan(0).cond(O.negate(),O)),P(Ae.y.lessThan(0),()=>{O.assign(O.sub(C))}).elseif(Ae.y.greaterThan(1),()=>{O.assign(O.add(C))}),O.assign(O.mul(on)),O.assign(O.div(Ft.w)),z.assign(Ae.y.lessThan(.5).cond(_,V)),O.assign(O.mul(z.w)),z.assign(z.add(M(O,0,0)))}return z})();const a=x(({p1:r,p2:c,p3:u,p4:l})=>{const p=r.sub(u),g=l.sub(u),_=c.sub(r),V=p.dot(g),R=g.dot(_),I=p.dot(_),C=g.dot(g),O=_.dot(_).mul(C).sub(R.mul(R)),K=V.mul(R).sub(I.mul(C)).div(O).clamp(),F=V.add(R.mul(K)).div(C).clamp();return E(K,F)});this.fragmentNode=x(()=>{const r=Ze("vec2","vUv");if(s){const l=this.offsetNode?d(this.offsetNodeNode):Mo,p=this.dashScaleNode?d(this.dashScaleNode):In,g=this.dashSizeNode?d(this.dashSizeNode):na,_=this.dashSizeNode?d(this.dashGapNode):oa;Pt.assign(g),Es.assign(_);const V=Te("instanceDistanceStart"),R=Te("instanceDistanceEnd"),I=Ae.y.lessThan(.5).cond(p.mul(V),In.mul(R)),C=oe(I.add(Mo)),z=l?C.add(l):C;r.y.lessThan(-1).or(r.y.greaterThan(1)).discard(),z.mod(Pt.add(Es)).greaterThan(Pt).discard()}const c=fe("float","alpha");if(c.assign(1),o){const l=Ze("vec3","worldStart"),p=Ze("vec3","worldEnd"),g=Ze("vec4","worldPos").xyz.normalize().mul(1e5),_=p.sub(l),V=a({p1:l,p2:p,p3:f(0,0,0),p4:g}),R=l.add(_.mul(V.x)),I=g.mul(V.y),O=R.sub(I).length().div(on);if(!s)if(e){const B=O.fwidth();c.assign(at(B.negate().add(.5),B.add(.5),O).oneMinus())}else O.greaterThan(.5).discard()}else if(e){const l=r.x,p=r.y.greaterThan(0).cond(r.y.sub(1),r.y.add(1)),g=l.mul(l).add(p.mul(p)),_=fe("float","dlen");_.assign(g.fwidth()),P(r.y.abs().greaterThan(1),()=>{c.assign(at(_.oneMinus(),_.add(1),g).oneMinus())})}else P(r.y.abs().greaterThan(1),()=>{const l=r.x,p=r.y.greaterThan(0).cond(r.y.sub(1),r.y.add(1));l.mul(l).add(p.mul(p)).greaterThan(1).discard()});let u;if(this.lineColorNode)u=this.lineColorNode;else if(t){const l=Te("instanceColorStart"),p=Te("instanceColorEnd");u=Ae.y.lessThan(.5).cond(l,p).mul(as)}else u=as;return M(u,c)})()}get worldUnits(){return this.useWorldUnits}set worldUnits(e){this.useWorldUnits!==e&&(this.useWorldUnits=e,this.needsUpdate=!0)}get dashed(){return this.useDash}set dashed(e){this.useDash!==e&&(this.useDash=e,this.needsUpdate=!0)}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.needsUpdate=!0)}}Re("Line2NodeMaterial",Vp);const _p=new Oc;class Rp extends Fe{constructor(e){super(),this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(_p),this.setValues(e)}setupDiffuseColor(){const e=this.opacityNode?d(this.opacityNode):sa;te.assign(M(Fa(ie),e))}}Re("MeshNormalNodeMaterial",Rp);const Ap=new bc;class wp extends Fe{constructor(e){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!1,this.setDefaultValues(Ap),this.setValues(e)}}Re("MeshBasicNodeMaterial",wp);const cs=x(({f0:n,f90:e,dotVH:t})=>{const s=t.mul(-5.55473).sub(6.98316).mul(t).exp2();return n.mul(s.oneMinus()).add(e.mul(s))}),Ds=x(n=>n.diffuseColor.mul(1/Math.PI)),Mp=()=>d(.25),Cp=x(({dotNH:n})=>wn.mul(d(.5)).add(1).mul(d(1/Math.PI)).mul(n.pow(wn))),Ep=x(({lightDirection:n})=>{const e=n.add(se).normalize(),t=ie.dot(e).clamp(),s=se.dot(e).clamp(),o=cs({f0:We,f90:1,dotVH:s}),i=Mp(),a=Cp({dotNH:t});return o.mul(i).mul(a)});class vr extends Qn{constructor(e=!0){super(),this.specular=e}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const i=ie.dot(e).clamp().mul(t);s.directDiffuse.addAssign(i.mul(Ds({diffuseColor:te.rgb}))),this.specular===!0&&s.directSpecular.addAssign(i.mul(Ep({lightDirection:e})).mul(Zl))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Ds({diffuseColor:te})))}}const Lp=new zc;class Ip extends Fe{constructor(e){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(Lp),this.setValues(e)}setupLightingModel(){return new vr(!1)}}Re("MeshLambertNodeMaterial",Ip);const Op=new Dc;class bp extends Fe{constructor(e){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(Op),this.setValues(e)}setupLightingModel(){return new vr}setupVariants(){const e=(this.shininessNode?d(this.shininessNode):$l).max(1e-4);wn.assign(e);const t=this.specularNode||jl;We.assign(t)}copy(e){return this.shininessNode=e.shininessNode,this.specularNode=e.specularNode,super.copy(e)}}Re("MeshPhongNodeMaterial",bp);const zp=x(()=>{const n=Ls.dFdx().abs().max(Ls.dFdy().abs());return n.x.max(n.y).max(n.z)}),Dp=x(n=>{const{roughness:e}=n,t=zp();let s=e.max(.0525);return s=s.add(t),s=s.min(1),s}),Pp=x(({alpha:n,dotNL:e,dotNV:t})=>{const s=n.pow2(),o=e.mul(s.add(s.oneMinus().mul(t.pow2())).sqrt()),i=t.mul(s.add(s.oneMinus().mul(e.pow2())).sqrt());return mt(.5,o.add(i).max(Di))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),Fp=x(({alphaT:n,alphaB:e,dotTV:t,dotBV:s,dotTL:o,dotBL:i,dotNV:a,dotNL:r})=>{const c=r.mul(f(n.mul(t),e.mul(s),a).length()),u=a.mul(f(n.mul(o),e.mul(i),r).length());return mt(.5,c.add(u)).saturate()}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),Up=x(({alpha:n,dotNH:e})=>{const t=n.pow2(),s=e.pow2().mul(t.oneMinus()).oneMinus();return t.div(s.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),Bp=d(1/Math.PI),kp=x(({alphaT:n,alphaB:e,dotNH:t,dotTH:s,dotBH:o})=>{const i=n.mul(e),a=f(e.mul(s),n.mul(o),i.mul(t)),r=a.dot(a),c=i.div(r);return Bp.mul(i.mul(c.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),jo=x(n=>{const{lightDirection:e,f0:t,f90:s,roughness:o,f:i,USE_IRIDESCENCE:a,USE_ANISOTROPY:r}=n,c=n.normalView||ie,u=o.pow2(),l=e.add(se).normalize(),p=c.dot(e).clamp(),g=c.dot(se).clamp(),_=c.dot(l).clamp(),V=se.dot(l).clamp();let R=cs({f0:t,f90:s,dotVH:V}),I,C;if(So(a)&&(R=to.mix(R,i)),So(r)){const z=vs.dot(e),O=vs.dot(se),B=vs.dot(l),K=Dt.dot(e),F=Dt.dot(se),Y=Dt.dot(l);I=Fp({alphaT:An,alphaB:u,dotTV:O,dotBV:F,dotTL:z,dotBL:K,dotNV:g,dotNL:p}),C=kp({alphaT:An,alphaB:u,dotNH:_,dotTH:B,dotBH:Y})}else I=Pp({alpha:u,dotNL:p,dotNV:g}),C=Up({alpha:u,dotNH:_});return R.mul(I).mul(C)}),Tr=x(({roughness:n,dotNV:e})=>{const t=M(-1,-.0275,-.572,.022),s=M(1,.0425,1.04,-.04),o=n.mul(t).add(s),i=o.x.mul(o.x).min(e.mul(-9.28).exp2()).mul(o.x).add(o.y);return E(-1.04,1.04).mul(i).add(o.zw)}).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),Sr=x(n=>{const{dotNV:e,specularColor:t,specularF90:s,roughness:o}=n,i=Tr({dotNV:e,roughness:o});return t.mul(i.x).add(s.mul(i.y))}),Gp=x(({f:n,f90:e,dotVH:t})=>{const s=t.oneMinus().saturate(),o=s.mul(s),i=s.mul(o,o).clamp(0,.9999);return n.sub(f(e).mul(i)).div(i.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),Wp=x(({roughness:n,dotNH:e})=>{const t=n.pow2(),s=d(1).div(t),i=e.pow2().oneMinus().max(.0078125);return d(2).add(s).mul(i.pow(s.mul(.5))).div(2*Math.PI)}).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),Hp=x(({dotNV:n,dotNL:e})=>d(1).div(d(4).mul(e.add(n).sub(e.mul(n))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),qp=x(({lightDirection:n})=>{const e=n.add(se).normalize(),t=ie.dot(n).clamp(),s=ie.dot(se).clamp(),o=ie.dot(e).clamp(),i=Wp({roughness:eo,dotNH:o}),a=Hp({dotNV:s,dotNL:t});return Lt.mul(i).mul(a)}),$p=x(([n,e,t,s,o])=>{const i=f(Hi(e.negate(),_e(n),mt(1,s))),a=f(ts(o[0].xyz),ts(o[1].xyz),ts(o[2].xyz));return _e(i).mul(t.mul(a))}).setLayout({name:"getVolumeTransmissionRay",type:"vec3",inputs:[{name:"n",type:"vec3"},{name:"v",type:"vec3"},{name:"thickness",type:"float"},{name:"ior",type:"float"},{name:"modelMatrix",type:"mat4"}]}),Xp=x(([n,e])=>n.mul(Gt(e.mul(2).sub(2),0,1))).setLayout({name:"applyIorToRoughness",type:"float",inputs:[{name:"roughness",type:"float"},{name:"ior",type:"float"}]}),jp=Sa(),Yp=x(([n,e,t])=>{const s=jp.uv(n),o=qs(d(Dn.x)).mul(Xp(e,t));return s.bicubic(o)}),Zp=x(([n,e,t])=>(P(t.notEqual(0),()=>{const s=Ui(e).negate().div(t);return Fi(s.negate().mul(n))}),f(1))).setLayout({name:"volumeAttenuation",type:"vec3",inputs:[{name:"transmissionDistance",type:"float"},{name:"attenuationColor",type:"vec3"},{name:"attenuationDistance",type:"float"}]}),Kp=x(([n,e,t,s,o,i,a,r,c,u,l,p,g,_])=>{const V=$p(n,e,p,l,r),R=a.add(V),I=u.mul(c.mul(M(R,1))),C=E(I.xy.div(I.w)).toVar();C.addAssign(1),C.divAssign(2),C.assign(E(C.x,C.y.oneMinus()));const z=Yp(C,t,l),O=s.mul(Zp(ts(V),g,_)),B=O.rgb.mul(z.rgb),K=n.dot(e).clamp(),F=f(Sr({dotNV:K,specularColor:o,specularF90:i,roughness:t})),Y=O.r.add(O.g,O.b).div(3);return M(F.oneMinus().mul(B),z.a.oneMinus().mul(Y).oneMinus())}),Jp=Xe(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),Qp=n=>{const e=n.sqrt();return f(1).add(e).div(f(1).sub(e))},Yo=(n,e)=>n.sub(e).div(n.add(e)).pow2(),em=(n,e)=>{const t=n.mul(2*Math.PI*1e-9),s=f(54856e-17,44201e-17,52481e-17),o=f(1681e3,1795300,2208400),i=f(43278e5,93046e5,66121e5),a=d(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());let r=s.mul(i.mul(2*Math.PI).sqrt()).mul(o.mul(t).add(e).cos()).mul(t.pow2().negate().mul(i).exp());return r=f(r.x.add(a),r.y,r.z).div(10685e-11),Jp.mul(r)},tm=x(({outsideIOR:n,eta2:e,cosTheta1:t,thinFilmThickness:s,baseF0:o})=>{const i=xe(n,e,at(0,.03,s)),a=n.div(i).pow2().mul(d(1).sub(t.pow2())),c=d(1).sub(a).sqrt(),u=Yo(i,n),l=cs({f0:u,f90:1,dotVH:t}),p=l.oneMinus(),g=i.lessThan(n).cond(Math.PI,0),_=d(Math.PI).sub(g),V=Qp(o.clamp(0,.9999)),R=Yo(V,i.vec3()),I=cs({f0:R,f90:1,dotVH:c}),C=f(V.x.lessThan(i).cond(Math.PI,0),V.y.lessThan(i).cond(Math.PI,0),V.z.lessThan(i).cond(Math.PI,0)),z=i.mul(s,c,2),O=f(_).add(C),B=l.mul(I).clamp(1e-5,.9999),K=B.sqrt(),F=p.pow2().mul(I).div(f(1).sub(B));let J=l.add(F),Ct=F.sub(p);for(let ms=1;ms<=2;++ms){Ct=Ct.mul(K);const rc=em(d(ms).mul(z),d(ms).mul(O)).mul(2);J=J.add(Ct.mul(rc))}return J.max(f(0))}).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),sm=x(({normal:n,viewDir:e,roughness:t})=>{const s=n.dot(e).saturate(),o=t.pow2(),i=be(t.lessThan(.25),d(-339.2).mul(o).add(d(161.4).mul(t)).sub(25.9),d(-8.48).mul(o).add(d(14.3).mul(t)).sub(9.95)),a=be(t.lessThan(.25),d(44).mul(o).sub(d(23.7).mul(t)).add(3.26),d(1.97).mul(o).sub(d(3.27).mul(t)).add(.72));return be(t.lessThan(.25),0,d(.1).mul(t).sub(.025)).add(i.mul(s).add(a).exp()).mul(1/Math.PI).saturate()}),yn=f(.04),xn=f(1);class ho extends Qn{constructor(e=!1,t=!1,s=!1,o=!1,i=!1){super(),this.clearcoat=e,this.sheen=t,this.iridescence=s,this.anisotropy=o,this.transmission=i,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null}start(e){if(this.clearcoat===!0&&(this.clearcoatRadiance=f().temp("clearcoatRadiance"),this.clearcoatSpecularDirect=f().temp("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=f().temp("clearcoatSpecularIndirect")),this.sheen===!0&&(this.sheenSpecularDirect=f().temp("sheenSpecularDirect"),this.sheenSpecularIndirect=f().temp("sheenSpecularIndirect")),this.iridescence===!0){const t=ie.dot(se).clamp();this.iridescenceFresnel=tm({outsideIOR:d(1),eta2:wi,cosTheta1:t,thinFilmThickness:Mi,baseF0:We}),this.iridescenceF0=Gp({f:this.iridescenceFresnel,f90:1,dotVH:t})}if(this.transmission===!0){const t=On,s=Hl.sub(On).normalize(),o=ta;e.backdrop=Kp(o,s,ht,te,We,Cs,t,is,rt,Ke,Ts,Ci,Li,Ei),e.backdropAlpha=Mn,te.a.mulAssign(xe(1,e.backdrop.a,Mn))}}computeMultiscattering(e,t,s){const o=ie.dot(se).clamp(),i=Tr({roughness:ht,dotNV:o}),r=(this.iridescenceF0?to.mix(We,this.iridescenceF0):We).mul(i.x).add(s.mul(i.y)),u=i.x.add(i.y).oneMinus(),l=We.add(We.oneMinus().mul(.047619)),p=r.mul(l).div(u.mul(l).oneMinus());e.addAssign(r),t.addAssign(p.mul(u))}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const i=ie.dot(e).clamp().mul(t);if(this.sheen===!0&&this.sheenSpecularDirect.addAssign(i.mul(qp({lightDirection:e}))),this.clearcoat===!0){const r=It.dot(e).clamp().mul(t);this.clearcoatSpecularDirect.addAssign(r.mul(jo({lightDirection:e,f0:yn,f90:xn,roughness:Ms,normalView:It})))}s.directDiffuse.addAssign(i.mul(Ds({diffuseColor:te.rgb}))),s.directSpecular.addAssign(i.mul(jo({lightDirection:e,f0:We,f90:1,roughness:ht,iridescence:this.iridescence,f:this.iridescenceFresnel,USE_IRIDESCENCE:this.iridescence,USE_ANISOTROPY:this.anisotropy})))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Ds({diffuseColor:te})))}indirectSpecular({radiance:e,iblIrradiance:t,reflectedLight:s}){if(this.sheen===!0&&this.sheenSpecularIndirect.addAssign(t.mul(Lt,sm({normal:ie,viewDir:se,roughness:eo}))),this.clearcoat===!0){const u=It.dot(se).clamp(),l=Sr({dotNV:u,specularColor:yn,specularF90:xn,roughness:Ms});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(l))}const o=f().temp("singleScattering"),i=f().temp("multiScattering"),a=t.mul(1/Math.PI);this.computeMultiscattering(o,i,Cs);const r=o.add(i),c=te.mul(r.r.max(r.g).max(r.b).oneMinus());s.indirectSpecular.addAssign(e.mul(o)),s.indirectSpecular.addAssign(i.mul(a)),s.indirectDiffuse.addAssign(c.mul(a))}ambientOcclusion({ambientOcclusion:e,reflectedLight:t}){const o=ie.dot(se).clamp().add(e),i=ht.mul(-16).oneMinus().negate().exp2(),a=e.sub(o.pow(i).oneMinus()).clamp();this.clearcoat===!0&&this.clearcoatSpecularIndirect.mulAssign(e),this.sheen===!0&&this.sheenSpecularIndirect.mulAssign(e),t.indirectDiffuse.mulAssign(e),t.indirectSpecular.mulAssign(a)}finish(e){const{outgoingLight:t}=e;if(this.clearcoat===!0){const s=It.dot(se).clamp(),o=cs({dotVH:s,f0:yn,f90:xn}),i=t.mul(Rn.mul(o).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(Rn));t.assign(i)}if(this.sheen===!0){const s=Lt.r.max(Lt.g).max(Lt.b).mul(.157).oneMinus(),o=t.mul(s).add(this.sheenSpecularDirect,this.sheenSpecularIndirect);t.assign(o)}}}const nm=new Pc;class Vr extends Fe{constructor(e){super(),this.isMeshStandardNodeMaterial=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(nm),this.setValues(e)}setupLightingModel(){return new ho}setupSpecular(){const e=xe(f(.04),te.rgb,ws);We.assign(e),Cs.assign(1)}setupVariants(){const e=this.metalnessNode?d(this.metalnessNode):Jl;ws.assign(e);let t=this.roughnessNode?d(this.roughnessNode):Kl;t=Dp({roughness:t}),ht.assign(t),this.setupSpecular(),te.assign(M(te.rgb.mul(e.oneMinus()),te.a))}copy(e){return this.emissiveNode=e.emissiveNode,this.metalnessNode=e.metalnessNode,this.roughnessNode=e.roughnessNode,super.copy(e)}}Re("MeshStandardNodeMaterial",Vr);const om=new Fc;class _r extends Vr{constructor(e){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.iorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.anisotropyNode=null,this.setDefaultValues(om),this.setValues(e)}get useClearcoat(){return this.clearcoat>0||this.clearcoatNode!==null}get useIridescence(){return this.iridescence>0||this.iridescenceNode!==null}get useSheen(){return this.sheen>0||this.sheenNode!==null}get useAnisotropy(){return this.anisotropy>0||this.anisotropyNode!==null}get useTransmission(){return this.transmission>0||this.transmissionNode!==null}setupSpecular(){const e=this.iorNode?d(this.iorNode):hd;Ts.assign(e),We.assign(xe(kt(Wi(Ts.sub(1).div(Ts.add(1))).mul(Yl),f(1)).mul(wo),te.rgb,ws)),Cs.assign(xe(wo,1,ws))}setupLightingModel(){return new ho(this.useClearcoat,this.useSheen,this.useIridescence,this.useAnisotropy,this.useTransmission)}setupVariants(e){if(super.setupVariants(e),this.useClearcoat){const t=this.clearcoatNode?d(this.clearcoatNode):ed,s=this.clearcoatRoughnessNode?d(this.clearcoatRoughnessNode):td;Rn.assign(t),Ms.assign(s)}if(this.useSheen){const t=this.sheenNode?f(this.sheenNode):od,s=this.sheenRoughnessNode?d(this.sheenRoughnessNode):id;Lt.assign(t),eo.assign(s)}if(this.useIridescence){const t=this.iridescenceNode?d(this.iridescenceNode):rd,s=this.iridescenceIORNode?d(this.iridescenceIORNode):cd,o=this.iridescenceThicknessNode?d(this.iridescenceThicknessNode):ud;to.assign(t),wi.assign(s),Mi.assign(o)}if(this.useAnisotropy){const t=(this.anisotropyNode?E(this.anisotropyNode):ad).toVar();xt.assign(t.length()),P(xt.equal(0),()=>{t.assign(E(1,0))}).else(()=>{t.divAssign(xt),xt.assign(xt.saturate())}),An.assign(xt.pow2().mix(ht.pow2(),1)),vs.assign(Ot[0].mul(t.x).add(Ot[1].mul(t.y))),Dt.assign(Ot[1].mul(t.x).sub(Ot[0].mul(t.y)))}if(this.useTransmission){const t=this.transmissionNode?d(this.transmissionNode):ld,s=this.thicknessNode?d(this.thicknessNode):dd,o=this.attenuationDistanceNode?d(this.attenuationDistanceNode):pd,i=this.attenuationColorNode?f(this.attenuationColorNode):md;Mn.assign(t),Ci.assign(s),Ei.assign(o),Li.assign(i)}}setupNormal(e){super.setupNormal(e);const t=this.clearcoatNormalNode?f(this.clearcoatNormalNode):sd;It.assign(t)}copy(e){return this.clearcoatNode=e.clearcoatNode,this.clearcoatRoughnessNode=e.clearcoatRoughnessNode,this.clearcoatNormalNode=e.clearcoatNormalNode,this.sheenNode=e.sheenNode,this.sheenRoughnessNode=e.sheenRoughnessNode,this.iridescenceNode=e.iridescenceNode,this.iridescenceIORNode=e.iridescenceIORNode,this.iridescenceThicknessNode=e.iridescenceThicknessNode,this.specularIntensityNode=e.specularIntensityNode,this.specularColorNode=e.specularColorNode,this.transmissionNode=e.transmissionNode,this.thicknessNode=e.thicknessNode,this.attenuationDistanceNode=e.attenuationDistanceNode,this.attenuationColorNode=e.attenuationColorNode,this.anisotropyNode=e.anisotropyNode,super.copy(e)}}Re("MeshPhysicalNodeMaterial",_r);class im extends ho{constructor(e,t,s,o){super(e,t,s),this.useSSS=o}direct({lightDirection:e,lightColor:t,reflectedLight:s},o,i){if(this.useSSS===!0){const a=i.material,{thicknessColorNode:r,thicknessDistortionNode:c,thicknessAmbientNode:u,thicknessAttenuationNode:l,thicknessPowerNode:p,thicknessScaleNode:g}=a,_=e.add(ie.mul(c)).normalize(),V=d(se.dot(_.negate()).saturate().pow(p).mul(g)),R=f(V.add(u).mul(r));s.directDiffuse.addAssign(R.mul(l.mul(t)))}super.direct({lightDirection:e,lightColor:t,reflectedLight:s},o,i)}}class am extends _r{constructor(e){super(e),this.thicknessColorNode=null,this.thicknessDistortionNode=d(.1),this.thicknessAmbientNode=d(0),this.thicknessAttenuationNode=d(.1),this.thicknessPowerNode=d(2),this.thicknessScaleNode=d(10)}get useSSS(){return this.thicknessColorNode!==null}setupLightingModel(){return new im(this.useClearcoat,this.useSheen,this.useIridescence,this.useSSS)}copy(e){return this.thicknessColorNode=e.thicknessColorNode,this.thicknessDistortionNode=e.thicknessDistortionNode,this.thicknessAmbientNode=e.thicknessAmbientNode,this.thicknessAttenuationNode=e.thicknessAttenuationNode,this.thicknessPowerNode=e.thicknessPowerNode,this.thicknessScaleNode=e.thicknessScaleNode,super.copy(e)}}Re("MeshSSSNodeMaterial",am);const rm=new ui;class cm extends Fe{constructor(e){super(),this.isPointsNodeMaterial=!0,this.lights=!1,this.normals=!1,this.transparent=!0,this.sizeNode=null,this.setDefaultValues(rm),this.setValues(e)}copy(e){return this.sizeNode=e.sizeNode,super.copy(e)}}Re("PointsNodeMaterial",cm);const um=new Uc;class lm extends Fe{constructor(e){super(),this.isSpriteNodeMaterial=!0,this.lights=!1,this.normals=!1,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.setDefaultValues(um),this.setValues(e)}setupPosition({object:e,context:t}){const{positionNode:s,rotationNode:o,scaleNode:i}=this,a=Se;let r=_t.mul(f(s||0)),c=E(is[0].xyz.length(),is[1].xyz.length());i!==null&&(c=c.mul(i));let u=a.xy;e.center&&e.center.isVector2===!0&&(u=u.sub(X(e.center).sub(.5))),u=u.mul(c);const l=d(o||nd),p=u.rotate(l);r=M(r.xy.add(p),r.zw);const g=Ke.mul(r);return t.vertex=a,g}copy(e){return this.positionNode=e.positionNode,this.rotationNode=e.rotationNode,this.scaleNode=e.scaleNode,super.copy(e)}}Re("SpriteNodeMaterial",lm);class dm extends Qn{constructor(){super(),this.shadowNode=d(1).toVar("shadowMask")}direct({shadowMask:e}){this.shadowNode.mulAssign(e)}finish(e){te.a.mulAssign(this.shadowNode.oneMinus()),e.outgoingLight.rgb.assign(te.rgb)}}const hm=new Bc;class pm extends Fe{constructor(e){super(),this.isShadowNodeMaterial=!0,this.lights=!0,this.setDefaultValues(hm),this.setValues(e)}setupLightingModel(){return new dm}}Re("ShadowNodeMaterial",pm);const Ut=x(([n,e,t])=>{const s=d(t).toVar(),o=d(e).toVar(),i=Vt(n).toVar();return be(i,o,s)}),us=x(([n,e])=>{const t=Vt(e).toVar(),s=d(n).toVar();return be(t,s.negate(),s)}),ae=x(([n])=>{const e=d(n).toVar();return h(Ht(e))}),Q=x(([n,e])=>{const t=d(n).toVar();return e.assign(ae(t)),t.sub(d(e))}),Rr=x(([n,e,t,s,o,i])=>{const a=d(i).toVar(),r=d(o).toVar(),c=d(s).toVar(),u=d(t).toVar(),l=d(e).toVar(),p=d(n).toVar(),g=d(re(1,r)).toVar();return re(1,a).mul(p.mul(g).add(l.mul(r))).add(a.mul(u.mul(g).add(c.mul(r))))}),Ar=x(([n,e,t,s,o,i])=>{const a=d(i).toVar(),r=d(o).toVar(),c=f(s).toVar(),u=f(t).toVar(),l=f(e).toVar(),p=f(n).toVar(),g=d(re(1,r)).toVar();return re(1,a).mul(p.mul(g).add(l.mul(r))).add(a.mul(u.mul(g).add(c.mul(r))))}),wr=Ge([Rr,Ar]),Mr=x(([n,e,t,s,o,i,a,r,c,u,l])=>{const p=d(l).toVar(),g=d(u).toVar(),_=d(c).toVar(),V=d(r).toVar(),R=d(a).toVar(),I=d(i).toVar(),C=d(o).toVar(),z=d(s).toVar(),O=d(t).toVar(),B=d(e).toVar(),K=d(n).toVar(),F=d(re(1,_)).toVar(),Y=d(re(1,g)).toVar();return d(re(1,p)).toVar().mul(Y.mul(K.mul(F).add(B.mul(_))).add(g.mul(O.mul(F).add(z.mul(_))))).add(p.mul(Y.mul(C.mul(F).add(I.mul(_))).add(g.mul(R.mul(F).add(V.mul(_))))))}),Cr=x(([n,e,t,s,o,i,a,r,c,u,l])=>{const p=d(l).toVar(),g=d(u).toVar(),_=d(c).toVar(),V=f(r).toVar(),R=f(a).toVar(),I=f(i).toVar(),C=f(o).toVar(),z=f(s).toVar(),O=f(t).toVar(),B=f(e).toVar(),K=f(n).toVar(),F=d(re(1,_)).toVar(),Y=d(re(1,g)).toVar();return d(re(1,p)).toVar().mul(Y.mul(K.mul(F).add(B.mul(_))).add(g.mul(O.mul(F).add(z.mul(_))))).add(p.mul(Y.mul(C.mul(F).add(I.mul(_))).add(g.mul(R.mul(F).add(V.mul(_))))))}),Er=Ge([Mr,Cr]),Lr=x(([n,e,t])=>{const s=d(t).toVar(),o=d(e).toVar(),i=w(n).toVar(),a=w(i.bitAnd(w(7))).toVar(),r=d(Ut(a.lessThan(w(4)),o,s)).toVar(),c=d(U(2,Ut(a.lessThan(w(4)),s,o))).toVar();return us(r,Vt(a.bitAnd(w(1)))).add(us(c,Vt(a.bitAnd(w(2)))))}),Ir=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),a=d(e).toVar(),r=w(n).toVar(),c=w(r.bitAnd(w(15))).toVar(),u=d(Ut(c.lessThan(w(8)),a,i)).toVar(),l=d(Ut(c.lessThan(w(4)),i,Ut(c.equal(w(12)).or(c.equal(w(14))),a,o))).toVar();return us(u,Vt(c.bitAnd(w(1)))).add(us(l,Vt(c.bitAnd(w(2)))))}),me=Ge([Lr,Ir]),Or=x(([n,e,t])=>{const s=d(t).toVar(),o=d(e).toVar(),i=ls(n).toVar();return f(me(i.x,o,s),me(i.y,o,s),me(i.z,o,s))}),br=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),a=d(e).toVar(),r=ls(n).toVar();return f(me(r.x,a,i,o),me(r.y,a,i,o),me(r.z,a,i,o))}),Ue=Ge([Or,br]),zr=x(([n])=>{const e=d(n).toVar();return U(.6616,e)}),Dr=x(([n])=>{const e=d(n).toVar();return U(.982,e)}),Pr=x(([n])=>{const e=f(n).toVar();return U(.6616,e)}),Fr=Ge([zr,Pr]),Ur=x(([n])=>{const e=f(n).toVar();return U(.982,e)}),Br=Ge([Dr,Ur]),Me=x(([n,e])=>{const t=h(e).toVar(),s=w(n).toVar();return s.shiftLeft(t).bitOr(s.shiftRight(h(32).sub(t)))}),kr=x(([n,e,t])=>{n.subAssign(t),n.bitXorAssign(Me(t,h(4))),t.addAssign(e),e.subAssign(n),e.bitXorAssign(Me(n,h(6))),n.addAssign(t),t.subAssign(e),t.bitXorAssign(Me(e,h(8))),e.addAssign(n),n.subAssign(t),n.bitXorAssign(Me(t,h(16))),t.addAssign(e),e.subAssign(n),e.bitXorAssign(Me(n,h(19))),n.addAssign(t),t.subAssign(e),t.bitXorAssign(Me(e,h(4))),e.addAssign(n)}),Yt=x(([n,e,t])=>{const s=w(t).toVar(),o=w(e).toVar(),i=w(n).toVar();return s.bitXorAssign(o),s.subAssign(Me(o,h(14))),i.bitXorAssign(s),i.subAssign(Me(s,h(11))),o.bitXorAssign(i),o.subAssign(Me(i,h(25))),s.bitXorAssign(o),s.subAssign(Me(o,h(16))),i.bitXorAssign(s),i.subAssign(Me(s,h(4))),o.bitXorAssign(i),o.subAssign(Me(i,h(14))),s.bitXorAssign(o),s.subAssign(Me(o,h(24))),s}),ye=x(([n])=>{const e=w(n).toVar();return d(e).div(d(w(h(4294967295))))}),$e=x(([n])=>{const e=d(n).toVar();return e.mul(e.mul(e.mul(e.mul(e.mul(6).sub(15)).add(10))))}),Gr=x(([n])=>{const e=h(n).toVar(),t=w(w(1)).toVar(),s=w(w(h(3735928559)).add(t.shiftLeft(w(2)).add(w(13)))).toVar();return Yt(s.add(w(e)),s,s)}),Wr=x(([n,e])=>{const t=h(e).toVar(),s=h(n).toVar(),o=w(w(2)).toVar(),i=w().toVar(),a=w().toVar(),r=w().toVar();return i.assign(a.assign(r.assign(w(h(3735928559)).add(o.shiftLeft(w(2)).add(w(13)))))),i.addAssign(w(s)),a.addAssign(w(t)),Yt(i,a,r)}),Hr=x(([n,e,t])=>{const s=h(t).toVar(),o=h(e).toVar(),i=h(n).toVar(),a=w(w(3)).toVar(),r=w().toVar(),c=w().toVar(),u=w().toVar();return r.assign(c.assign(u.assign(w(h(3735928559)).add(a.shiftLeft(w(2)).add(w(13)))))),r.addAssign(w(i)),c.addAssign(w(o)),u.addAssign(w(s)),Yt(r,c,u)}),qr=x(([n,e,t,s])=>{const o=h(s).toVar(),i=h(t).toVar(),a=h(e).toVar(),r=h(n).toVar(),c=w(w(4)).toVar(),u=w().toVar(),l=w().toVar(),p=w().toVar();return u.assign(l.assign(p.assign(w(h(3735928559)).add(c.shiftLeft(w(2)).add(w(13)))))),u.addAssign(w(r)),l.addAssign(w(a)),p.addAssign(w(i)),kr(u,l,p),u.addAssign(w(o)),Yt(u,l,p)}),$r=x(([n,e,t,s,o])=>{const i=h(o).toVar(),a=h(s).toVar(),r=h(t).toVar(),c=h(e).toVar(),u=h(n).toVar(),l=w(w(5)).toVar(),p=w().toVar(),g=w().toVar(),_=w().toVar();return p.assign(g.assign(_.assign(w(h(3735928559)).add(l.shiftLeft(w(2)).add(w(13)))))),p.addAssign(w(u)),g.addAssign(w(c)),_.addAssign(w(r)),kr(p,g,_),p.addAssign(w(a)),g.addAssign(w(i)),Yt(p,g,_)}),G=Ge([Gr,Wr,Hr,qr,$r]),Xr=x(([n,e])=>{const t=h(e).toVar(),s=h(n).toVar(),o=w(G(s,t)).toVar(),i=ls().toVar();return i.x.assign(o.bitAnd(h(255))),i.y.assign(o.shiftRight(h(8)).bitAnd(h(255))),i.z.assign(o.shiftRight(h(16)).bitAnd(h(255))),i}),jr=x(([n,e,t])=>{const s=h(t).toVar(),o=h(e).toVar(),i=h(n).toVar(),a=w(G(i,o,s)).toVar(),r=ls().toVar();return r.x.assign(a.bitAnd(h(255))),r.y.assign(a.shiftRight(h(8)).bitAnd(h(255))),r.z.assign(a.shiftRight(h(16)).bitAnd(h(255))),r}),Be=Ge([Xr,jr]),Yr=x(([n])=>{const e=E(n).toVar(),t=h().toVar(),s=h().toVar(),o=d(Q(e.x,t)).toVar(),i=d(Q(e.y,s)).toVar(),a=d($e(o)).toVar(),r=d($e(i)).toVar(),c=d(wr(me(G(t,s),o,i),me(G(t.add(h(1)),s),o.sub(1),i),me(G(t,s.add(h(1))),o,i.sub(1)),me(G(t.add(h(1)),s.add(h(1))),o.sub(1),i.sub(1)),a,r)).toVar();return Fr(c)}),Zr=x(([n])=>{const e=f(n).toVar(),t=h().toVar(),s=h().toVar(),o=h().toVar(),i=d(Q(e.x,t)).toVar(),a=d(Q(e.y,s)).toVar(),r=d(Q(e.z,o)).toVar(),c=d($e(i)).toVar(),u=d($e(a)).toVar(),l=d($e(r)).toVar(),p=d(Er(me(G(t,s,o),i,a,r),me(G(t.add(h(1)),s,o),i.sub(1),a,r),me(G(t,s.add(h(1)),o),i,a.sub(1),r),me(G(t.add(h(1)),s.add(h(1)),o),i.sub(1),a.sub(1),r),me(G(t,s,o.add(h(1))),i,a,r.sub(1)),me(G(t.add(h(1)),s,o.add(h(1))),i.sub(1),a,r.sub(1)),me(G(t,s.add(h(1)),o.add(h(1))),i,a.sub(1),r.sub(1)),me(G(t.add(h(1)),s.add(h(1)),o.add(h(1))),i.sub(1),a.sub(1),r.sub(1)),c,u,l)).toVar();return Br(p)}),mm=Ge([Yr,Zr]),Kr=x(([n])=>{const e=E(n).toVar(),t=h().toVar(),s=h().toVar(),o=d(Q(e.x,t)).toVar(),i=d(Q(e.y,s)).toVar(),a=d($e(o)).toVar(),r=d($e(i)).toVar(),c=f(wr(Ue(Be(t,s),o,i),Ue(Be(t.add(h(1)),s),o.sub(1),i),Ue(Be(t,s.add(h(1))),o,i.sub(1)),Ue(Be(t.add(h(1)),s.add(h(1))),o.sub(1),i.sub(1)),a,r)).toVar();return Fr(c)}),Jr=x(([n])=>{const e=f(n).toVar(),t=h().toVar(),s=h().toVar(),o=h().toVar(),i=d(Q(e.x,t)).toVar(),a=d(Q(e.y,s)).toVar(),r=d(Q(e.z,o)).toVar(),c=d($e(i)).toVar(),u=d($e(a)).toVar(),l=d($e(r)).toVar(),p=f(Er(Ue(Be(t,s,o),i,a,r),Ue(Be(t.add(h(1)),s,o),i.sub(1),a,r),Ue(Be(t,s.add(h(1)),o),i,a.sub(1),r),Ue(Be(t.add(h(1)),s.add(h(1)),o),i.sub(1),a.sub(1),r),Ue(Be(t,s,o.add(h(1))),i,a,r.sub(1)),Ue(Be(t.add(h(1)),s,o.add(h(1))),i.sub(1),a,r.sub(1)),Ue(Be(t,s.add(h(1)),o.add(h(1))),i,a.sub(1),r.sub(1)),Ue(Be(t.add(h(1)),s.add(h(1)),o.add(h(1))),i.sub(1),a.sub(1),r.sub(1)),c,u,l)).toVar();return Br(p)}),gm=Ge([Kr,Jr]),fm=x(([n])=>{const e=d(n).toVar(),t=h(ae(e)).toVar();return ye(G(t))}),Nm=x(([n])=>{const e=E(n).toVar(),t=h(ae(e.x)).toVar(),s=h(ae(e.y)).toVar();return ye(G(t,s))}),ym=x(([n])=>{const e=f(n).toVar(),t=h(ae(e.x)).toVar(),s=h(ae(e.y)).toVar(),o=h(ae(e.z)).toVar();return ye(G(t,s,o))}),xm=x(([n])=>{const e=M(n).toVar(),t=h(ae(e.x)).toVar(),s=h(ae(e.y)).toVar(),o=h(ae(e.z)).toVar(),i=h(ae(e.w)).toVar();return ye(G(t,s,o,i))}),Qr=x(([n])=>{const e=d(n).toVar(),t=h(ae(e)).toVar();return f(ye(G(t,h(0))),ye(G(t,h(1))),ye(G(t,h(2))))}),ec=x(([n])=>{const e=E(n).toVar(),t=h(ae(e.x)).toVar(),s=h(ae(e.y)).toVar();return f(ye(G(t,s,h(0))),ye(G(t,s,h(1))),ye(G(t,s,h(2))))}),tc=x(([n])=>{const e=f(n).toVar(),t=h(ae(e.x)).toVar(),s=h(ae(e.y)).toVar(),o=h(ae(e.z)).toVar();return f(ye(G(t,s,o,h(0))),ye(G(t,s,o,h(1))),ye(G(t,s,o,h(2))))}),sc=x(([n])=>{const e=M(n).toVar(),t=h(ae(e.x)).toVar(),s=h(ae(e.y)).toVar(),o=h(ae(e.z)).toVar(),i=h(ae(e.w)).toVar();return f(ye(G(t,s,o,i,h(0))),ye(G(t,s,o,i,h(1))),ye(G(t,s,o,i,h(2))))}),nc=Ge([Qr,ec,tc,sc]),Ps=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),a=h(e).toVar(),r=f(n).toVar(),c=d(0).toVar(),u=d(1).toVar();return Z({start:h(0),end:a},({i:l})=>{c.addAssign(u.mul(mm(r))),u.mulAssign(o),r.mulAssign(i)}),c}),oc=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),a=h(e).toVar(),r=f(n).toVar(),c=f(0).toVar(),u=d(1).toVar();return Z({start:h(0),end:a},({i:l})=>{c.addAssign(u.mul(gm(r))),u.mulAssign(o),r.mulAssign(i)}),c}),vm=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),a=h(e).toVar(),r=f(n).toVar();return E(Ps(r,a,i,o),Ps(r.add(f(h(19),h(193),h(17))),a,i,o))}),Tm=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),a=h(e).toVar(),r=f(n).toVar(),c=f(oc(r,a,i,o)).toVar(),u=d(Ps(r.add(f(h(19),h(193),h(17))),a,i,o)).toVar();return M(c,u)}),ic=x(([n,e,t,s,o,i,a])=>{const r=h(a).toVar(),c=d(i).toVar(),u=h(o).toVar(),l=h(s).toVar(),p=h(t).toVar(),g=h(e).toVar(),_=E(n).toVar(),V=f(nc(E(g.add(l),p.add(u)))).toVar(),R=E(V.x,V.y).toVar();R.subAssign(.5),R.mulAssign(c),R.addAssign(.5);const I=E(E(d(g),d(p)).add(R)).toVar(),C=E(I.sub(_)).toVar();return P(r.equal(h(2)),()=>ue(C.x).add(ue(C.y))),P(r.equal(h(3)),()=>Pe(ue(C.x),ue(C.y))),qt(C,C)}),ac=x(([n,e,t,s,o,i,a,r,c])=>{const u=h(c).toVar(),l=d(r).toVar(),p=h(a).toVar(),g=h(i).toVar(),_=h(o).toVar(),V=h(s).toVar(),R=h(t).toVar(),I=h(e).toVar(),C=f(n).toVar(),z=f(nc(f(I.add(_),R.add(g),V.add(p)))).toVar();z.subAssign(.5),z.mulAssign(l),z.addAssign(.5);const O=f(f(d(I),d(R),d(V)).add(z)).toVar(),B=f(O.sub(C)).toVar();return P(u.equal(h(2)),()=>ue(B.x).add(ue(B.y).add(ue(B.z)))),P(u.equal(h(3)),()=>Pe(Pe(ue(B.x),ue(B.y)),ue(B.z))),qt(B,B)}),Zt=Ge([ic,ac]),Sm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=E(n).toVar(),a=h().toVar(),r=h().toVar(),c=E(Q(i.x,a),Q(i.y,r)).toVar(),u=d(1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:l})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:p})=>{const g=d(Zt(c,l,p,a,r,o,s)).toVar();u.assign(kt(u,g))})}),P(s.equal(h(0)),()=>{u.assign(wt(u))}),u}),Vm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=E(n).toVar(),a=h().toVar(),r=h().toVar(),c=E(Q(i.x,a),Q(i.y,r)).toVar(),u=E(1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:l})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:p})=>{const g=d(Zt(c,l,p,a,r,o,s)).toVar();P(g.lessThan(u.x),()=>{u.y.assign(u.x),u.x.assign(g)}).elseif(g.lessThan(u.y),()=>{u.y.assign(g)})})}),P(s.equal(h(0)),()=>{u.assign(wt(u))}),u}),_m=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=E(n).toVar(),a=h().toVar(),r=h().toVar(),c=E(Q(i.x,a),Q(i.y,r)).toVar(),u=f(1e6,1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:l})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:p})=>{const g=d(Zt(c,l,p,a,r,o,s)).toVar();P(g.lessThan(u.x),()=>{u.z.assign(u.y),u.y.assign(u.x),u.x.assign(g)}).elseif(g.lessThan(u.y),()=>{u.z.assign(u.y),u.y.assign(g)}).elseif(g.lessThan(u.z),()=>{u.z.assign(g)})})}),P(s.equal(h(0)),()=>{u.assign(wt(u))}),u}),Rm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=f(n).toVar(),a=h().toVar(),r=h().toVar(),c=h().toVar(),u=f(Q(i.x,a),Q(i.y,r),Q(i.z,c)).toVar(),l=d(1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:p})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:g})=>{Z({start:-1,end:h(1),name:"z",condition:"<="},({z:_})=>{const V=d(Zt(u,p,g,_,a,r,c,o,s)).toVar();l.assign(kt(l,V))})})}),P(s.equal(h(0)),()=>{l.assign(wt(l))}),l}),Am=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=f(n).toVar(),a=h().toVar(),r=h().toVar(),c=h().toVar(),u=f(Q(i.x,a),Q(i.y,r),Q(i.z,c)).toVar(),l=E(1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:p})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:g})=>{Z({start:-1,end:h(1),name:"z",condition:"<="},({z:_})=>{const V=d(Zt(u,p,g,_,a,r,c,o,s)).toVar();P(V.lessThan(l.x),()=>{l.y.assign(l.x),l.x.assign(V)}).elseif(V.lessThan(l.y),()=>{l.y.assign(V)})})})}),P(s.equal(h(0)),()=>{l.assign(wt(l))}),l}),wm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=f(n).toVar(),a=h().toVar(),r=h().toVar(),c=h().toVar(),u=f(Q(i.x,a),Q(i.y,r),Q(i.z,c)).toVar(),l=f(1e6,1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:p})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:g})=>{Z({start:-1,end:h(1),name:"z",condition:"<="},({z:_})=>{const V=d(Zt(u,p,g,_,a,r,c,o,s)).toVar();P(V.lessThan(l.x),()=>{l.z.assign(l.y),l.y.assign(l.x),l.x.assign(V)}).elseif(V.lessThan(l.y),()=>{l.z.assign(l.y),l.y.assign(V)}).elseif(V.lessThan(l.z),()=>{l.z.assign(V)})})})}),P(s.equal(h(0)),()=>{l.assign(wt(l))}),l});Ut.setLayout({name:"mx_select",type:"float",inputs:[{name:"b",type:"bool"},{name:"t",type:"float"},{name:"f",type:"float"}]});us.setLayout({name:"mx_negate_if",type:"float",inputs:[{name:"val",type:"float"},{name:"b",type:"bool"}]});ae.setLayout({name:"mx_floor",type:"int",inputs:[{name:"x",type:"float"}]});Rr.setLayout({name:"mx_bilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"}]});Ar.setLayout({name:"mx_bilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"}]});Mr.setLayout({name:"mx_trilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"v4",type:"float"},{name:"v5",type:"float"},{name:"v6",type:"float"},{name:"v7",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]});Cr.setLayout({name:"mx_trilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"v4",type:"vec3"},{name:"v5",type:"vec3"},{name:"v6",type:"vec3"},{name:"v7",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]});Lr.setLayout({name:"mx_gradient_float_0",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"}]});Ir.setLayout({name:"mx_gradient_float_1",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]});Or.setLayout({name:"mx_gradient_vec3_0",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"}]});br.setLayout({name:"mx_gradient_vec3_1",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]});zr.setLayout({name:"mx_gradient_scale2d_0",type:"float",inputs:[{name:"v",type:"float"}]});Dr.setLayout({name:"mx_gradient_scale3d_0",type:"float",inputs:[{name:"v",type:"float"}]});Pr.setLayout({name:"mx_gradient_scale2d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]});Ur.setLayout({name:"mx_gradient_scale3d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]});Me.setLayout({name:"mx_rotl32",type:"uint",inputs:[{name:"x",type:"uint"},{name:"k",type:"int"}]});Yt.setLayout({name:"mx_bjfinal",type:"uint",inputs:[{name:"a",type:"uint"},{name:"b",type:"uint"},{name:"c",type:"uint"}]});ye.setLayout({name:"mx_bits_to_01",type:"float",inputs:[{name:"bits",type:"uint"}]});$e.setLayout({name:"mx_fade",type:"float",inputs:[{name:"t",type:"float"}]});Gr.setLayout({name:"mx_hash_int_0",type:"uint",inputs:[{name:"x",type:"int"}]});Wr.setLayout({name:"mx_hash_int_1",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]});Hr.setLayout({name:"mx_hash_int_2",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]});qr.setLayout({name:"mx_hash_int_3",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"}]});$r.setLayout({name:"mx_hash_int_4",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"},{name:"yy",type:"int"}]});Xr.setLayout({name:"mx_hash_vec3_0",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]});jr.setLayout({name:"mx_hash_vec3_1",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]});Yr.setLayout({name:"mx_perlin_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"}]});Zr.setLayout({name:"mx_perlin_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"}]});Kr.setLayout({name:"mx_perlin_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"}]});Jr.setLayout({name:"mx_perlin_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"}]});fm.setLayout({name:"mx_cell_noise_float_0",type:"float",inputs:[{name:"p",type:"float"}]});Nm.setLayout({name:"mx_cell_noise_float_1",type:"float",inputs:[{name:"p",type:"vec2"}]});ym.setLayout({name:"mx_cell_noise_float_2",type:"float",inputs:[{name:"p",type:"vec3"}]});xm.setLayout({name:"mx_cell_noise_float_3",type:"float",inputs:[{name:"p",type:"vec4"}]});Qr.setLayout({name:"mx_cell_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"float"}]});ec.setLayout({name:"mx_cell_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec2"}]});tc.setLayout({name:"mx_cell_noise_vec3_2",type:"vec3",inputs:[{name:"p",type:"vec3"}]});sc.setLayout({name:"mx_cell_noise_vec3_3",type:"vec3",inputs:[{name:"p",type:"vec4"}]});Ps.setLayout({name:"mx_fractal_noise_float",type:"float",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});oc.setLayout({name:"mx_fractal_noise_vec3",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});vm.setLayout({name:"mx_fractal_noise_vec2",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});Tm.setLayout({name:"mx_fractal_noise_vec4",type:"vec4",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});ic.setLayout({name:"mx_worley_distance_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});ac.setLayout({name:"mx_worley_distance_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"zoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});Sm.setLayout({name:"mx_worley_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});Vm.setLayout({name:"mx_worley_noise_vec2_0",type:"vec2",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});_m.setLayout({name:"mx_worley_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});Rm.setLayout({name:"mx_worley_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});Am.setLayout({name:"mx_worley_noise_vec2_1",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});wm.setLayout({name:"mx_worley_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});const Mm=x(([n])=>{const e=f(n).toVar(),t=d(e.x).toVar(),s=d(e.y).toVar(),o=d(e.z).toVar();P(s.lessThan(1e-4),()=>f(o,o,o)).else(()=>{t.assign(U(6,t.sub(Ht(t))));const i=h(ki(t)).toVar(),a=d(t.sub(d(i))).toVar(),r=d(o.mul(re(1,s))).toVar(),c=d(o.mul(re(1,s.mul(a)))).toVar(),u=d(o.mul(re(1,s.mul(re(1,a))))).toVar();return P(i.equal(h(0)),()=>f(o,u,r)).elseif(i.equal(h(1)),()=>f(c,o,r)).elseif(i.equal(h(2)),()=>f(r,o,u)).elseif(i.equal(h(3)),()=>f(r,c,o)).elseif(i.equal(h(4)),()=>f(u,r,o)),f(o,r,c)})}),Cm=x(([n])=>{const e=f(n).toVar(),t=d(e.x).toVar(),s=d(e.y).toVar(),o=d(e.z).toVar(),i=d(kt(t,kt(s,o))).toVar(),a=d(Pe(t,Pe(s,o))).toVar(),r=d(a.sub(i)).toVar(),c=d().toVar(),u=d().toVar(),l=d().toVar();return l.assign(a),P(a.greaterThan(0),()=>{u.assign(r.div(a))}).else(()=>{u.assign(0)}),P(u.lessThanEqual(0),()=>{c.assign(0)}).else(()=>{P(t.greaterThanEqual(a),()=>{c.assign(s.sub(o).div(r))}).elseif(s.greaterThanEqual(a),()=>{c.assign(De(2,o.sub(t).div(r)))}).else(()=>{c.assign(De(4,t.sub(s).div(r)))}),c.mulAssign(1/6),P(c.lessThan(0),()=>{c.addAssign(1)})}),f(c,u,l)});Mm.setLayout({name:"mx_hsvtorgb",type:"vec3",inputs:[{name:"hsv",type:"vec3"}]});Cm.setLayout({name:"mx_rgbtohsv",type:"vec3",inputs:[{name:"c",type:"vec3"}]});const Em=x(([n])=>{const e=f(n).toVar(),t=xi(zi(e,f(.04045))).toVar(),s=f(e.div(12.92)).toVar(),o=f(Qe(Pe(e.add(f(.055)),f(0)).div(1.055),f(2.4))).toVar();return xe(s,o,t)});Em.setLayout({name:"mx_srgb_texture_to_lin_rec709",type:"vec3",inputs:[{name:"color",type:"vec3"}]});const we={x:0,y:0,gl:new ne,glNormalized:new ne,glScreenSpace:new ne};let ce={color1:{value:"#fdd3e0",type:"color",displayName:"Top Base Color",onChange:(n,{width:e,height:t,pixelRatio:s})=>{ut.uniforms.uColor1.value.setHex(n.value.replace("#","0x"))}},color2:{value:"#d3effd",type:"color",displayName:"Middle Base Color",onChange:(n,{width:e,height:t,pixelRatio:s})=>{ut.uniforms.uColor2.value.setHex(n.value.replace("#","0x"))}},color3:{value:"#0088cc",type:"color",displayName:"Bottom Base Color",onChange:(n,{width:e,height:t,pixelRatio:s})=>{ut.uniforms.uColor3.value.setHex(n.value.replace("#","0x"))}},step1:{value:0,displayName:"Gradient Step 1",params:{min:-.5,max:1,step:.001},onChange:(n,{width:e,height:t,pixelRatio:s})=>{ut.uniforms.uStep1.value=n.value}},step2:{value:.49,displayName:"Gradient Step 2",params:{min:0,max:1,step:.001},onChange:(n,{width:e,height:t,pixelRatio:s})=>{ut.uniforms.uStep2.value=n.value}},step3:{value:.935,displayName:"Gradient Step 3",params:{min:0,max:1.5,step:.001},onChange:(n,{width:e,height:t,pixelRatio:s})=>{ut.uniforms.uStep3.value=n.value}},bigWarpScale:{value:[.8,2],displayName:"Big Warp Scale",onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uBigWarpScale.value.set(n.value[0],n.value[1])}},detailWarpScale:{value:[.5,8],displayName:"Detail Warp Scale",onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uDetailWarpScale.value.set(n.value[0],n.value[1])}},noWarp:{value:!1,displayName:"No Warp",onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uNoWarp.value=n.value}},warpStrength:{value:.5,displayName:"Warp Strength",params:{min:0,max:1,step:.001},onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uWarpStrength.value=n.value}},noiseStrength:{value:.115,displayName:"Noise Strength",params:{min:0,max:1,step:.001},onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uNoiseStrength.value=n.value}},outlineThickness:{value:.35,displayName:"Outline Thickness",params:{min:0,max:1,step:.001},onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uOutlineThickness.value=n.value}},outlineColor:{value:"#ffffff",type:"color",displayName:"Outline Color",onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uOutlineColor.value.setHex(n.value.replace("#","0x"))}},rectangleSize:{value:[.1,.1],displayName:"Rectangle Size",onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uRectangleSize.value.set(n.value[0],n.value[1])}},numberOfRectangles:{value:12,displayName:"Number of Rectangles",params:{min:0,max:100,step:1},onChange:(n,{width:e,height:t,pixelRatio:s})=>{Ve.uNumberOfRectangles.value=n.value}}},lt,Zo=()=>{},vn=!1,ys=!1,Ko=new ne,xs=new ne,ss,ns,Wn,ut,Hn,Fs,Ve={uResolution:{value:new ne},uTime:{value:0},uMouse:{value:new ne},uColor1:{value:new ot().setHex(ce.color1.value.replace("#","0x"))},uColor2:{value:new ot().setHex(ce.color2.value.replace("#","0x"))},uOutlineThickness:{value:ce.outlineThickness.value},uOutlineColor:{value:new ot().setHex(ce.outlineColor.value.replace("#","0x"))},uNoiseStrength:{value:ce.noiseStrength.value},tBackground:{value:new kc},uRectangleSize:{value:new ne().set(ce.rectangleSize.value[0],ce.rectangleSize.value[1])},uWarpStrength:{value:ce.warpStrength.value},uBigWarpScale:{value:new ne().set(ce.bigWarpScale.value[0],ce.bigWarpScale.value[1])},uDetailWarpScale:{value:new ne().set(ce.detailWarpScale.value[0],ce.detailWarpScale.value[1])},uNumberOfRectangles:{value:ce.numberOfRectangles.value},uNoWarp:{value:ce.noWarp.value}};const Lm=n=>{we.x=n.changedTouches?n.changedTouches[0].clientX:n.clientX,we.y=n.changedTouches?n.changedTouches[0].clientY:n.clientY,we.gl.set(we.x-ss/2,-we.y+ns/2),we.glNormalized.set(we.x/ss*2-1,-(we.y/ns)*2+1),we.glScreenSpace.set(we.x/ss,1-we.y/ns)};let Om=({canvas:n,scene:e,width:t,height:s})=>{ss=t,ns=s,n.addEventListener("mousemove",$c(i=>Lm(i),16)),Wn=new Gc(t,s,{minFilter:go,magFilter:go,format:Wc,type:ti,wrapS:fo,wrapT:fo}),ut=new Sn({vertexShader:`

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = vec4(position, 1.);
			}

		`,fragmentShader:qc,uniforms:{uColor1:{value:new ot().setHex(ce.color1.value.replace("#","0x"))},uColor2:{value:new ot().setHex(ce.color2.value.replace("#","0x"))},uColor3:{value:new ot().setHex(ce.color3.value.replace("#","0x"))},uStep1:{value:ce.step1.value},uStep2:{value:ce.step2.value},uStep3:{value:ce.step3.value}}}),lt=new ii(1,1,1,1,1,1e3);let o=new ri;o.setAttribute("position",new _s([-1,3,0,-1,-1,0,3,-1,0],3)),o.setAttribute("uv",new _s([0,2,0,0,2,0],2)),Hn=new Sn({vertexShader:`
			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = vec4(position, 1.);
			}
		`,fragmentShader:Hc,uniforms:Ve}),Fs=new ai(o,Hn),e.add(Fs)},bm=({renderer:n,scene:e,time:t,deltaTime:s})=>{Ve.uTime.value=t,we.glNormalized.equals(Ko)?!vn&!ys?(vn=!0,clearTimeout(Zo),Zo=setTimeout(()=>{ys=!0},400)):ys&&t%1e3===0&&(xs.x=Math.random()*2-1,xs.y=Math.random()*2-1):(Ko.copy(we.glNormalized),xs.copy(we.glNormalized),vn=!1,ys=!1),Ve.uMouse.value.copy(xs),n.setRenderTarget(Wn),Fs.material=ut,n.render(e,lt),Ve.tBackground.value=Wn.texture,Fs.material=Hn,n.setRenderTarget(null),n.render(e,lt)},zm=({width:n,height:e})=>{ss=n,ns=e,Ve.uResolution.value.x=n,Ve.uResolution.value.y=e,lt.left=-n*.5,lt.right=n*.5,lt.top=e*.5,lt.bottom=-e*.5,lt.updateProjectionMatrix()},Dm="three",Pm="./exports",Fm={gui:{output:!0}};export{Fm as buildConfig,Pm as exportDir,Om as init,ce as props,Dm as rendering,zm as resize,bm as update};
