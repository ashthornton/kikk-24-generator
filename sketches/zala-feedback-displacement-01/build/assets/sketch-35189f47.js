import{C as ts,V as we,a as He,b as lt,M as ec,c as Wo,E as $o,d as Xo,L as Un,S as tc,e as sc,I as nc,f as oc,D as fn,g as ic,h as rc,i as ac,F as jo,W as Yo,j as Bn,N as vs,k as cc,l as Ts,m as Zo,n as Ko,o as uc,B as lc,p as dc,q as hc,R as xt,P as pc,T as uo,O as mc,r as gc,s as fc,t as Nc,A as yc,u as xc,H as vc,v as Jo,w as kn,x as Gn,y as Ft,z as Tc,G as Sc,J as Qo,K as Ac,Q as Vc,U as ei,X as _c,Y as ti,Z as Rc,_ as Mc,$ as wc,a0 as Ec,a1 as Cc,a2 as Lc,a3 as Ic,a4 as Oc,a5 as bc,a6 as zc,a7 as Dc,a8 as Pc,a9 as lo,aa as si}from"./three.module-dc7cd118.js";const Fc=`precision highp float;
#define GLSLIFY 1
#define PI 3.14159265359

uniform float uTime;
uniform float uDelta;
uniform vec2 uResolution;

uniform float uSetup;
uniform bool uDebugSimulatorTexture;
uniform float uAnimation;

uniform sampler2D uTexture;
uniform vec3 uColor1;
uniform vec3 uColor2;

uniform float uNoiseSpeed;
uniform float uNoiseScale;
uniform vec2 uNoiseDirection;
uniform float uNoiseAngle;
uniform float uNoiseBias;

varying vec2 vUv;

float map(float value, float min1, float max1, float min2, float max2) {
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float random (in vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

float cnoise(vec3 P){
    vec3 Pi0 = floor(P); 
    vec3 Pi1 = Pi0 + vec3(1.0); 
    Pi0 = mod(Pi0, 289.0);
    Pi1 = mod(Pi1, 289.0);
    vec3 Pf0 = fract(P); 
    vec3 Pf1 = Pf0 - vec3(1.0); 
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = Pi0.zzzz;
    vec4 iz1 = Pi1.zzzz;

    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);

    vec4 gx0 = ixy0 / 7.0;
    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);

    vec4 gx1 = ixy1 / 7.0;
    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);

    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;

    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);

    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 2.2 * n_xyz;
}

void main() {

    if(uSetup == 1.) { 
        gl_FragColor = vec4(mix(uColor1, uColor2, vUv.y), 1.);
        return;
    }

    if(uDebugSimulatorTexture) {
        gl_FragColor = texture2D(uTexture, vUv);
        return;
    }

    vec4 texel = vec4(0.0);
    vec2 offset = vec2(0.0);
    if(uAnimation == 1.0) {
        
        float noise = map(cnoise(vec3(vUv * uNoiseScale, uTime * uNoiseSpeed * 0.01)), -1., 1., -0.8, 1.0);
        offset = vec2(
            noise * uNoiseDirection.x,
            noise * uNoiseDirection.y
        );
        texel = texture2D(uTexture, vUv + offset * 0.001 * uDelta);
    } else {
        
        float bias = random(floor(vUv * uNoiseScale)) > uNoiseBias ? 1.0 : 0.0;

        offset = vec2(cos(uNoiseAngle + PI) * uNoiseDirection.x, sin(uNoiseAngle + PI) * uNoiseDirection.y) * uNoiseSpeed * (1.0 - bias);

        texel = texture2D(uTexture, vUv + offset * uDelta * 0.001);
    }
    

    gl_FragColor = vec4(texel.rgb, 1.);
}`,ho={VERTEX:"vertex",FRAGMENT:"fragment"},$={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},zs=["x","y","z","w"];function ni(n,e=!1){let t="{";n.isNode===!0&&(t+=n.id);for(const{property:s,childNode:o}of Ss(n))t+=","+s.slice(0,-4)+":"+o.getCacheKey(e);return t+="}",t}function*Ss(n,e=!1){for(const t in n){if(t.startsWith("_")===!0)continue;const s=n[t];if(Array.isArray(s)===!0)for(let o=0;o<s.length;o++){const i=s[o];i&&(i.isNode===!0||e&&typeof i.toJSON=="function")&&(yield{property:t,index:o,childNode:i})}else if(s&&s.isNode===!0)yield{property:t,childNode:s};else if(typeof s=="object")for(const o in s){const i=s[o];i&&(i.isNode===!0||e&&typeof i.toJSON=="function")&&(yield{property:t,index:o,childNode:i})}}}function ct(n){if(n==null)return null;const e=typeof n;return n.isNode===!0?"node":e==="number"?"float":e==="boolean"?"bool":e==="string"?"string":e==="function"?"shader":n.isVector2===!0?"vec2":n.isVector3===!0?"vec3":n.isVector4===!0?"vec4":n.isMatrix3===!0?"mat3":n.isMatrix4===!0?"mat4":n.isColor===!0?"color":n instanceof ArrayBuffer?"ArrayBuffer":null}function oi(n,...e){const t=n?n.slice(-4):void 0;return e.length===1&&(t==="vec2"?e=[e[0],e[0]]:t==="vec3"?e=[e[0],e[0],e[0]]:t==="vec4"&&(e=[e[0],e[0],e[0],e[0]])),n==="color"?new ts(...e):t==="vec2"?new we(...e):t==="vec3"?new He(...e):t==="vec4"?new lt(...e):t==="mat3"?new ec(...e):t==="mat4"?new Wo(...e):n==="bool"?e[0]||!1:n==="float"||n==="int"||n==="uint"?e[0]||0:n==="string"?e[0]||"":n==="ArrayBuffer"?ri(e[0]):null}function ii(n){let e="";const t=new Uint8Array(n);for(let s=0;s<t.length;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function ri(n){return Uint8Array.from(atob(n),e=>e.charCodeAt(0)).buffer}const po=new Map;let Uc=0;class L extends $o{constructor(e=null){super(),this.nodeType=e,this.updateType=$.NONE,this.updateBeforeType=$.NONE,this.uuid=Xo.generateUUID(),this.version=0,this._cacheKey=null,this._cacheKeyVersion=0,this.isNode=!0,Object.defineProperty(this,"id",{value:Uc++})}set needsUpdate(e){e===!0&&this.version++}get type(){return this.constructor.type}onUpdate(e,t){return this.updateType=t,this.update=e.bind(this.getSelf()),this}onFrameUpdate(e){return this.onUpdate(e,$.FRAME)}onRenderUpdate(e){return this.onUpdate(e,$.RENDER)}onObjectUpdate(e){return this.onUpdate(e,$.OBJECT)}onReference(e){return this.updateReference=e.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return!1}*getChildren(){for(const{childNode:e}of Ss(this))yield e}dispose(){this.dispatchEvent({type:"dispose"})}traverse(e){e(this);for(const t of this.getChildren())t.traverse(e)}getCacheKey(e=!1){return e=e||this.version!==this._cacheKeyVersion,(e===!0||this._cacheKey===null)&&(this._cacheKey=ni(this,e),this._cacheKeyVersion=this.version),this._cacheKey}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode?t.outputNode.getNodeType(e):this.nodeType}getShared(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}setup(e){const t=e.getNodeProperties(this);for(const s of this.getChildren())t["_node"+s.id]=s;return null}construct(e){return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."),this.setup(e)}increaseUsage(e){const t=e.getDataFromNode(this);return t.usageCount=t.usageCount===void 0?1:t.usageCount+1,t.usageCount}analyze(e){if(this.increaseUsage(e)===1){const s=e.getNodeProperties(this);for(const o of Object.values(s))o&&o.isNode===!0&&o.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&s.isNode===!0)return s.build(e,t)}updateBefore(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const s=this.getShared(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let o=null;const i=e.getBuildStage();if(i==="setup"){this.updateReference(e);const r=e.getNodeProperties(this);if(r.initialized!==!0||e.context.tempRead===!1){const a=e.stack.nodes.length;r.initialized=!0,r.outputNode=this.setup(e),r.outputNode!==null&&e.stack.nodes.length!==a&&(r.outputNode=e.stack);for(const c of Object.values(r))c&&c.isNode===!0&&c.build(e)}}else if(i==="analyze")this.analyze(e);else if(i==="generate")if(this.generate.length===1){const a=this.getNodeType(e),c=e.getDataFromNode(this);o=c.snippet,o===void 0&&(o=this.generate(e)||"",c.snippet=o),o=e.format(o,a,t)}else o=this.generate(e,t)||"";return e.removeChain(this),o}getSerializeChildren(){return Ss(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:o,index:i,childNode:r}of t)i!==void 0?(s[o]===void 0&&(s[o]=Number.isInteger(i)?[]:{}),s[o][i]=r.toJSON(e.meta).uuid):s[o]=r.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(e.inputNodes!==void 0){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const o=[];for(const i of e.inputNodes[s])o.push(t[i]);this[s]=o}else if(typeof e.inputNodes[s]=="object"){const o={};for(const i in e.inputNodes[s]){const r=e.inputNodes[s][i];o[i]=t[r]}this[s]=o}else{const o=e.inputNodes[s];this[s]=t[o]}}}toJSON(e){const{uuid:t,type:s}=this,o=e===void 0||typeof e=="string";o&&(e={textures:{},images:{},nodes:{}});let i=e.nodes[t];i===void 0&&(i={uuid:t,type:s,meta:e,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},o!==!0&&(e.nodes[i.uuid]=i),this.serialize(i),delete i.meta);function r(a){const c=[];for(const u in a){const l=a[u];delete l.metadata,c.push(l)}return c}if(o){const a=r(e.textures),c=r(e.images),u=r(e.nodes);a.length>0&&(i.textures=a),c.length>0&&(i.images=c),u.length>0&&(i.nodes=u)}return i}}function T(n,e){if(typeof e!="function"||!n)throw new Error(`Node class ${n} is not a class`);if(po.has(n)){console.warn(`Redefinition of node class ${n}`);return}po.set(n,e),e.type=n}class j extends L{constructor(e){super(e),this.isTempNode=!0}hasDependencies(e){return e.getDataFromNode(this).usageCount>1}build(e,t){if(e.getBuildStage()==="generate"){const o=e.getVectorType(this.getNodeType(e,t)),i=e.getDataFromNode(this);if(e.context.tempRead!==!1&&i.propertyName!==void 0)return e.format(i.propertyName,o,t);if(e.context.tempWrite!==!1&&o!=="void"&&t!=="void"&&this.hasDependencies(e)){const r=super.build(e,o),a=e.getVarFromNode(this,null,o),c=e.getPropertyName(a);return e.addLineFlowCode(`${c} = ${r}`),i.snippet=r,i.propertyName=c,e.format(i.propertyName,o,t)}}return super.build(e,t)}}T("TempNode",j);class Gt extends L{constructor(e,t){super(),this.node=e,this.indexNode=t,this.isArrayElementNode=!0}getNodeType(e){return this.node.getNodeType(e)}generate(e){const t=this.node.build(e),s=this.indexNode.build(e,"uint");return`${t}[ ${s} ]`}}T("ArrayElementNode",Gt);class Hn extends L{constructor(e,t){super(),this.node=e,this.convertTo=t}getNodeType(e){const t=this.node.getNodeType(e);let s=null;for(const o of this.convertTo.split("|"))(s===null||e.getTypeLength(t)===e.getTypeLength(o))&&(s=o);return s}serialize(e){super.serialize(e),e.convertTo=this.convertTo}deserialize(e){super.deserialize(e),this.convertTo=e.convertTo}generate(e,t){const s=this.node,o=this.getNodeType(e),i=s.build(e,o);return e.format(i,o,t)}}T("ConvertNode",Hn);class ai extends j{constructor(e=[],t=null){super(t),this.nodes=e}getNodeType(e){return this.nodeType!==null?e.getVectorType(this.nodeType):e.getTypeFromLength(this.nodes.reduce((t,s)=>t+e.getTypeLength(s.getNodeType(e)),0))}generate(e,t){const s=this.getNodeType(e),o=this.nodes,i=e.getComponentType(s),r=[];for(const c of o){let u=c.build(e);const l=e.getComponentType(c.getNodeType(e));l!==i&&(u=e.format(u,l,i)),r.push(u)}const a=`${e.getType(s)}( ${r.join(", ")} )`;return e.format(a,s,t)}}T("JoinNode",ai);const Bc=zs.join("");class Nn extends L{constructor(e,t="x"){super(),this.node=e,this.components=t,this.isSplitNode=!0}getVectorLength(){let e=this.components.length;for(const t of this.components)e=Math.max(zs.indexOf(t)+1,e);return e}getComponentType(e){return e.getComponentType(this.node.getNodeType(e))}getNodeType(e){return e.getTypeFromLength(this.components.length,this.getComponentType(e))}generate(e,t){const s=this.node,o=e.getTypeLength(s.getNodeType(e));let i=null;if(o>1){let r=null;this.getVectorLength()>=o&&(r=e.getTypeFromLength(this.getVectorLength(),this.getComponentType(e)));const c=s.build(e,r);this.components.length===o&&this.components===Bc.slice(0,this.components.length)?i=e.format(c,r,t):i=e.format(`${c}.${this.components}`,this.getNodeType(e),t)}else i=s.build(e,t);return i}serialize(e){super.serialize(e),e.components=this.components}deserialize(e){super.deserialize(e),this.components=e.components}}T("SplitNode",Nn);class ci extends j{constructor(e,t,s){super(),this.sourceNode=e,this.components=t,this.targetNode=s}getNodeType(e){return this.sourceNode.getNodeType(e)}generate(e){const{sourceNode:t,components:s,targetNode:o}=this,i=this.getNodeType(e),r=e.getTypeFromLength(s.length),a=o.build(e,r),c=t.build(e,i),u=e.getTypeLength(i),l=[];for(let p=0;p<u;p++){const g=zs[p];g===s[0]?(l.push(a),p+=s.length-1):l.push(c+"."+g)}return`${e.getType(i)}( ${l.join(", ")} )`}}T("SetNode",ci);class Ds extends L{constructor(e,t=null){super(t),this.isInputNode=!0,this.value=e,this.precision=null}getNodeType(){return this.nodeType===null?ct(this.value):this.nodeType}getInputType(e){return this.getNodeType(e)}setPrecision(e){return this.precision=e,this}serialize(e){super.serialize(e),e.value=this.value,this.value&&this.value.toArray&&(e.value=this.value.toArray()),e.valueType=ct(this.value),e.nodeType=this.nodeType,e.valueType==="ArrayBuffer"&&(e.value=ii(e.value)),e.precision=this.precision}deserialize(e){super.deserialize(e),this.nodeType=e.nodeType,this.value=Array.isArray(e.value)?oi(e.valueType,...e.value):e.value,this.precision=e.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(e.value))}generate(){console.warn("Abstract function.")}}T("InputNode",Ds);class Be extends Ds{constructor(e,t=null){super(e,t),this.isConstNode=!0}generateConst(e){return e.generateConst(this.getNodeType(e),this.value)}generate(e,t){const s=this.getNodeType(e);return e.format(this.generateConst(e),s,t)}}T("ConstNode",Be);let Ut=null;const Mt=new Map;function N(n,e){if(Mt.has(n)){console.warn(`Redefinition of node element ${n}`);return}if(typeof e!="function")throw new Error(`Node element ${n} is not a function`);Mt.set(n,e)}const mo=n=>n.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),ui={setup(n,e){const t=e.shift();return n(Us(t),...e)},get(n,e,t){if(typeof e=="string"&&n[e]===void 0){if(n.isStackNode!==!0&&e==="assign")return(...s)=>(Ut.assign(t,...s),t);if(Mt.has(e)){const s=Mt.get(e);return n.isStackNode?(...o)=>t.add(s(...o)):(...o)=>s(t,...o)}else{if(e==="self")return n;if(e.endsWith("Assign")&&Mt.has(e.slice(0,e.length-6))){const s=Mt.get(e.slice(0,e.length-6));return n.isStackNode?(...o)=>t.assign(o[0],s(...o)):(...o)=>t.assign(s(t,...o))}else{if(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0)return e=mo(e),R(new Nn(t,e));if(/^set[XYZWRGBASTPQ]{1,4}$/.test(e)===!0)return e=mo(e.slice(3).toLowerCase()),e=e.split("").sort().join(""),s=>R(new ci(n,e,s));if(e==="width"||e==="height"||e==="depth")return e==="width"?e="x":e==="height"?e="y":e==="depth"&&(e="z"),R(new Nn(n,e));if(/^\d+$/.test(e)===!0)return R(new Gt(t,new Be(Number(e),"uint")))}}}return Reflect.get(n,e,t)},set(n,e,t,s){return typeof e=="string"&&n[e]===void 0&&(/^[xyzwrgbastpq]{1,4}$/.test(e)===!0||e==="width"||e==="height"||e==="depth"||/^\d+$/.test(e)===!0)?(s[e].assign(t),!0):Reflect.set(n,e,t,s)}},Ks=new WeakMap,go=new WeakMap,kc=function(n,e=null){const t=ct(n);if(t==="node"){let s=Ks.get(n);return s===void 0&&(s=new Proxy(n,ui),Ks.set(n,s),Ks.set(s,s)),s}else{if(e===null&&(t==="float"||t==="boolean")||t&&t!=="shader"&&t!=="string")return R(yn(n,e));if(t==="shader")return x(n)}return n},Gc=function(n,e=null){for(const t in n)n[t]=R(n[t],e);return n},Hc=function(n,e=null){const t=n.length;for(let s=0;s<t;s++)n[s]=R(n[s],e);return n},qc=function(n,e=null,t=null,s=null){const o=i=>R(s!==null?Object.assign(i,s):i);return e===null?(...i)=>o(new n(...It(i))):t!==null?(t=R(t),(...i)=>o(new n(e,...It(i),t))):(...i)=>o(new n(e,...It(i)))},Wc=function(n,...e){return R(new n(...It(e)))};class $c extends L{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t}getNodeType(e){const{outputNode:t}=e.getNodeProperties(this);return t?t.getNodeType(e):super.getNodeType(e)}call(e){const{shaderNode:t,inputNodes:s}=this;if(t.layout){let r=go.get(e.constructor);r===void 0&&(r=new WeakMap,go.set(e.constructor,r));let a=r.get(t);return a===void 0&&(a=R(e.buildFunctionNode(t)),r.set(t,a)),e.currentFunctionNode!==null&&e.currentFunctionNode.includes.push(a),R(a.call(s))}const o=t.jsFunc,i=s!==null?o(s,e.stack,e):o(e.stack,e);return R(i)}setup(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);return s===null?this.call(e).build(e,t):super.generate(e,t)}}class Xc extends L{constructor(e){super(),this.jsFunc=e,this.layout=null}get isArrayInput(){return/^\((\s+)?\[/.test(this.jsFunc.toString())}setLayout(e){return this.layout=e,this}call(e=null){return Us(e),R(new $c(this,e))}setup(){return this.call()}}const jc=[!1,!0],Yc=[0,1,2,3],Zc=[-1,-2],li=[.5,1.5,1/3,1e-6,1e6,Math.PI,Math.PI*2,1/Math.PI,2/Math.PI,1/(Math.PI*2),Math.PI/2],qn=new Map;for(const n of jc)qn.set(n,new Be(n));const Wn=new Map;for(const n of Yc)Wn.set(n,new Be(n,"uint"));const $n=new Map([...Wn].map(n=>new Be(n.value,"int")));for(const n of Zc)$n.set(n,new Be(n,"int"));const Ps=new Map([...$n].map(n=>new Be(n.value)));for(const n of li)Ps.set(n,new Be(n));for(const n of li)Ps.set(-n,new Be(-n));const Fs={bool:qn,uint:Wn,ints:$n,float:Ps},fo=new Map([...qn,...Ps]),yn=(n,e)=>fo.has(n)?fo.get(n):n.isNode===!0?n:new Be(n,e),Kc=n=>{try{return n.getNodeType()}catch{return}},q=function(n,e=null){return(...t)=>{if((t.length===0||!["bool","float","int","uint"].includes(n)&&t.every(o=>typeof o!="object"))&&(t=[oi(n,...t)]),t.length===1&&e!==null&&e.has(t[0]))return R(e.get(t[0]));if(t.length===1){const o=yn(t[0],n);return Kc(o)===n?R(o):R(new Hn(o,n))}const s=t.map(o=>yn(o));return R(new ai(s,n))}},No=n=>n&&n.value,Jc=n=>n!=null?n.nodeType||n.convertTo||(typeof n=="string"?n:null):null;function Qt(n){return new Proxy(new Xc(n),ui)}const R=(n,e=null)=>kc(n,e),Us=(n,e=null)=>new Gc(n,e),It=(n,e=null)=>new Hc(n,e),y=(...n)=>new qc(...n),S=(...n)=>new Wc(...n),x=n=>{const e=new Qt(n),t=(...s)=>{let o;return Us(s),s[0]&&s[0].isNode?o=[...s]:o=s[0],e.call(o)};return t.shaderNode=e,t.setLayout=s=>(e.setLayout(s),t),t};T("ShaderNode",Qt);const yo=n=>{Ut=n},Qc=()=>Ut,P=(...n)=>Ut.if(...n);function eu(n){return Ut&&Ut.add(n),n}N("append",eu);const tu=new q("color"),d=new q("float",Fs.float),h=new q("int",Fs.ints),M=new q("uint",Fs.uint),vt=new q("bool",Fs.bool),C=new q("vec2"),yt=new q("ivec2"),su=new q("uvec2"),nu=new q("bvec2"),f=new q("vec3"),ou=new q("ivec3"),cs=new q("uvec3"),di=new q("bvec3"),w=new q("vec4"),iu=new q("ivec4"),ru=new q("uvec4"),au=new q("bvec4"),Xn=new q("mat2"),cu=new q("imat2"),uu=new q("umat2"),lu=new q("bmat2"),$e=new q("mat3"),du=new q("imat3"),hu=new q("umat3"),pu=new q("bmat3"),Ot=new q("mat4"),mu=new q("imat4"),gu=new q("umat4"),fu=new q("bmat4"),Nu=(n="")=>R(new Be(n,"string")),yu=n=>R(new Be(n,"ArrayBuffer"));N("color",tu);N("float",d);N("int",h);N("uint",M);N("bool",vt);N("vec2",C);N("ivec2",yt);N("uvec2",su);N("bvec2",nu);N("vec3",f);N("ivec3",ou);N("uvec3",cs);N("bvec3",di);N("vec4",w);N("ivec4",iu);N("uvec4",ru);N("bvec4",au);N("mat2",Xn);N("imat2",cu);N("umat2",uu);N("bmat2",lu);N("mat3",$e);N("imat3",du);N("umat3",hu);N("bmat3",pu);N("mat4",Ot);N("imat4",mu);N("umat4",gu);N("bmat4",fu);N("string",Nu);N("arrayBuffer",yu);const xu=y(Gt),vu=(n,e)=>R(new Hn(R(n),e));N("element",xu);N("convert",vu);class hi extends j{constructor(e,t){super(),this.targetNode=e,this.sourceNode=t}hasDependencies(){return!1}getNodeType(e,t){return t!=="void"?this.targetNode.getNodeType(e):"void"}needsSplitAssign(e){const{targetNode:t}=this;if(e.isAvailable("swizzleAssign")===!1&&t.isSplitNode&&t.components.length>1){const s=e.getTypeLength(t.node.getNodeType(e));return zs.join("").slice(0,s)!==t.components}return!1}generate(e,t){const{targetNode:s,sourceNode:o}=this,i=this.needsSplitAssign(e),r=s.getNodeType(e),a=s.context({assign:!0}).build(e),c=o.build(e,r),u=o.getNodeType(e),l=e.getDataFromNode(this);let p;if(l.initialized===!0)t!=="void"&&(p=a);else if(i){const g=e.getVarFromNode(this,null,r),V=e.getPropertyName(g);e.addLineFlowCode(`${V} = ${c}`);const A=s.node.context({assign:!0}).build(e);for(let _=0;_<s.components.length;_++){const I=s.components[_];e.addLineFlowCode(`${A}.${I} = ${V}[ ${_} ]`)}t!=="void"&&(p=a)}else p=`${a} = ${c}`,(t==="void"||u==="void")&&(e.addLineFlowCode(p),t!=="void"&&(p=a));return l.initialized=!0,e.format(p,r,t)}}const Tu=y(hi);T("AssignNode",hi);N("assign",Tu);class pi extends L{constructor(e,t=null){super(),this.node=e,this.name=t,this.isVaryingNode=!0}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{name:t,node:s}=this,o=this.getNodeType(e),i=e.getVaryingFromNode(this,t,o);i.needsInterpolation||(i.needsInterpolation=e.shaderStage==="fragment");const r=e.getPropertyName(i,ho.VERTEX);return e.flowNodeFromShaderStage(ho.VERTEX,s,o,r),e.getPropertyName(i)}}const ne=y(pi);N("varying",ne);T("VaryingNode",pi);class Bs extends L{constructor(e,t=null){super(t),this._attributeName=e}isGlobal(){return!0}getHash(e){return this.getAttributeName(e)}getNodeType(e){let t=super.getNodeType(e);if(t===null){const s=this.getAttributeName(e);if(e.hasGeometryAttribute(s)){const o=e.geometry.getAttribute(s);t=e.getTypeFromAttribute(o)}else t="float"}return t}setAttributeName(e){return this._attributeName=e,this}getAttributeName(){return this._attributeName}generate(e){const t=this.getAttributeName(e),s=this.getNodeType(e);if(e.hasGeometryAttribute(t)===!0){const i=e.geometry.getAttribute(t),r=e.getTypeFromAttribute(i),a=e.getAttribute(t,r);return e.shaderStage==="vertex"?e.format(a.name,r,s):ne(this).build(e,s)}else return console.warn(`AttributeNode: Vertex attribute "${t}" not found on geometry.`),e.generateConst(s)}}const ve=(n,e)=>R(new Bs(n,e));T("AttributeNode",Bs);class mi extends L{constructor(e,t){super(),this.isBypassNode=!0,this.outputNode=e,this.callNode=t}getNodeType(e){return this.outputNode.getNodeType(e)}generate(e){const t=this.callNode.build(e,"void");return t!==""&&e.addLineFlowCode(t),this.outputNode.build(e)}}const gi=y(mi);N("bypass",gi);T("BypassNode",mi);let Su=0;class Au{constructor(){this.id=Su++,this.nodesData=new WeakMap}getNodeData(e){return this.nodesData.get(e)}setNodeData(e,t){this.nodesData.set(e,t)}}class fi extends L{constructor(e,t=new Au){super(),this.isCacheNode=!0,this.node=e,this.cache=t}getNodeType(e){return this.node.getNodeType(e)}build(e,...t){const s=e.getCache(),o=this.cache||e.globalCache;e.setCache(o);const i=this.node.build(e,...t);return e.setCache(s),i}}const As=y(fi),Vu=n=>As(n,null);N("cache",As);N("globalCache",Vu);T("CacheNode",fi);class jn extends L{constructor(e,t={}){super(),this.isContextNode=!0,this.node=e,this.context=t}getNodeType(e){return this.node.getNodeType(e)}setup(e){const t=e.getContext();e.setContext({...e.context,...this.context});const s=this.node.build(e);return e.setContext(t),s}generate(e,t){const s=e.getContext();e.setContext({...e.context,...this.context});const o=this.node.build(e,t);return e.setContext(s),o}}const nt=y(jn),_u=(n,e)=>nt(n,{label:e});N("context",nt);N("label",_u);T("ContextNode",jn);class Qe extends L{constructor(e){super("uint"),this.scope=e,this.isInstanceIndexNode=!0}generate(e){const t=this.getNodeType(e),s=this.scope;let o;if(s===Qe.VERTEX)o=e.getVertexIndex();else if(s===Qe.INSTANCE)o=e.getInstanceIndex();else throw new Error("THREE.IndexNode: Unknown scope: "+s);let i;return e.shaderStage==="vertex"||e.shaderStage==="compute"?i=o:i=ne(this).build(e,t),i}}Qe.VERTEX="vertex";Qe.INSTANCE="instance";const Ru=S(Qe,Qe.VERTEX),Ni=S(Qe,Qe.INSTANCE);T("IndexNode",Qe);class Yn{start(){}finish(){}direct(){}indirectDiffuse(){}indirectSpecular(){}ambientOcclusion(){}}class yi extends L{constructor(e,t=null){super(),this.node=e,this.name=t,this.isVarNode=!0}isGlobal(){return!0}getHash(e){return this.name||super.getHash(e)}getNodeType(e){return this.node.getNodeType(e)}generate(e){const{node:t,name:s}=this,o=e.getVarFromNode(this,s,e.getVectorType(this.getNodeType(e))),i=e.getPropertyName(o),r=t.build(e,o.type);return e.addLineFlowCode(`${i} = ${r}`),i}}const ss=y(yi);N("temp",ss);N("toVar",(...n)=>ss(...n).append());T("VarNode",yi);class H extends L{constructor(e,t=null,s=!1){super(e),this.name=t,this.varying=s,this.isPropertyNode=!0}getHash(e){return this.name||super.getHash(e)}isGlobal(){return!0}generate(e){let t;return this.varying===!0?(t=e.getVaryingFromNode(this,this.name),t.needsInterpolation=!0):t=e.getVarFromNode(this,this.name),e.getPropertyName(t)}}const ge=(n,e)=>R(new H(n,e)),Ye=(n,e)=>R(new H(n,e,!0)),te=S(H,"vec4","DiffuseColor"),ut=S(H,"float","Roughness"),Vs=S(H,"float","Metalness"),xn=S(H,"float","Clearcoat"),_s=S(H,"float","ClearcoatRoughness"),wt=S(H,"vec3","Sheen"),Zn=S(H,"float","SheenRoughness"),Kn=S(H,"float","Iridescence"),xi=S(H,"float","IridescenceIOR"),vi=S(H,"float","IridescenceThickness"),vn=S(H,"float","AlphaT"),ft=S(H,"float","Anisotropy"),fs=S(H,"vec3","AnisotropyT"),bt=S(H,"vec3","AnisotropyB"),Ge=S(H,"color","SpecularColor"),Rs=S(H,"float","SpecularF90"),Tn=S(H,"float","Shininess"),Mu=S(H,"vec4","Output"),zt=S(H,"float","dashSize"),Ms=S(H,"float","gapSize");S(H,"float","pointWidth");const Ns=S(H,"float","IOR"),Sn=S(H,"float","Transmission"),Ti=S(H,"float","Thickness"),Si=S(H,"float","AttenuationDistance"),Ai=S(H,"color","AttenuationColor");T("PropertyNode",H);class wu extends H{constructor(e,t=null){super(e,t),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}T("ParameterNode",wu);class Jn extends L{constructor(e="",t=[],s=""){super("code"),this.isCodeNode=!0,this.code=e,this.language=s,this.includes=t}isGlobal(){return!0}setIncludes(e){return this.includes=e,this}getIncludes(){return this.includes}generate(e){const t=this.getIncludes(e);for(const o of t)o.build(e);const s=e.getCodeFromNode(this,this.getNodeType(e));return s.code=this.code,s.code}serialize(e){super.serialize(e),e.code=this.code,e.language=this.language}deserialize(e){super.deserialize(e),this.code=e.code,this.language=e.language}}y(Jn);T("CodeNode",Jn);class Eu extends Jn{constructor(e="",t=[],s=""){super(e,t,s),this.keywords={}}getNodeType(e){return this.getNodeFunction(e).type}getInputs(e){return this.getNodeFunction(e).inputs}getNodeFunction(e){const t=e.getDataFromNode(this);let s=t.nodeFunction;return s===void 0&&(s=e.parser.parseFunction(this.code),t.nodeFunction=s),s}generate(e,t){super.generate(e);const s=this.getNodeFunction(e),o=s.name,i=s.type,r=e.getCodeFromNode(this,i);o!==""&&(r.name=o);const a=e.getPropertyName(r);let c=this.getNodeFunction(e).getCode(a);const u=this.keywords,l=Object.keys(u);if(l.length>0)for(const p of l){const g=new RegExp(`\\b${p}\\b`,"g"),V=u[p].build(e,"property");c=c.replace(g,V)}return r.code=c+`
`,t==="property"?a:e.format(`${a}()`,i,t)}}T("FunctionNode",Eu);class Qn extends L{constructor(e,t=!1){super("string"),this.name=e,this.version=0,this.shared=t,this.isUniformGroup=!0}set needsUpdate(e){e===!0&&this.version++}}const Cu=n=>new Qn(n),Vi=n=>new Qn(n,!0);Vi("frame");Vi("render");const Lu=Cu("object");T("UniformGroupNode",Qn);class At extends Ds{constructor(e,t=null){super(e,t),this.isUniformNode=!0,this.groupNode=Lu}setGroup(e){return this.groupNode=e,this}getGroup(){return this.groupNode}getUniformHash(e){return this.getHash(e)}onUpdate(e,t){const s=this.getSelf();return e=e.bind(s),super.onUpdate(o=>{const i=e(o,s);i!==void 0&&(this.value=i)},t)}generate(e,t){const s=this.getNodeType(e),o=this.getUniformHash(e);let i=e.getNodeFromHash(o);i===void 0&&(e.setHashNode(this,o),i=this);const r=i.getInputType(e),a=e.getUniformFromNode(i,r,e.shaderStage,e.context.label),c=e.getPropertyName(a);return e.context.label!==void 0&&delete e.context.label,e.format(c,s,t)}}const X=(n,e)=>{const t=Jc(e||n),s=n&&n.isNode===!0?n.node&&n.node.value||n.value:n;return R(new At(s,t))};T("UniformNode",At);class _i extends Bs{constructor(e=0){super(null,"vec2"),this.isUVNode=!0,this.index=e}getAttributeName(){const e=this.index;return"uv"+(e>0?e:"")}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}const tt=(...n)=>R(new _i(...n));T("UVNode",_i);class Ri extends L{constructor(e,t=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=e,this.levelNode=t}generate(e,t){const s=this.textureNode.build(e,"property"),o=this.levelNode.build(e,"int");return e.format(`${e.getMethod("textureDimensions")}( ${s}, ${o} )`,this.getNodeType(e),t)}}const eo=y(Ri);N("textureSize",eo);T("TextureSizeNode",Ri);class ee extends j{constructor(e,t,s,...o){if(super(),this.op=e,o.length>0){let i=s;for(let r=0;r<o.length;r++)i=new ee(e,i,o[r]);s=i}this.aNode=t,this.bNode=s}getNodeType(e,t){const s=this.op,o=this.aNode,i=this.bNode,r=o.getNodeType(e),a=typeof i<"u"?i.getNodeType(e):null;if(r==="void"||a==="void")return"void";if(s==="%")return r;if(s==="~"||s==="&"||s==="|"||s==="^"||s===">>"||s==="<<")return e.getIntegerType(r);if(s==="!"||s==="=="||s==="&&"||s==="||"||s==="^^")return"bool";if(s==="<"||s===">"||s==="<="||s===">="){const c=t?e.getTypeLength(t):Math.max(e.getTypeLength(r),e.getTypeLength(a));return c>1?`bvec${c}`:"bool"}else return r==="float"&&e.isMatrix(a)?a:e.isMatrix(r)&&e.isVector(a)?e.getVectorFromMatrix(r):e.isVector(r)&&e.isMatrix(a)?e.getVectorFromMatrix(a):e.getTypeLength(a)>e.getTypeLength(r)?a:r}generate(e,t){const s=this.op,o=this.aNode,i=this.bNode,r=this.getNodeType(e,t);let a=null,c=null;r!=="void"?(a=o.getNodeType(e),c=typeof i<"u"?i.getNodeType(e):null,s==="<"||s===">"||s==="<="||s===">="||s==="=="?e.isVector(a)?c=a:a=c="float":s===">>"||s==="<<"?(a=r,c=e.changeComponentType(c,"uint")):e.isMatrix(a)&&e.isVector(c)?c=e.getVectorFromMatrix(a):e.isVector(a)&&e.isMatrix(c)?a=e.getVectorFromMatrix(c):a=c=r):a=c=r;const u=o.build(e,a),l=typeof i<"u"?i.build(e,c):null,p=e.getTypeLength(t),g=e.getFunctionOperator(s);if(t!=="void")return s==="<"&&p>1?e.format(`${e.getMethod("lessThan")}( ${u}, ${l} )`,r,t):s==="<="&&p>1?e.format(`${e.getMethod("lessThanEqual")}( ${u}, ${l} )`,r,t):s===">"&&p>1?e.format(`${e.getMethod("greaterThan")}( ${u}, ${l} )`,r,t):s===">="&&p>1?e.format(`${e.getMethod("greaterThanEqual")}( ${u}, ${l} )`,r,t):s==="!"||s==="~"?e.format(`(${s}${u})`,a,t):g?e.format(`${g}( ${u}, ${l} )`,r,t):e.format(`( ${u} ${s} ${l} )`,r,t);if(a!=="void")return g?e.format(`${g}( ${u}, ${l} )`,r,t):e.format(`${u} ${s} ${l}`,r,t)}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}const ze=y(ee,"+"),re=y(ee,"-"),U=y(ee,"*"),dt=y(ee,"/"),Iu=y(ee,"%"),Ou=y(ee,"=="),bu=y(ee,"!="),zu=y(ee,"<"),Mi=y(ee,">"),Du=y(ee,"<="),Pu=y(ee,">="),Fu=y(ee,"&&"),Uu=y(ee,"||"),Bu=y(ee,"!"),ku=y(ee,"^^"),Gu=y(ee,"&"),Hu=y(ee,"~"),qu=y(ee,"|"),Wu=y(ee,"^"),$u=y(ee,"<<"),Xu=y(ee,">>");N("add",ze);N("sub",re);N("mul",U);N("div",dt);N("remainder",Iu);N("equal",Ou);N("notEqual",bu);N("lessThan",zu);N("greaterThan",Mi);N("lessThanEqual",Du);N("greaterThanEqual",Pu);N("and",Fu);N("or",Uu);N("not",Bu);N("xor",ku);N("bitAnd",Gu);N("bitNot",Hu);N("bitOr",qu);N("bitXor",Wu);N("shiftLeft",$u);N("shiftRight",Xu);T("OperatorNode",ee);class m extends j{constructor(e,t,s=null,o=null){super(),this.method=e,this.aNode=t,this.bNode=s,this.cNode=o}getInputType(e){const t=this.aNode.getNodeType(e),s=this.bNode?this.bNode.getNodeType(e):null,o=this.cNode?this.cNode.getNodeType(e):null,i=e.isMatrix(t)?0:e.getTypeLength(t),r=e.isMatrix(s)?0:e.getTypeLength(s),a=e.isMatrix(o)?0:e.getTypeLength(o);return i>r&&i>a?t:r>a?s:a>i?o:t}getNodeType(e){const t=this.method;return t===m.LENGTH||t===m.DISTANCE||t===m.DOT?"float":t===m.CROSS?"vec3":t===m.ALL?"bool":t===m.EQUALS?e.changeComponentType(this.aNode.getNodeType(e),"bool"):t===m.MOD?this.aNode.getNodeType(e):this.getInputType(e)}generate(e,t){const s=this.method,o=this.getNodeType(e),i=this.getInputType(e),r=this.aNode,a=this.bNode,c=this.cNode,u=e.renderer.isWebGLRenderer===!0;if(s===m.TRANSFORM_DIRECTION){let l=r,p=a;e.isMatrix(l.getNodeType(e))?p=w(f(p),0):l=w(f(l),0);const g=U(l,p).xyz;return Se(g).build(e,t)}else{if(s===m.NEGATE)return e.format("( - "+r.build(e,i)+" )",o,t);if(s===m.ONE_MINUS)return re(1,r).build(e,t);if(s===m.RECIPROCAL)return dt(1,r).build(e,t);if(s===m.DIFFERENCE)return ae(re(r,a)).build(e,t);{const l=[];return s===m.CROSS||s===m.MOD?l.push(r.build(e,o),a.build(e,o)):s===m.STEP?l.push(r.build(e,e.getTypeLength(r.getNodeType(e))===1?"float":i),a.build(e,i)):u&&(s===m.MIN||s===m.MAX)||s===m.MOD?l.push(r.build(e,i),a.build(e,e.getTypeLength(a.getNodeType(e))===1?"float":i)):s===m.REFRACT?l.push(r.build(e,i),a.build(e,i),c.build(e,"float")):s===m.MIX?l.push(r.build(e,i),a.build(e,i),c.build(e,e.getTypeLength(c.getNodeType(e))===1?"float":i)):(l.push(r.build(e,i)),a!==null&&l.push(a.build(e,i)),c!==null&&l.push(c.build(e,i))),e.format(`${e.getMethod(s,o)}( ${l.join(", ")} )`,o,t)}}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}m.ALL="all";m.ANY="any";m.EQUALS="equals";m.RADIANS="radians";m.DEGREES="degrees";m.EXP="exp";m.EXP2="exp2";m.LOG="log";m.LOG2="log2";m.SQRT="sqrt";m.INVERSE_SQRT="inversesqrt";m.FLOOR="floor";m.CEIL="ceil";m.NORMALIZE="normalize";m.FRACT="fract";m.SIN="sin";m.COS="cos";m.TAN="tan";m.ASIN="asin";m.ACOS="acos";m.ATAN="atan";m.ABS="abs";m.SIGN="sign";m.LENGTH="length";m.NEGATE="negate";m.ONE_MINUS="oneMinus";m.DFDX="dFdx";m.DFDY="dFdy";m.ROUND="round";m.RECIPROCAL="reciprocal";m.TRUNC="trunc";m.FWIDTH="fwidth";m.BITCAST="bitcast";m.ATAN2="atan2";m.MIN="min";m.MAX="max";m.MOD="mod";m.STEP="step";m.REFLECT="reflect";m.DISTANCE="distance";m.DIFFERENCE="difference";m.DOT="dot";m.CROSS="cross";m.POW="pow";m.TRANSFORM_DIRECTION="transformDirection";m.MIX="mix";m.CLAMP="clamp";m.REFRACT="refract";m.SMOOTHSTEP="smoothstep";m.FACEFORWARD="faceforward";const wi=d(1e-6);d(1e6);const xo=d(Math.PI);d(Math.PI*2);const Ei=y(m,m.ALL),ju=y(m,m.ANY),Yu=y(m,m.EQUALS),Zu=y(m,m.RADIANS),Ku=y(m,m.DEGREES),Ci=y(m,m.EXP),An=y(m,m.EXP2),Li=y(m,m.LOG),ks=y(m,m.LOG2),Vt=y(m,m.SQRT),Ju=y(m,m.INVERSE_SQRT),Ht=y(m,m.FLOOR),Ii=y(m,m.CEIL),Se=y(m,m.NORMALIZE),Gs=y(m,m.FRACT),st=y(m,m.SIN),rt=y(m,m.COS),Qu=y(m,m.TAN),el=y(m,m.ASIN),tl=y(m,m.ACOS),sl=y(m,m.ATAN),ae=y(m,m.ABS),to=y(m,m.SIGN),es=y(m,m.LENGTH),nl=y(m,m.NEGATE),ol=y(m,m.ONE_MINUS),il=y(m,m.DFDX),rl=y(m,m.DFDY),al=y(m,m.ROUND),cl=y(m,m.RECIPROCAL),Oi=y(m,m.TRUNC),ul=y(m,m.FWIDTH);y(m,m.BITCAST);const ll=y(m,m.ATAN2),Bt=y(m,m.MIN),De=y(m,m.MAX),dl=y(m,m.MOD),hl=y(m,m.STEP),pl=y(m,m.REFLECT),ml=y(m,m.DISTANCE),gl=y(m,m.DIFFERENCE),qt=y(m,m.DOT),bi=y(m,m.CROSS),Je=y(m,m.POW),zi=y(m,m.POW,2),fl=y(m,m.POW,3),Nl=y(m,m.POW,4),yl=y(m,m.TRANSFORM_DIRECTION),xl=n=>U(to(n),Je(ae(n),1/3)),vl=n=>qt(n,n),ye=y(m,m.MIX),kt=(n,e=0,t=1)=>R(new m(m.CLAMP,R(n),R(e),R(t))),Tl=n=>kt(n),Di=y(m,m.REFRACT),ot=y(m,m.SMOOTHSTEP),Sl=y(m,m.FACEFORWARD),Al=(n,e,t)=>ye(e,t,n),Vl=(n,e,t)=>ot(e,t,n);N("all",Ei);N("any",ju);N("equals",Yu);N("radians",Zu);N("degrees",Ku);N("exp",Ci);N("exp2",An);N("log",Li);N("log2",ks);N("sqrt",Vt);N("inverseSqrt",Ju);N("floor",Ht);N("ceil",Ii);N("normalize",Se);N("fract",Gs);N("sin",st);N("cos",rt);N("tan",Qu);N("asin",el);N("acos",tl);N("atan",sl);N("abs",ae);N("sign",to);N("length",es);N("lengthSq",vl);N("negate",nl);N("oneMinus",ol);N("dFdx",il);N("dFdy",rl);N("round",al);N("reciprocal",cl);N("trunc",Oi);N("fwidth",ul);N("atan2",ll);N("min",Bt);N("max",De);N("mod",dl);N("step",hl);N("reflect",pl);N("distance",ml);N("dot",qt);N("cross",bi);N("pow",Je);N("pow2",zi);N("pow3",fl);N("pow4",Nl);N("transformDirection",yl);N("mix",Al);N("clamp",kt);N("refract",Di);N("smoothstep",Vl);N("faceForward",Sl);N("difference",gl);N("saturate",Tl);N("cbrt",xl);T("MathNode",m);const _l=x(n=>{const{value:e}=n,{rgb:t}=e,s=t.mul(.9478672986).add(.0521327014).pow(2.4),o=t.mul(.0773993808),i=t.lessThanEqual(.04045),r=ye(s,o,i);return w(r,e.a)}),Rl=x(n=>{const{value:e}=n,{rgb:t}=e,s=t.pow(.41666).mul(1.055).sub(.055),o=t.mul(12.92),i=t.lessThanEqual(.0031308),r=ye(s,o,i);return w(r,e.a)}),vo=n=>{let e=null;return n===Un?e="Linear":n===tc&&(e="sRGB"),e},Pi=(n,e)=>vo(n)+"To"+vo(e);class Ce extends j{constructor(e,t){super("vec4"),this.method=e,this.node=t}setup(){const{method:e,node:t}=this;return e===Ce.LINEAR_TO_LINEAR?t:Ml[e]({value:t})}}Ce.LINEAR_TO_LINEAR="LinearToLinear";Ce.LINEAR_TO_sRGB="LinearTosRGB";Ce.sRGB_TO_LINEAR="sRGBToLinear";const Ml={[Ce.LINEAR_TO_sRGB]:Rl,[Ce.sRGB_TO_LINEAR]:_l},wl=(n,e)=>R(new Ce(Pi(Un,e),R(n))),Fi=(n,e)=>R(new Ce(Pi(e,Un),R(n))),El=y(Ce,Ce.LINEAR_TO_sRGB),Cl=y(Ce,Ce.sRGB_TO_LINEAR);N("linearTosRGB",El);N("sRGBToLinear",Cl);N("linearToColorSpace",wl);N("colorSpaceToLinear",Fi);T("ColorSpaceNode",Ce);class Ui extends L{constructor(e="",t="void"){super(t),this.snippet=e}generate(e,t){const s=this.getNodeType(e),o=this.snippet;if(s==="void")e.addLineFlowCode(o);else return e.format(`( ${o} )`,s,t)}}const Hs=y(Ui);T("ExpressionNode",Ui);class Bi extends At{constructor(e){super(0),this.textureNode=e,this.updateType=$.FRAME}get texture(){return this.textureNode.value}update(){const e=this.texture,t=e.images,s=t&&t.length>0?t[0]&&t[0].image||t[0]:e.image;if(s&&s.width!==void 0){const{width:o,height:i}=s;this.value=Math.log2(Math.max(o,i))}}}const Ll=y(Bi);T("MaxMipLevelNode",Bi);class Wt extends At{constructor(e,t=null,s=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=s,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=$.NONE,this.referenceNode=null,this._value=e,this.setUpdateMatrix(t===null)}set value(e){this.referenceNode?this.referenceNode.value=e:this._value=e}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return this.value.isDepthTexture===!0?"float":"vec4"}getInputType(){return"texture"}getDefaultUV(){return tt(this.value.channel)}updateReference(){return this.value}getTransformedUV(e){const t=this.value;return X(t.matrix).mul(f(e,1)).xy}setUpdateMatrix(e){return this.updateMatrix=e,this.updateType=e?$.FRAME:$.NONE,this}setupUV(e,t){const s=this.value;return e.isFlipY()&&(s.isRenderTargetTexture===!0||s.isFramebufferTexture===!0||s.isDepthTexture===!0)&&(t=t.setY(t.y.oneMinus())),t}setup(e){const t=e.getNodeProperties(this);let s=this.uvNode;(s===null||e.context.forceUVContext===!0)&&e.context.getUV&&(s=e.context.getUV(this)),s||(s=this.getDefaultUV()),this.updateMatrix===!0&&(s=this.getTransformedUV(s)),s=this.setupUV(e,s);let o=this.levelNode;o===null&&e.context.getTextureLevel&&(o=e.context.getTextureLevel(this)),t.uvNode=s,t.levelNode=o,t.compareNode=this.compareNode,t.gradNode=this.gradNode,t.depthNode=this.depthNode}generateUV(e,t){return t.build(e,this.sampler===!0?"vec2":"ivec2")}generateSnippet(e,t,s,o,i,r,a){const c=this.value;let u;return o?u=e.generateTextureLevel(c,t,s,o,i):a?u=e.generateTextureGrad(c,t,s,a,i):r?u=e.generateTextureCompare(c,t,s,r,i):this.sampler===!1?u=e.generateTextureLoad(c,t,s,i):u=e.generateTexture(c,t,s,i),u}generate(e,t){const s=e.getNodeProperties(this),o=this.value;if(!o||o.isTexture!==!0)throw new Error("TextureNode: Need a three.js texture.");const i=super.generate(e,"property");if(t==="sampler")return i+"_sampler";if(e.isReference(t))return i;{const r=e.getDataFromNode(this);let a=r.propertyName;if(a===void 0){const{uvNode:l,levelNode:p,compareNode:g,depthNode:V,gradNode:A}=s,_=this.generateUV(e,l),I=p?p.build(e,"float"):null,E=V?V.build(e,"int"):null,z=g?g.build(e,"float"):null,O=A?[A[0].build(e,"vec2"),A[1].build(e,"vec2")]:null,B=e.getVarFromNode(this);a=e.getPropertyName(B);const K=this.generateSnippet(e,i,_,I,E,z,O);e.addLineFlowCode(`${a} = ${K}`),e.context.tempWrite!==!1&&(r.snippet=K,r.propertyName=a)}let c=a;const u=this.getNodeType(e);return e.needsColorSpaceToLinear(o)&&(c=Fi(Hs(c,u),o.colorSpace).setup(e).build(e,u)),e.format(c,u,t)}}setSampler(e){return this.sampler=e,this}getSampler(){return this.sampler}uv(e){const t=this.clone();return t.uvNode=e,t.referenceNode=this,R(t)}blur(e){const t=this.clone();return t.levelNode=e.mul(Ll(t)),t.referenceNode=this,R(t)}level(e){const t=this.clone();return t.levelNode=e,t.referenceNode=this,t}size(e){return eo(this,e)}compare(e){const t=this.clone();return t.compareNode=R(e),t.referenceNode=this,R(t)}grad(e,t){const s=this.clone();return s.gradNode=[R(e),R(t)],s.referenceNode=this,R(s)}depth(e){const t=this.clone();return t.depthNode=R(e),t.referenceNode=this,R(t)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value]}update(){const e=this.value;e.matrixAutoUpdate===!0&&e.updateMatrix()}clone(){const e=new this.constructor(this.value,this.uvNode,this.levelNode);return e.sampler=this.sampler,e}}const be=y(Wt),Nt=(...n)=>be(...n).setSampler(!1);N("texture",be);T("TextureNode",Wt);class qs extends At{constructor(e,t,s=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferCount=s}getInputType(){return"buffer"}}const so=(n,e,t)=>R(new qs(n,e,t));T("BufferNode",qs);class Il extends Gt{constructor(e,t){super(e,t),this.isArrayBufferElementNode=!0}getNodeType(e){return this.node.getElementType(e)}generate(e){const t=super.generate(e),s=this.getNodeType();return e.format(t,"vec4",s)}}class ki extends qs{constructor(e,t=null){super(null,"vec4"),this.array=e,this.elementType=t,this._elementType=null,this._elementLength=0,this.updateType=$.RENDER,this.isArrayBufferNode=!0}getElementType(){return this.elementType||this._elementType}getElementLength(){return this._elementLength}update(){const{array:e,value:t}=this,s=this.getElementLength(),o=this.getElementType();if(s===1)for(let i=0;i<e.length;i++){const r=i*4;t[r]=e[i]}else if(o==="color")for(let i=0;i<e.length;i++){const r=i*4,a=e[i];t[r]=a.r,t[r+1]=a.g,t[r+2]=a.b||0}else for(let i=0;i<e.length;i++){const r=i*4,a=e[i];t[r]=a.x,t[r+1]=a.y,t[r+2]=a.z||0,t[r+3]=a.w||0}}setup(e){const t=this.array.length;return this._elementType=this.elementType===null?ct(this.array[0]):this.elementType,this._elementLength=e.getTypeLength(this._elementType),this.value=new Float32Array(t*4),this.bufferCount=t,super.setup(e)}element(e){return R(new Il(this,R(e)))}}const Vn=(n,e)=>R(new ki(n,e));T("UniformsNode",ki);class Ol extends Gt{constructor(e,t){super(e,t),this.referenceNode=e,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(e){const t=super.generate(e),s=this.referenceNode.getNodeType(),o=this.getNodeType();return e.format(t,s,o)}}class $t extends L{constructor(e,t,s=null,o=null){super(),this.property=e,this.uniformType=t,this.object=s,this.count=o,this.properties=e.split("."),this.reference=null,this.node=null,this.updateType=$.OBJECT}element(e){return R(new Ol(this,R(e)))}setNodeType(e){let t=null;this.count!==null?t=so(null,e,this.count):Array.isArray(this.getValueFromReference())?t=Vn(null,e):e==="texture"?t=be(null):t=X(null,e),this.node=t}getNodeType(e){return this.node.getNodeType(e)}getValueFromReference(e=this.reference){const{properties:t}=this;let s=e[t[0]];for(let o=1;o<t.length;o++)s=s[t[o]];return s}updateReference(e){return this.reference=this.object!==null?this.object:e.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const e=this.getValueFromReference();Array.isArray(e)?this.node.array=e:this.node.value=e}}const Xe=(n,e,t)=>R(new $t(n,e,t)),bl=(n,e,t,s)=>R(new $t(n,e,s,t));T("ReferenceNode",$t);class Gi extends $t{constructor(e,t,s=null){super(e,t,s),this.material=s}updateReference(e){return this.reference=this.material!==null?this.material:e.material,this.reference}}const Hi=(n,e,t)=>R(new Gi(n,e,t));T("MaterialReferenceNode",Gi);class b extends L{constructor(e=b.VIEW_MATRIX,t=null){super(),this.scope=e,this.object3d=t,this.updateType=$.OBJECT,this._uniformNode=new At(null)}getNodeType(){const e=this.scope;if(e===b.WORLD_MATRIX||e===b.VIEW_MATRIX)return"mat4";if(e===b.NORMAL_MATRIX)return"mat3";if(e===b.POSITION||e===b.VIEW_POSITION||e===b.DIRECTION||e===b.SCALE)return"vec3"}update(e){const t=this.object3d,s=this._uniformNode,o=this.scope;if(o===b.VIEW_MATRIX)s.value=t.modelViewMatrix;else if(o===b.NORMAL_MATRIX)s.value=t.normalMatrix;else if(o===b.WORLD_MATRIX)s.value=t.matrixWorld;else if(o===b.POSITION)s.value=s.value||new He,s.value.setFromMatrixPosition(t.matrixWorld);else if(o===b.SCALE)s.value=s.value||new He,s.value.setFromMatrixScale(t.matrixWorld);else if(o===b.DIRECTION)s.value=s.value||new He,t.getWorldDirection(s.value);else if(o===b.VIEW_POSITION){const i=e.camera;s.value=s.value||new He,s.value.setFromMatrixPosition(t.matrixWorld),s.value.applyMatrix4(i.matrixWorldInverse)}}generate(e){const t=this.scope;return t===b.WORLD_MATRIX||t===b.VIEW_MATRIX?this._uniformNode.nodeType="mat4":t===b.NORMAL_MATRIX?this._uniformNode.nodeType="mat3":(t===b.POSITION||t===b.VIEW_POSITION||t===b.DIRECTION||t===b.SCALE)&&(this._uniformNode.nodeType="vec3"),this._uniformNode.build(e)}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}b.VIEW_MATRIX="viewMatrix";b.NORMAL_MATRIX="normalMatrix";b.WORLD_MATRIX="worldMatrix";b.POSITION="position";b.SCALE="scale";b.VIEW_POSITION="viewPosition";b.DIRECTION="direction";y(b,b.DIRECTION);y(b,b.VIEW_MATRIX);y(b,b.NORMAL_MATRIX);y(b,b.WORLD_MATRIX);const _n=y(b,b.POSITION);y(b,b.SCALE);const qi=y(b,b.VIEW_POSITION);T("Object3DNode",b);class D extends b{constructor(e=D.POSITION){super(e),this.updateType=$.RENDER}getNodeType(e){const t=this.scope;return t===D.PROJECTION_MATRIX||t===D.PROJECTION_MATRIX_INVERSE?"mat4":t===D.NEAR||t===D.FAR||t===D.LOG_DEPTH?"float":super.getNodeType(e)}update(e){const t=e.camera,s=this._uniformNode,o=this.scope;o===D.VIEW_MATRIX?s.value=t.matrixWorldInverse:o===D.PROJECTION_MATRIX?s.value=t.projectionMatrix:o===D.PROJECTION_MATRIX_INVERSE?s.value=t.projectionMatrixInverse:o===D.NEAR?s.value=t.near:o===D.FAR?s.value=t.far:o===D.LOG_DEPTH?s.value=2/(Math.log(t.far+1)/Math.LN2):(this.object3d=t,super.update(e))}generate(e){const t=this.scope;return t===D.PROJECTION_MATRIX||t===D.PROJECTION_MATRIX_INVERSE?this._uniformNode.nodeType="mat4":(t===D.NEAR||t===D.FAR||t===D.LOG_DEPTH)&&(this._uniformNode.nodeType="float"),super.generate(e)}}D.PROJECTION_MATRIX="projectionMatrix";D.PROJECTION_MATRIX_INVERSE="projectionMatrixInverse";D.NEAR="near";D.FAR="far";D.LOG_DEPTH="logDepth";const Ze=S(D,D.PROJECTION_MATRIX);S(D,D.PROJECTION_MATRIX_INVERSE);const Js=S(D,D.NEAR),Qs=S(D,D.FAR),zl=S(D,D.LOG_DEPTH),it=S(D,D.VIEW_MATRIX);S(D,D.NORMAL_MATRIX);S(D,D.WORLD_MATRIX);const Dl=S(D,D.POSITION);T("CameraNode",D);class xe extends b{constructor(e=xe.VIEW_MATRIX){super(e)}update(e){this.object3d=e.object,super.update(e)}}S(xe,xe.DIRECTION);const Tt=S(xe,xe.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix"),Wi=S(xe,xe.NORMAL_MATRIX),ns=S(xe,xe.WORLD_MATRIX);S(xe,xe.POSITION);S(xe,xe.SCALE);S(xe,xe.VIEW_POSITION);T("ModelNode",xe);class ue extends L{constructor(e=ue.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`normal-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===ue.GEOMETRY)e.hasGeometryAttribute("normal")===!1?s=f(0,1,0):s=ve("normal","vec3");else if(t===ue.LOCAL)s=ne(ws);else if(t===ue.VIEW){const o=Wi.mul(je);s=Se(ne(o))}else if(t===ue.WORLD){const o=ht.transformDirection(it);s=Se(ne(o))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}ue.GEOMETRY="geometry";ue.LOCAL="local";ue.VIEW="view";ue.WORLD="world";const ws=S(ue,ue.GEOMETRY),je=S(ue,ue.LOCAL).temp("Normal"),ht=S(ue,ue.VIEW),$i=S(ue,ue.WORLD),oe=ge("vec3","TransformedNormalView"),Xi=oe.transformDirection(it).normalize(),Et=ge("vec3","TransformedClearcoatNormalView");T("NormalNode",ue);const To=new Map;class v extends L{constructor(e){super(),this.scope=e}getCache(e,t){let s=To.get(e);return s===void 0&&(s=Hi(e,t),To.set(e,s)),s}getFloat(e){return this.getCache(e,"float")}getColor(e){return this.getCache(e,"color")}getTexture(e){return this.getCache(e==="map"?"map":e+"Map","texture")}setup(e){const t=e.context.material,s=this.scope;let o=null;if(s===v.COLOR){const i=this.getColor(s);t.map&&t.map.isTexture===!0?o=i.mul(this.getTexture("map")):o=i}else if(s===v.OPACITY){const i=this.getFloat(s);t.alphaMap&&t.alphaMap.isTexture===!0?o=i.mul(this.getTexture("alpha")):o=i}else if(s===v.SPECULAR_STRENGTH)t.specularMap&&t.specularMap.isTexture===!0?o=this.getTexture("specular").r:o=d(1);else if(s===v.SPECULAR_INTENSITY){const i=this.getFloat(s);t.specularMap?o=i.mul(this.getTexture(s).a):o=i}else if(s===v.SPECULAR_COLOR){const i=this.getColor(s);t.specularColorMap&&t.specularColorMap.isTexture===!0?o=i.mul(this.getTexture(s).rgb):o=i}else if(s===v.ROUGHNESS){const i=this.getFloat(s);t.roughnessMap&&t.roughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).g):o=i}else if(s===v.METALNESS){const i=this.getFloat(s);t.metalnessMap&&t.metalnessMap.isTexture===!0?o=i.mul(this.getTexture(s).b):o=i}else if(s===v.EMISSIVE){const i=this.getColor(s);t.emissiveMap&&t.emissiveMap.isTexture===!0?o=i.mul(this.getTexture(s)):o=i}else if(s===v.NORMAL)t.normalMap?o=this.getTexture("normal").normalMap(this.getCache("normalScale","vec2")):t.bumpMap?o=this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")):o=ht;else if(s===v.CLEARCOAT){const i=this.getFloat(s);t.clearcoatMap&&t.clearcoatMap.isTexture===!0?o=i.mul(this.getTexture(s).r):o=i}else if(s===v.CLEARCOAT_ROUGHNESS){const i=this.getFloat(s);t.clearcoatRoughnessMap&&t.clearcoatRoughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).r):o=i}else if(s===v.CLEARCOAT_NORMAL)t.clearcoatNormalMap?o=this.getTexture(s).normalMap(this.getCache(s+"Scale","vec2")):o=ht;else if(s===v.SHEEN){const i=this.getColor("sheenColor").mul(this.getFloat("sheen"));t.sheenColorMap&&t.sheenColorMap.isTexture===!0?o=i.mul(this.getTexture("sheenColor").rgb):o=i}else if(s===v.SHEEN_ROUGHNESS){const i=this.getFloat(s);t.sheenRoughnessMap&&t.sheenRoughnessMap.isTexture===!0?o=i.mul(this.getTexture(s).a):o=i,o=o.clamp(.07,1)}else if(s===v.ANISOTROPY)if(t.anisotropyMap&&t.anisotropyMap.isTexture===!0){const i=this.getTexture(s);o=Xn(Zt.x,Zt.y,Zt.y.negate(),Zt.x).mul(i.rg.mul(2).sub(C(1)).normalize().mul(i.b))}else o=Zt;else if(s===v.IRIDESCENCE_THICKNESS){const i=Xe("1","float",t.iridescenceThicknessRange);if(t.iridescenceThicknessMap){const r=Xe("0","float",t.iridescenceThicknessRange);o=i.sub(r).mul(this.getTexture(s).g).add(r)}else o=i}else if(s===v.TRANSMISSION){const i=this.getFloat(s);t.transmissionMap?o=i.mul(this.getTexture(s).r):o=i}else if(s===v.THICKNESS){const i=this.getFloat(s);t.thicknessMap?o=i.mul(this.getTexture(s).g):o=i}else if(s===v.IOR)o=this.getFloat(s);else{const i=this.getNodeType(e);o=this.getCache(s,i)}return o}}v.ALPHA_TEST="alphaTest";v.COLOR="color";v.OPACITY="opacity";v.SHININESS="shininess";v.SPECULAR="specular";v.SPECULAR_STRENGTH="specularStrength";v.SPECULAR_INTENSITY="specularIntensity";v.SPECULAR_COLOR="specularColor";v.REFLECTIVITY="reflectivity";v.ROUGHNESS="roughness";v.METALNESS="metalness";v.NORMAL="normal";v.CLEARCOAT="clearcoat";v.CLEARCOAT_ROUGHNESS="clearcoatRoughness";v.CLEARCOAT_NORMAL="clearcoatNormal";v.EMISSIVE="emissive";v.ROTATION="rotation";v.SHEEN="sheen";v.SHEEN_ROUGHNESS="sheenRoughness";v.ANISOTROPY="anisotropy";v.IRIDESCENCE="iridescence";v.IRIDESCENCE_IOR="iridescenceIOR";v.IRIDESCENCE_THICKNESS="iridescenceThickness";v.IOR="ior";v.TRANSMISSION="transmission";v.THICKNESS="thickness";v.ATTENUATION_DISTANCE="attenuationDistance";v.ATTENUATION_COLOR="attenuationColor";v.LINE_SCALE="scale";v.LINE_DASH_SIZE="dashSize";v.LINE_GAP_SIZE="gapSize";v.LINE_WIDTH="linewidth";v.LINE_DASH_OFFSET="dashOffset";v.POINT_WIDTH="pointWidth";const Pl=S(v,v.ALPHA_TEST),os=S(v,v.COLOR),Fl=S(v,v.SHININESS),Ul=S(v,v.EMISSIVE),ji=S(v,v.OPACITY),Bl=S(v,v.SPECULAR),So=S(v,v.SPECULAR_INTENSITY),kl=S(v,v.SPECULAR_COLOR),Gl=S(v,v.SPECULAR_STRENGTH);S(v,v.REFLECTIVITY);const Hl=S(v,v.ROUGHNESS),ql=S(v,v.METALNESS),Wl=S(v,v.NORMAL),$l=S(v,v.CLEARCOAT),Xl=S(v,v.CLEARCOAT_ROUGHNESS),jl=S(v,v.CLEARCOAT_NORMAL),Yl=S(v,v.ROTATION),Zl=S(v,v.SHEEN),Kl=S(v,v.SHEEN_ROUGHNESS),Jl=S(v,v.ANISOTROPY),Ql=S(v,v.IRIDESCENCE),ed=S(v,v.IRIDESCENCE_IOR),td=S(v,v.IRIDESCENCE_THICKNESS),sd=S(v,v.TRANSMISSION),nd=S(v,v.THICKNESS),od=S(v,v.IOR),id=S(v,v.ATTENUATION_DISTANCE),rd=S(v,v.ATTENUATION_COLOR),Rn=S(v,v.LINE_SCALE),Yi=S(v,v.LINE_DASH_SIZE),Zi=S(v,v.LINE_GAP_SIZE),en=S(v,v.LINE_WIDTH),Ao=S(v,v.LINE_DASH_OFFSET),ad=S(v,v.POINT_WIDTH),Zt=X(new we).onReference(function(n){return n.material}).onRenderUpdate(function({material:n}){this.value.set(n.anisotropy*Math.cos(n.anisotropyRotation),n.anisotropy*Math.sin(n.anisotropyRotation))});T("MaterialNode",v);class W extends L{constructor(e=W.LOCAL){super("vec3"),this.scope=e}isGlobal(){return!0}getHash(){return`position-${this.scope}`}generate(e){const t=this.scope;let s=null;if(t===W.GEOMETRY)s=ve("position","vec3");else if(t===W.LOCAL)s=ne(Ve);else if(t===W.WORLD){const o=ns.mul(Te);s=ne(o)}else if(t===W.VIEW){const o=Tt.mul(Te);s=ne(o)}else if(t===W.VIEW_DIRECTION){const o=Ie.negate();s=Se(ne(o))}else if(t===W.WORLD_DIRECTION){const o=Te.transformDirection(ns);s=Se(ne(o))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}W.GEOMETRY="geometry";W.LOCAL="local";W.WORLD="world";W.WORLD_DIRECTION="worldDirection";W.VIEW="view";W.VIEW_DIRECTION="viewDirection";const Ve=S(W,W.GEOMETRY),Te=S(W,W.LOCAL).temp("Position"),Mn=S(W,W.WORLD),cd=S(W,W.WORLD_DIRECTION),Ie=S(W,W.VIEW),se=S(W,W.VIEW_DIRECTION);T("PositionNode",W);class Ki extends j{constructor(e=null){super("vec4"),this.positionNode=e}setup(e){if(e.shaderStage==="fragment")return ne(e.context.mvp);const t=this.positionNode||Te;return Ze.mul(Tt).mul(t)}}const Vo=y(Ki);T("ModelViewProjectionNode",Ki);class Ji extends Ds{constructor(e,t=null,s=0,o=0){super(e,t),this.isBufferNode=!0,this.bufferType=t,this.bufferStride=s,this.bufferOffset=o,this.usage=sc,this.instanced=!1,this.attribute=null,e&&e.isBufferAttribute===!0&&(this.attribute=e,this.usage=e.usage,this.instanced=e.isInstancedBufferAttribute)}getNodeType(e){return this.bufferType===null&&(this.bufferType=e.getTypeFromAttribute(this.attribute)),this.bufferType}setup(e){if(this.attribute!==null)return;const t=this.getNodeType(e),s=this.value,o=e.getTypeLength(t),i=this.bufferStride||o,r=this.bufferOffset,a=s.isInterleavedBuffer===!0?s:new nc(s,i),c=new oc(a,o,r);a.setUsage(this.usage),this.attribute=c,this.attribute.isInstancedBufferAttribute=this.instanced}generate(e){const t=this.getNodeType(e),s=e.getBufferAttributeFromNode(this,t),o=e.getPropertyName(s);let i=null;return e.shaderStage==="vertex"||e.shaderStage==="compute"?(this.name=o,i=o):i=ne(this).build(e,t),i}getInputType(){return"bufferAttribute"}setUsage(e){return this.usage=e,this}setInstanced(e){return this.instanced=e,this}}const Ws=(n,e,t,s)=>R(new Ji(n,e,t,s)),ud=(n,e,t,s)=>Ws(n,e,t,s).setUsage(fn),_o=(n,e,t,s)=>Ws(n,e,t,s).setInstanced(!0),Ro=(n,e,t,s)=>ud(n,e,t,s).setInstanced(!0);N("toAttribute",n=>Ws(n.value));T("BufferAttributeNode",Ji);class Qi extends L{constructor(e){super("void"),this.instanceMesh=e,this.instanceMatrixNode=null,this.instanceColorNode=null}setup(){let e=this.instanceMatrixNode;const t=this.instanceMesh;if(e===null){const c=t.instanceMatrix,u=new ic(c.array,16,1),l=c.usage===fn?Ro:_o,p=[l(u,"vec4",16,0),l(u,"vec4",16,4),l(u,"vec4",16,8),l(u,"vec4",16,12)];e=Ot(...p),this.instanceMatrixNode=e}const s=t.instanceColor;if(s&&this.instanceColorNode===null){const c=new rc(s.array,3),u=s.usage===fn?Ro:_o;this.instanceColorNode=f(u(c,"vec3",3,0))}const o=e.mul(Te).xyz,i=$e(e[0].xyz,e[1].xyz,e[2].xyz),r=je.div(f(i[0].dot(i[0]),i[1].dot(i[1]),i[2].dot(i[2]))),a=i.mul(r).xyz;Te.assign(o),je.assign(a),this.instanceColorNode!==null&&Ye("vec3","vInstanceColor").assign(this.instanceColorNode)}}const ld=y(Qi);T("InstanceNode",Qi);class ce extends L{constructor(e=ce.LOCAL){super(),this.scope=e}getHash(){return`tangent-${this.scope}`}getNodeType(){return this.scope===ce.GEOMETRY?"vec4":"vec3"}generate(e){const t=this.scope;let s=null;if(t===ce.GEOMETRY)s=ve("tangent","vec4"),e.geometry.hasAttribute("tangent")===!1&&e.geometry.computeTangents();else if(t===ce.LOCAL)s=ne(Es.xyz);else if(t===ce.VIEW){const o=Tt.mul(w($s,0)).xyz;s=Se(ne(o))}else if(t===ce.WORLD){const o=Xs.transformDirection(it);s=Se(ne(o))}return s.build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}ce.GEOMETRY="geometry";ce.LOCAL="local";ce.VIEW="view";ce.WORLD="world";const Es=S(ce,ce.GEOMETRY),$s=S(ce,ce.LOCAL),Xs=S(ce,ce.VIEW),dd=S(ce,ce.WORLD),er=ss(Xs,"TransformedTangentView");Se(er.transformDirection(it));T("TangentNode",ce);class tr extends L{constructor(e){super("void"),this.batchMesh=e,this.instanceColorNode=null,this.batchingIdNode=null}setup(e){this.batchingIdNode===null&&(this.batchingIdNode=ve("batchId"));const t=this.batchMesh._matricesTexture,s=eo(Nt(t),0),o=d(h(this.batchingIdNode)).mul(4).toVar(),i=h(o.mod(s)),r=h(o).div(h(s)),a=Ot(Nt(t,yt(i,r)),Nt(t,yt(i.add(1),r)),Nt(t,yt(i.add(2),r)),Nt(t,yt(i.add(3),r))),c=$e(a[0].xyz,a[1].xyz,a[2].xyz);Te.assign(a.mul(Te));const u=je.div(f(c[0].dot(c[0]),c[1].dot(c[1]),c[2].dot(c[2]))),l=c.mul(u).xyz;je.assign(l),e.hasGeometryAttribute("tangent")&&$s.mulAssign(c)}}const hd=y(tr);T("batch",tr);class sr extends L{constructor(e,t=!1){super("void"),this.skinnedMesh=e,this.useReference=t,this.updateType=$.OBJECT,this.skinIndexNode=ve("skinIndex","uvec4"),this.skinWeightNode=ve("skinWeight","vec4");let s,o,i;t?(s=Xe("bindMatrix","mat4"),o=Xe("bindMatrixInverse","mat4"),i=bl("skeleton.boneMatrices","mat4",e.skeleton.bones.length)):(s=X(e.bindMatrix,"mat4"),o=X(e.bindMatrixInverse,"mat4"),i=so(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)),this.bindMatrixNode=s,this.bindMatrixInverseNode=o,this.boneMatricesNode=i}setup(e){const{skinIndexNode:t,skinWeightNode:s,bindMatrixNode:o,bindMatrixInverseNode:i,boneMatricesNode:r}=this,a=r.element(t.x),c=r.element(t.y),u=r.element(t.z),l=r.element(t.w),p=o.mul(Te),g=ze(a.mul(s.x).mul(p),c.mul(s.y).mul(p),u.mul(s.z).mul(p),l.mul(s.w).mul(p)),V=i.mul(g).xyz;let A=ze(s.x.mul(a),s.y.mul(c),s.z.mul(u),s.w.mul(l));A=i.mul(A).mul(o);const _=A.transformDirection(je).xyz;Te.assign(V),je.assign(_),e.hasGeometryAttribute("tangent")&&$s.assign(_)}generate(e,t){if(t!=="void")return Te.build(e,t)}update(e){(this.useReference?e.object:this.skinnedMesh).skeleton.update()}}const pd=n=>R(new sr(n,!0));T("SkinningNode",sr);class nr extends L{constructor(e=[]){super(),this.params=e}getVarName(e){return String.fromCharCode("i".charCodeAt()+e)}getProperties(e){const t=e.getNodeProperties(this);if(t.stackNode!==void 0)return t;const s={};for(let o=0,i=this.params.length-1;o<i;o++){const r=this.params[o],a=r.isNode!==!0&&r.name||this.getVarName(o),c=r.isNode!==!0&&r.type||"int";s[a]=Hs(a,c)}return t.returnsNode=this.params[this.params.length-1](s,e.addStack(),e),t.stackNode=e.removeStack(),t}getNodeType(e){const{returnsNode:t}=this.getProperties(e);return t?t.getNodeType(e):"void"}setup(e){this.getProperties(e)}generate(e){const t=this.getProperties(e),s={tempWrite:!1},o=this.params,i=t.stackNode;for(let c=0,u=o.length-1;c<u;c++){const l=o[c];let p=null,g=null,V=null,A=null,_=null,I=null;l.isNode?(A="int",V=this.getVarName(c),p="0",g=l.build(e,A),_="<"):(A=l.type||"int",V=l.name||this.getVarName(c),p=l.start,g=l.end,_=l.condition,I=l.update,typeof p=="number"?p=p.toString():p&&p.isNode&&(p=p.build(e,A)),typeof g=="number"?g=g.toString():g&&g.isNode&&(g=g.build(e,A)),p!==void 0&&g===void 0?(p=p+" - 1",g="0",_=">="):g!==void 0&&p===void 0&&(p="0",_="<"),_===void 0&&(Number(p)>Number(g)?_=">=":_="<"));const E={start:p,end:g,condition:_},z=E.start,O=E.end;let B="",K="",F="";I||(A==="int"||A==="uint"?_.includes("<")?I="++":I="--":_.includes("<")?I="+= 1.":I="-= 1."),B+=e.getVar(A,V)+" = "+z,K+=V+" "+_+" "+O,F+=V+" "+I;const Y=`for ( ${B}; ${K}; ${F} )`;e.addFlowCode((c===0?`
`:"")+e.tab+Y+` {

`).addFlowTab()}const r=nt(i,s).build(e,"void"),a=t.returnsNode?t.returnsNode.build(e):"";e.removeFlowTab().addFlowCode(`
`+e.tab+r);for(let c=0,u=this.params.length-1;c<u;c++)e.addFlowCode((c===0?"":e.tab)+`}

`).removeFlowTab();return e.addFlowTab(),a}}const Z=(...n)=>R(new nr(It(n,"int"))).append(),md=()=>Hs("break").append();N("loop",(n,...e)=>gi(n,Z(...e)));T("LoopNode",nr);const tn=new WeakMap,Le=new lt,Mo=x(({bufferMap:n,influence:e,stride:t,width:s,depth:o,offset:i})=>{const r=h(Ru).mul(t).add(i),a=r.div(s),c=r.sub(a.mul(s));return Nt(n,yt(c,a)).depth(o).mul(e)});function gd(n){const e=n.morphAttributes.position!==void 0,t=n.morphAttributes.normal!==void 0,s=n.morphAttributes.color!==void 0,o=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,i=o!==void 0?o.length:0;let r=tn.get(n);if(r===void 0||r.count!==i){let E=function(){_.dispose(),tn.delete(n),n.removeEventListener("dispose",E)};r!==void 0&&r.texture.dispose();const a=n.morphAttributes.position||[],c=n.morphAttributes.normal||[],u=n.morphAttributes.color||[];let l=0;e===!0&&(l=1),t===!0&&(l=2),s===!0&&(l=3);let p=n.attributes.position.count*l,g=1;const V=4096;p>V&&(g=Math.ceil(p/V),p=V);const A=new Float32Array(p*g*4*i),_=new ac(A,p,g,i);_.type=jo,_.needsUpdate=!0;const I=l*4;for(let z=0;z<i;z++){const O=a[z],B=c[z],K=u[z],F=p*g*4*z;for(let Y=0;Y<O.count;Y++){const J=Y*I;e===!0&&(Le.fromBufferAttribute(O,Y),A[F+J+0]=Le.x,A[F+J+1]=Le.y,A[F+J+2]=Le.z,A[F+J+3]=0),t===!0&&(Le.fromBufferAttribute(B,Y),A[F+J+4]=Le.x,A[F+J+5]=Le.y,A[F+J+6]=Le.z,A[F+J+7]=0),s===!0&&(Le.fromBufferAttribute(K,Y),A[F+J+8]=Le.x,A[F+J+9]=Le.y,A[F+J+10]=Le.z,A[F+J+11]=K.itemSize===4?Le.w:1)}}r={count:i,texture:_,stride:l,size:new we(p,g)},tn.set(n,r),n.addEventListener("dispose",E)}return r}class or extends L{constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=X(1),this.updateType=$.OBJECT}setup(e){const{geometry:t}=e,s=t.morphAttributes.position!==void 0,o=t.morphAttributes.normal!==void 0,i=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,r=i!==void 0?i.length:0,{texture:a,stride:c,size:u}=gd(t);s===!0&&Te.mulAssign(this.morphBaseInfluence),o===!0&&je.mulAssign(this.morphBaseInfluence);const l=h(u.width);Z(r,({i:p})=>{const g=d(0).toVar();this.mesh.isInstancedMesh===!0&&this.mesh.morphTexture!==null&&this.mesh.morphTexture!==void 0?g.assign(Nt(this.mesh.morphTexture,yt(h(p).add(1),h(Ni))).r):g.assign(Xe("morphTargetInfluences","float").element(p).toVar()),s===!0&&Te.addAssign(Mo({bufferMap:a,influence:g,stride:c,width:l,depth:p,offset:h(0)})),o===!0&&je.addAssign(Mo({bufferMap:a,influence:g,stride:c,width:l,depth:p,offset:h(1)}))})}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce((t,s)=>t+s,0)}}const fd=y(or);T("MorphNode",or);class ir extends L{constructor(){super("vec3")}getHash(){return"reflectVector"}setup(){return se.negate().reflect(oe).transformDirection(it)}}const Nd=S(ir);T("ReflectVectorNode",ir);class rr extends Wt{constructor(e,t=null,s=null){super(e,t,s),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){return Nd}setUpdateMatrix(){}setupUV(e,t){const s=this.value;return e.renderer.coordinateSystem===Yo||!s.isRenderTargetTexture?f(t.x.negate(),t.yz):t}generateUV(e,t){return t.build(e,"vec3")}}const ar=y(rr);N("cubeTexture",ar);T("CubeTextureNode",rr);class us extends L{constructor(){super("vec3")}generate(){console.warn("Abstract function.")}}T("LightingNode",us);let Kt=null;class _t extends us{constructor(e=null){super(),this.updateType=$.FRAME,this.light=e,this.rtt=null,this.shadowNode=null,this.shadowMaskNode=null,this.color=new ts,this._defaultColorNode=X(this.color),this.colorNode=this._defaultColorNode,this.isAnalyticLightNode=!0}getCacheKey(){return super.getCacheKey()+"-"+(this.light.id+"-"+(this.light.castShadow?"1":"0"))}getHash(){return this.light.uuid}setupShadow(e){const{object:t}=e;if(t.receiveShadow===!1)return;let s=this.shadowNode;if(s===null){Kt===null&&(Kt=e.createNodeMaterial(),Kt.fragmentNode=w(0,0,0,1),Kt.isShadowNodeMaterial=!0);const o=this.light.shadow,i=e.createRenderTarget(o.mapSize.width,o.mapSize.height),r=new Bn;r.minFilter=vs,r.magFilter=vs,r.image.width=o.mapSize.width,r.image.height=o.mapSize.height,r.compareFunction=cc,i.depthTexture=r,o.camera.updateProjectionMatrix();const a=Xe("bias","float",o),c=Xe("normalBias","float",o),u=t.material.shadowPositionNode||Mn;let l=X(o.matrix).mul(u.add($i.mul(c)));l=l.xyz.div(l.w);const p=l.x.greaterThanEqual(0).and(l.x.lessThanEqual(1)).and(l.y.greaterThanEqual(0)).and(l.y.lessThanEqual(1)).and(l.z.lessThanEqual(1));let g=l.z.add(a);e.renderer.coordinateSystem===Yo&&(g=g.mul(2).sub(1)),l=f(l.x,l.y.oneMinus(),g),s=((I,E,z)=>be(I,E).compare(z))(r,l.xy,l.z);const A=be(i.texture,l),_=p.mix(1,s.mix(A.a.mix(1,A),1));this.rtt=i,this.colorNode=this.colorNode.mul(_),this.shadowNode=s,this.shadowMaskNode=_,this.updateBeforeType=$.RENDER}}setup(e){this.light.castShadow?this.setupShadow(e):this.shadowNode!==null&&this.disposeShadow()}updateShadow(e){const{rtt:t,light:s}=this,{renderer:o,scene:i}=e,r=i.overrideMaterial;i.overrideMaterial=Kt,t.setSize(s.shadow.mapSize.width,s.shadow.mapSize.height),s.shadow.updateMatrices(s);const a=o.toneMapping,c=o.getRenderTarget(),u=o.getRenderObjectFunction();o.setRenderObjectFunction((l,...p)=>{l.castShadow===!0&&o.renderObject(l,...p)}),o.setRenderTarget(t),o.toneMapping=Ts,o.render(i,s.shadow.camera),o.setRenderTarget(c),o.setRenderObjectFunction(u),o.toneMapping=a,i.overrideMaterial=r}disposeShadow(){this.rtt.dispose(),this.shadowNode=null,this.shadowMaskNode=null,this.rtt=null,this.colorNode=this._defaultColorNode}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(){const{light:e}=this;this.color.copy(e.color).multiplyScalar(e.intensity)}}T("AnalyticLightNode",_t);const Cs=new WeakMap,yd=n=>n.sort((e,t)=>e.id-t.id);class xd extends L{constructor(e=[]){super("vec3"),this.totalDiffuseNode=f().temp("totalDiffuse"),this.totalSpecularNode=f().temp("totalSpecular"),this.outgoingLightNode=f().temp("outgoingLight"),this.lightNodes=e,this._hash=null}get hasLight(){return this.lightNodes.length>0}getHash(){if(this._hash===null){const e=[];for(const t of this.lightNodes)e.push(t.getHash());this._hash="lights-"+e.join(",")}return this._hash}setup(e){const t=e.context,s=t.lightingModel;let o=this.outgoingLightNode;if(s){const{lightNodes:i,totalDiffuseNode:r,totalSpecularNode:a}=this;t.outgoingLight=o;const c=e.addStack();s.start(t,c,e);for(const I of i)I.build(e);s.indirectDiffuse(t,c,e),s.indirectSpecular(t,c,e),s.ambientOcclusion(t,c,e);const{backdrop:u,backdropAlpha:l}=t,{directDiffuse:p,directSpecular:g,indirectDiffuse:V,indirectSpecular:A}=t.reflectedLight;let _=p.add(V);u!==null&&(l!==null?_=f(l.mix(_,u)):_=f(u),t.material.transparent=!0),r.assign(_),a.assign(g.add(A)),o.assign(r.add(a)),s.finish(t,c,e),o=o.bypass(e.removeStack())}return o}_getLightNodeById(e){for(const t of this.lightNodes)if(t.isAnalyticLightNode&&t.light.id===e)return t;return null}fromLights(e=[]){const t=[];e=yd(e);for(const s of e){let o=this._getLightNodeById(s.id);if(o===null){const i=s.constructor,r=Cs.has(i)?Cs.get(i):_t;o=R(new r(s))}t.push(o)}return this.lightNodes=t,this._hash=null,this}}const vd=y(xd);function Xt(n,e){if(Cs.has(n)){console.warn(`Redefinition of light node ${e.type}`);return}if(typeof n!="function")throw new Error(`Light ${n.name} is not a class`);if(typeof e!="function"||!e.type)throw new Error(`Light node ${e.type} is not a class`);Cs.set(n,e)}class cr extends us{constructor(e=null){super(),this.aoNode=e}setup(e){const s=this.aoNode.x.sub(1).mul(1).add(1);e.context.ambientOcclusion.mulAssign(s)}}T("AONode",cr);class ur extends jn{constructor(e,t=null,s=null,o=null){super(e),this.lightingModel=t,this.backdropNode=s,this.backdropAlphaNode=o,this._context=null}getContext(){const{backdropNode:e,backdropAlphaNode:t}=this,s=f().temp("directDiffuse"),o=f().temp("directSpecular"),i=f().temp("indirectDiffuse"),r=f().temp("indirectSpecular"),a={directDiffuse:s,directSpecular:o,indirectDiffuse:i,indirectSpecular:r};return{radiance:f().temp("radiance"),irradiance:f().temp("irradiance"),iblIrradiance:f().temp("iblIrradiance"),ambientOcclusion:d(1).temp("ambientOcclusion"),reflectedLight:a,backdrop:e,backdropAlpha:t}}setup(e){return this.context=this._context||(this._context=this.getContext()),this.context.lightingModel=this.lightingModel||e.context.lightingModel,super.setup(e)}}const lr=y(ur);N("lightingContext",lr);T("LightingContextNode",ur);class le extends L{constructor(e=le.LOCAL){super("vec3"),this.scope=e}getHash(){return`bitangent-${this.scope}`}generate(e){const t=this.scope;let s;t===le.GEOMETRY?s=ws.cross(Es):t===le.LOCAL?s=je.cross($s):t===le.VIEW?s=ht.cross(Xs):t===le.WORLD&&(s=$i.cross(dd));const o=s.mul(Es.w).xyz;return Se(ne(o)).build(e,this.getNodeType(e))}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}le.GEOMETRY="geometry";le.LOCAL="local";le.VIEW="view";le.WORLD="world";S(le,le.GEOMETRY);S(le,le.LOCAL);const Td=S(le,le.VIEW);S(le,le.WORLD);const Sd=Se(oe.cross(er).mul(Es.w));Se(Sd.transformDirection(it));T("BitangentNode",le);const Ct=$e(Xs,Td,ht);se.mul(Ct);const Ad=(()=>{let n=bt.cross(se);return n=n.cross(bt).normalize(),n=ye(n,oe,ft.mul(ut.oneMinus()).oneMinus().pow2().pow2()).normalize(),n})();class no extends L{constructor(e,t,s=null){super(),this.condNode=e,this.ifNode=t,this.elseNode=s}getNodeType(e){const t=this.ifNode.getNodeType(e);if(this.elseNode!==null){const s=this.elseNode.getNodeType(e);if(e.getTypeLength(s)>e.getTypeLength(t))return s}return t}generate(e,t){const s=this.getNodeType(e),o={tempWrite:!1},i=e.getDataFromNode(this);if(i.nodeProperty!==void 0)return i.nodeProperty;const{ifNode:r,elseNode:a}=this,c=t!=="void",u=c?ge(s).build(e):"";i.nodeProperty=u;const l=nt(this.condNode).build(e,"bool");e.addFlowCode(`
${e.tab}if ( ${l} ) {

`).addFlowTab();let p=nt(r,o).build(e,s);if(p&&(c?p=u+" = "+p+";":p="return "+p+";"),e.removeFlowTab().addFlowCode(e.tab+"	"+p+`

`+e.tab+"}"),a!==null){e.addFlowCode(` else {

`).addFlowTab();let g=nt(a,o).build(e,s);g&&(c?g=u+" = "+g+";":g="return "+g+";"),e.removeFlowTab().addFlowCode(e.tab+"	"+g+`

`+e.tab+`}

`)}else e.addFlowCode(`

`);return e.format(u,s,t)}}const Oe=y(no);N("cond",Oe);T("CondNode",no);const wo=d(1),wn=d(-2),ps=d(.8),sn=d(-1),ms=d(.4),nn=d(2),gs=d(.305),on=d(3),Eo=d(.21),Vd=d(4),Co=d(4),_d=d(16),Rd=x(([n])=>{const e=f(ae(n)).toVar(),t=d(-1).toVar();return P(e.x.greaterThan(e.z),()=>{P(e.x.greaterThan(e.y),()=>{t.assign(Oe(n.x.greaterThan(0),0,3))}).else(()=>{t.assign(Oe(n.y.greaterThan(0),1,4))})}).else(()=>{P(e.z.greaterThan(e.y),()=>{t.assign(Oe(n.z.greaterThan(0),2,5))}).else(()=>{t.assign(Oe(n.y.greaterThan(0),1,4))})}),t}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),Md=x(([n,e])=>{const t=C().toVar();return P(e.equal(0),()=>{t.assign(C(n.z,n.y).div(ae(n.x)))}).elseif(e.equal(1),()=>{t.assign(C(n.x.negate(),n.z.negate()).div(ae(n.y)))}).elseif(e.equal(2),()=>{t.assign(C(n.x.negate(),n.y).div(ae(n.z)))}).elseif(e.equal(3),()=>{t.assign(C(n.z.negate(),n.y).div(ae(n.x)))}).elseif(e.equal(4),()=>{t.assign(C(n.x.negate(),n.z).div(ae(n.y)))}).else(()=>{t.assign(C(n.x,n.y).div(ae(n.z)))}),U(.5,t.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),wd=x(([n])=>{const e=d(0).toVar();return P(n.greaterThanEqual(ps),()=>{e.assign(wo.sub(n).mul(sn.sub(wn)).div(wo.sub(ps)).add(wn))}).elseif(n.greaterThanEqual(ms),()=>{e.assign(ps.sub(n).mul(nn.sub(sn)).div(ps.sub(ms)).add(sn))}).elseif(n.greaterThanEqual(gs),()=>{e.assign(ms.sub(n).mul(on.sub(nn)).div(ms.sub(gs)).add(nn))}).elseif(n.greaterThanEqual(Eo),()=>{e.assign(gs.sub(n).mul(Vd.sub(on)).div(gs.sub(Eo)).add(on))}).else(()=>{e.assign(d(-2).mul(ks(U(1.16,n))))}),e}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]});x(([n,e])=>{const t=n.toVar();t.assign(U(2,t).sub(1));const s=f(t,1).toVar();return P(e.equal(0),()=>{s.assign(s.zyx)}).elseif(e.equal(1),()=>{s.assign(s.xzy),s.xz.mulAssign(-1)}).elseif(e.equal(2),()=>{s.x.mulAssign(-1)}).elseif(e.equal(3),()=>{s.assign(s.zyx),s.xz.mulAssign(-1)}).elseif(e.equal(4),()=>{s.assign(s.xzy),s.xy.mulAssign(-1)}).elseif(e.equal(5),()=>{s.z.mulAssign(-1)}),s}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]});const Ed=x(([n,e,t,s,o,i])=>{const r=d(t),a=f(e),c=kt(wd(r),wn,i),u=Gs(c),l=Ht(c),p=f(En(n,a,l,s,o,i)).toVar();return P(u.notEqual(0),()=>{const g=f(En(n,a,l.add(1),s,o,i)).toVar();p.assign(ye(p,g,u))}),p}),En=x(([n,e,t,s,o,i])=>{const r=d(t).toVar(),a=f(e),c=d(Rd(a)).toVar(),u=d(De(Co.sub(r),0)).toVar();r.assign(De(r,Co));const l=d(An(r)).toVar(),p=C(Md(a,c).mul(l.sub(2)).add(1)).toVar();return P(c.greaterThan(2),()=>{p.y.addAssign(l),c.subAssign(3)}),p.x.addAssign(c.mul(l)),p.x.addAssign(u.mul(U(3,_d))),p.y.addAssign(U(4,An(i).sub(l))),p.x.mulAssign(s),p.y.mulAssign(o),n.uv(p).grad(C(),C())}),rn=x(({envMap:n,mipInt:e,outputDirection:t,theta:s,axis:o,CUBEUV_TEXEL_WIDTH:i,CUBEUV_TEXEL_HEIGHT:r,CUBEUV_MAX_MIP:a})=>{const c=rt(s),u=t.mul(c).add(o.cross(t).mul(st(s))).add(o.mul(o.dot(t).mul(c.oneMinus())));return En(n,u,e,i,r,a)});x(({n,latitudinal:e,poleAxis:t,outputDirection:s,weights:o,samples:i,dTheta:r,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p})=>{const g=f(Oe(e,t,bi(t,s))).toVar();P(Ei(g.equals(f(0))),()=>{g.assign(f(s.z,0,s.x.negate()))}),g.assign(Se(g));const V=f().toVar();return V.addAssign(o.element(h(0)).mul(rn({theta:0,axis:g,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p}))),Z({start:h(1),end:n},({i:A})=>{P(A.greaterThanEqual(i),()=>{md()});const _=d(r.mul(d(A))).toVar();V.addAssign(o.element(A).mul(rn({theta:_.mul(-1),axis:g,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p}))),V.addAssign(o.element(A).mul(rn({theta:_,axis:g,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:p})))}),w(V,1)});let Ls=null;const Lo=new WeakMap;function Cd(n){const e=Math.log2(n)-2,t=1/n;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:t,maxMip:e}}function Ld(n){let e=Lo.get(n);if((e!==void 0?e.pmremVersion:-1)!==n.pmremVersion){if(n.isCubeTexture){if(n.source.data.some(s=>s===void 0))throw new Error("PMREMNode: Undefined texture in CubeTexture. Use onLoad callback or async loader");e=Ls.fromCubemap(n,e)}else{if(n.image===void 0)throw new Error("PMREMNode: Undefined image in Texture. Use onLoad callback or async loader");e=Ls.fromEquirectangular(n,e)}e.pmremVersion=n.pmremVersion,Lo.set(n,e)}return e.texture}class dr extends j{constructor(e,t=null,s=null){super("vec3"),this._value=e,this._pmrem=null,this.uvNode=t,this.levelNode=s,this._generator=null,this._texture=be(null),this._width=X(0),this._height=X(0),this._maxMip=X(0),this.updateBeforeType=$.RENDER}set value(e){this._value=e,this._pmrem=null}get value(){return this._value}updateFromTexture(e){const t=Cd(e.image.height);this._texture.value=e,this._width.value=t.texelWidth,this._height.value=t.texelHeight,this._maxMip.value=t.maxMip}updateBefore(){let e=this._pmrem;const t=e?e.pmremVersion:-1,s=this._value;t!==s.pmremVersion&&(s.isPMREMTexture===!0?e=s:e=Ld(s),this._pmrem=e,this.updateFromTexture(e))}setup(e){Ls===null&&(Ls=e.createPMREMGenerator()),this.updateBefore(e);let t=this.uvNode;t===null&&e.context.getUV&&(t=e.context.getUV(this));const s=this.value;e.renderer.coordinateSystem===Zo&&s.isPMREMTexture!==!0&&s.isRenderTargetTexture===!0&&(t=f(t.x.negate(),t.yz));let o=this.levelNode;return o===null&&e.context.getTextureLevel&&(o=e.context.getTextureLevel(this)),Ed(this._texture,t,o,this._width,this._height,this._maxMip)}}const Id=y(dr);T("PMREMNode",dr);const Io=new WeakMap;class hr extends us{constructor(e=null){super(),this.envNode=e}setup(e){let t=this.envNode;if(t.isTextureNode){let g=Io.get(t.value);g===void 0&&(g=Id(t.value),Io.set(t.value,g)),t=g}const{material:s}=e,i=s.envMap?Xe("envMapIntensity","float",e.material):Xe("environmentIntensity","float",e.scene),a=s.useAnisotropy===!0||s.anisotropy>0?Ad:oe,c=nt(t,Oo(ut,a)).mul(i),u=nt(t,Od(Xi)).mul(Math.PI).mul(i),l=As(c);e.context.radiance.addAssign(l),e.context.iblIrradiance.addAssign(u);const p=e.context.lightingModel.clearcoatRadiance;if(p){const g=nt(t,Oo(_s,Et)).mul(i),V=As(g);p.addAssign(V)}}}const Oo=(n,e)=>{let t=null;return{getUV:()=>(t===null&&(t=se.negate().reflect(e),t=n.mul(n).mix(t,e).normalize(),t=t.transformDirection(it)),t),getTextureLevel:()=>n}},Od=n=>({getUV:()=>n,getTextureLevel:()=>d(1)});T("EnvironmentNode",hr);class pr extends us{constructor(e){super(),this.node=e}setup(e){e.context.irradiance.addAssign(this.node)}}T("IrradianceNode",pr);let an,cn;class k extends L{constructor(e){super(),this.scope=e,this.isViewportNode=!0}getNodeType(){return this.scope===k.VIEWPORT?"vec4":this.scope===k.COORDINATE?"vec3":"vec2"}getUpdateType(){let e=$.NONE;return(this.scope===k.RESOLUTION||this.scope===k.VIEWPORT)&&(e=$.FRAME),this.updateType=e,e}update({renderer:e}){this.scope===k.VIEWPORT?e.getViewport(cn):e.getDrawingBufferSize(an)}setup(){const e=this.scope;let t=null;if(e===k.RESOLUTION)t=X(an||(an=new we));else if(e===k.VIEWPORT)t=X(cn||(cn=new lt));else{t=bd.div(Cn);let s=t.x,o=t.y;/bottom/i.test(e)&&(o=o.oneMinus()),/right/i.test(e)&&(s=s.oneMinus()),t=C(s,o)}return t}generate(e){if(this.scope===k.COORDINATE){let t=e.getFragCoord();if(e.isFlipY()){const s=e.getNodeProperties(Cn).outputNode.build(e);t=`${e.getType("vec3")}( ${t}.x, ${s}.y - ${t}.y, ${t}.z )`}return t}return super.generate(e)}}k.COORDINATE="coordinate";k.RESOLUTION="resolution";k.VIEWPORT="viewport";k.TOP_LEFT="topLeft";k.BOTTOM_LEFT="bottomLeft";k.TOP_RIGHT="topRight";k.BOTTOM_RIGHT="bottomRight";const bd=S(k,k.COORDINATE),Cn=S(k,k.RESOLUTION),Dt=S(k,k.VIEWPORT),is=S(k,k.TOP_LEFT);S(k,k.BOTTOM_LEFT);S(k,k.TOP_RIGHT);S(k,k.BOTTOM_RIGHT);T("ViewportNode",k);const Jt=new we;class ls extends Wt{constructor(e=is,t=null,s=null){s===null&&(s=new Ko,s.minFilter=uc),super(s,e,t),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=$.FRAME}updateBefore(e){const t=e.renderer;t.getDrawingBufferSize(Jt);const s=this.value;(s.image.width!==Jt.width||s.image.height!==Jt.height)&&(s.image.width=Jt.width,s.image.height=Jt.height,s.needsUpdate=!0);const o=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,t.copyFramebufferToTexture(s),s.generateMipmaps=o}clone(){const e=new this.constructor(this.uvNode,this.levelNode,this.value);return e.generateMipmaps=this.generateMipmaps,e}}const zd=y(ls),mr=y(ls,null,null,{generateMipmaps:!0});N("viewportTexture",zd);N("viewportMipTexture",mr);T("ViewportTextureNode",ls);let un=null;class gr extends ls{constructor(e=is,t=null){un===null&&(un=new Bn),super(e,t,un)}}const fr=y(gr);N("viewportDepthTexture",fr);T("ViewportDepthTextureNode",gr);class fe extends L{constructor(e,t=null){super("float"),this.scope=e,this.valueNode=t,this.isViewportDepthNode=!0}generate(e){const{scope:t}=this;return t===fe.DEPTH_PIXEL?e.getFragDepth():super.generate(e)}setup(){const{scope:e}=this;let t=null;if(e===fe.DEPTH)t=Ln(Ie.z,Js,Qs);else if(e===fe.DEPTH_TEXTURE){const s=this.valueNode||fr(),o=Nr(s,Js,Qs);t=Ln(o,Js,Qs)}else e===fe.DEPTH_PIXEL&&this.valueNode!==null&&(t=yr().assign(this.valueNode));return t}}const Ln=(n,e,t)=>n.add(e).div(e.sub(t)),Nr=(n,e,t)=>e.mul(t).div(t.sub(e).mul(n).sub(t));fe.DEPTH="depth";fe.DEPTH_TEXTURE="depthTexture";fe.DEPTH_PIXEL="depthPixel";const yr=y(fe,fe.DEPTH_PIXEL);S(fe,fe.DEPTH);y(fe,fe.DEPTH_TEXTURE);const xr=S(fe,fe.DEPTH_PIXEL);xr.assign=n=>yr(n);T("ViewportDepthNode",fe);class pt extends L{constructor(e=pt.DEFAULT){super(),this.scope=e}setup(e){super.setup(e);const t=e.clippingContext,{localClipIntersection:s,localClippingCount:o,globalClippingCount:i}=t,r=i+o,a=s?r-o:r;return this.scope===pt.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(t.planes,r,a):this.setupDefault(t.planes,r,a)}setupAlphaToCoverage(e,t,s){return x(()=>{const o=Vn(e),i=ge("float","distanceToPlane"),r=ge("float","distanceToGradient"),a=ge("float","clipOpacity");a.assign(1);let c;if(Z(s,({i:u})=>{c=o.element(u),i.assign(Ie.dot(c.xyz).negate().add(c.w)),r.assign(i.fwidth().div(2)),a.mulAssign(ot(r.negate(),r,i)),a.equal(0).discard()}),s<t){const u=ge("float","unionclipOpacity");u.assign(1),Z({start:s,end:t},({i:l})=>{c=o.element(l),i.assign(Ie.dot(c.xyz).negate().add(c.w)),r.assign(i.fwidth().div(2)),u.mulAssign(ot(r.negate(),r,i).oneMinus())}),a.mulAssign(u.oneMinus())}te.a.mulAssign(a),te.a.equal(0).discard()})()}setupDefault(e,t,s){return x(()=>{const o=Vn(e);let i;if(Z(s,({i:r})=>{i=o.element(r),Ie.dot(i.xyz).greaterThan(i.w).discard()}),s<t){const r=ge("bool","clipped");r.assign(!0),Z({start:s,end:t},({i:a})=>{i=o.element(a),r.assign(Ie.dot(i.xyz).greaterThan(i.w).and(r))}),r.discard()}})()}}pt.ALPHA_TO_COVERAGE="alphaToCoverage";pt.DEFAULT="default";const Dd=()=>R(new pt),Pd=()=>R(new pt(pt.ALPHA_TO_COVERAGE));class vr extends L{constructor(){super("bool"),this.isFrontFacingNode=!0}generate(e){const{renderer:t,material:s}=e;return t.coordinateSystem===Zo&&s.side===lc?"false":e.getFrontFacing()}}const Fd=S(vr),Is=d(Fd).mul(2).sub(1);T("FrontFacingNode",vr);const In=new Map;class Pe extends dc{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!0,this.normals=!0,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.depthNode=null,this.shadowNode=null,this.shadowPositionNode=null,this.outputNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+ni(this)}build(e){this.setup(e)}setup(e){e.addStack(),e.stack.outputNode=this.vertexNode||this.setupPosition(e),e.addFlow("vertex",e.removeStack()),e.addStack();let t;const s=this.setupClipping(e);if(this.depthWrite===!0&&this.setupDepth(e),this.fragmentNode===null){this.normals===!0&&this.setupNormal(e),this.setupDiffuseColor(e),this.setupVariants(e);const o=this.setupLighting(e);s!==null&&e.stack.add(s);const i=w(o,te.a).max(0);t=this.setupOutput(e,i),Mu.assign(t),this.outputNode!==null&&(t=this.outputNode)}else{let o=this.fragmentNode;o.isOutputStructNode!==!0&&(o=w(o)),t=this.setupOutput(e,o)}e.stack.outputNode=t,e.addFlow("fragment",e.removeStack())}setupClipping(e){if(e.clippingContext===null)return null;const{globalClippingCount:t,localClippingCount:s}=e.clippingContext;let o=null;return(t||s)&&(this.alphaToCoverage?o=Pd():e.stack.add(Dd())),o}setupDepth(e){const{renderer:t}=e;let s=this.depthNode;s===null&&t.logarithmicDepthBuffer===!0&&(s=Vo().w.add(1).log2().mul(zl).mul(.5)),s!==null&&xr.assign(s).append()}setupPosition(e){const{object:t}=e,s=t.geometry;e.addStack(),(s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&fd(t).append(),t.isSkinnedMesh===!0&&pd(t).append(),t.isBatchedMesh&&hd(t).append(),t.instanceMatrix&&t.instanceMatrix.isInstancedBufferAttribute===!0&&e.isAvailable("instance")===!0&&ld(t).append(),this.positionNode!==null&&Te.assign(this.positionNode);const o=Vo();return e.context.vertex=e.removeStack(),e.context.mvp=o,o}setupDiffuseColor({object:e,geometry:t}){let s=this.colorNode?w(this.colorNode):os;this.vertexColors===!0&&t.hasAttribute("color")&&(s=w(s.xyz.mul(ve("color","vec3")),s.a)),e.instanceColor&&(s=Ye("vec3","vInstanceColor").mul(s)),te.assign(s);const o=this.opacityNode?d(this.opacityNode):ji;if(te.a.assign(te.a.mul(o)),this.alphaTestNode!==null||this.alphaTest>0){const i=this.alphaTestNode!==null?d(this.alphaTestNode):Pl;te.a.lessThanEqual(i).discard()}}setupVariants(){}setupNormal(){if(this.flatShading===!0){const e=Ie.dFdx().cross(Ie.dFdy()).normalize();oe.assign(e.mul(Is))}else{const e=this.normalNode?f(this.normalNode):Wl;oe.assign(e.mul(Is))}}getEnvNode(e){let t=null;return this.envNode?t=this.envNode:this.envMap?t=this.envMap.isCubeTexture?ar(this.envMap):be(this.envMap):e.environmentNode&&(t=e.environmentNode),t}setupLights(e){const t=this.getEnvNode(e),s=[];if(t&&s.push(new hr(t)),e.material.lightMap&&s.push(new pr(Hi("lightMap","texture"))),this.aoNode!==null||e.material.aoMap){const i=this.aoNode!==null?this.aoNode:be(e.material.aoMap);s.push(new cr(i))}let o=this.lightsNode||e.lightsNode;return s.length>0&&(o=vd([...o.lightNodes,...s])),o}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:s,backdropAlphaNode:o,emissiveNode:i}=this,a=this.lights===!0||this.lightsNode!==null?this.setupLights(e):null;let c=te.rgb;if(a&&a.hasLight!==!1){const u=this.setupLightingModel(e);c=lr(a,u,s,o)}else s!==null&&(c=f(o!==null?ye(c,s,o):s));return(i&&i.isNode===!0||t.emissive&&t.emissive.isColor===!0)&&(c=c.add(f(i||Ul))),c}setupOutput(e,t){const s=e.fogNode;return s&&(t=w(s.mix(t.rgb,s.colorNode),t.a)),t}setDefaultValues(e){for(const s in e){const o=e[s];this[s]===void 0&&(this[s]=o,o&&o.clone&&(this[s]=o.clone()))}Object.assign(this.defines,e.defines);const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const s in t)Object.getOwnPropertyDescriptor(this.constructor.prototype,s)===void 0&&t[s].get!==void 0&&Object.defineProperty(this.constructor.prototype,s,t[s])}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{},nodes:{}});const s=hc.prototype.toJSON.call(this,e),o=Ss(this);s.inputNodes={};for(const{property:r,childNode:a}of o)s.inputNodes[r]=a.toJSON(e).uuid;function i(r){const a=[];for(const c in r){const u=r[c];delete u.metadata,a.push(u)}return a}if(t){const r=i(e.textures),a=i(e.images),c=i(e.nodes);r.length>0&&(s.textures=r),a.length>0&&(s.images=a),c.length>0&&(s.nodes=c)}return s}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.positionNode=e.positionNode,this.depthNode=e.depthNode,this.shadowNode=e.shadowNode,this.shadowPositionNode=e.shadowPositionNode,this.outputNode=e.outputNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}static fromMaterial(e){if(e.isNodeMaterial===!0)return e;const t=e.type.replace("Material","NodeMaterial"),s=Ud(t);if(s===void 0)throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);for(const o in e)s[o]=e[o];return s}}function Ae(n,e){if(typeof e!="function"||!n)throw new Error(`Node material ${n} is not a class`);if(In.has(n)){console.warn(`Redefinition of node material ${n}`);return}In.set(n,e),e.type=n}function Ud(n){const e=In.get(n);if(e!==void 0)return new e}Ae("NodeMaterial",Pe);class Tr extends L{constructor(e=null){super(),this.nodes=[],this.outputNode=null,this.parent=e,this._currentCond=null,this.isStackNode=!0}getNodeType(e){return this.outputNode?this.outputNode.getNodeType(e):"void"}add(e){return this.nodes.push(e),this}if(e,t){const s=new Qt(t);return this._currentCond=Oe(e,s),this.add(this._currentCond)}elseif(e,t){const s=new Qt(t),o=Oe(e,s);return this._currentCond.elseNode=o,this._currentCond=o,this}else(e){return this._currentCond.elseNode=new Qt(e),this}build(e,...t){const s=Qc();yo(this);for(const o of this.nodes)o.build(e,"void");return yo(s),this.outputNode?this.outputNode.build(e,...t):super.build(e,...t)}}y(Tr);T("StackNode",Tr);class Sr extends j{constructor(e=cd){super("vec2"),this.dirNode=e}setup(){const e=this.dirNode,t=e.z.atan2(e.x).mul(1/(Math.PI*2)).add(.5),s=e.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return C(t,s)}}y(Sr);T("EquirectUVNode",Sr);class Ar extends L{constructor(e){super(),this.types=e,this.isStructTypeNode=!0}getMemberTypes(){return this.types}}T("StructTypeNode",Ar);class Vr extends L{constructor(...e){super(),this.members=e,this.isOutputStructNode=!0}setup(e){super.setup(e);const t=this.members,s=[];for(let o=0;o<t.length;o++)s.push(t[o].getNodeType(e));this.nodeType=e.getStructTypeFromNode(new Ar(s)).name}generate(e,t){const s=e.getVarFromNode(this);s.isOutputStructVar=!0;const o=e.getPropertyName(s),i=this.members,r=o!==""?o+".":"";for(let a=0;a<i.length;a++){const c=i[a].build(e,t);e.addLineFlowCode(`${r}m${a} = ${c}`)}return o}}y(Vr);T("OutputStructNode",Vr);class _r extends L{constructor(e){super(),this.seedNode=e}setup(){const e=this.seedNode.uint().mul(747796405).add(2891336453),t=e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);return t.shiftRight(22).bitXor(t).float().mul(1/2**32)}}const Bd=y(_r);N("hash",Bd);T("HashNode",_r);const On=(n,e)=>Je(U(4,n.mul(re(1,n))),e),kd=(n,e)=>n.lessThan(.5)?On(n.mul(2),e).div(2):re(1,On(U(re(1,n),2),e).div(2)),Gd=(n,e,t)=>Je(dt(Je(n,e),ze(Je(n,e),Je(re(1,n),t))),1/e),Hd=(n,e)=>st(xo.mul(e.mul(n).sub(1))).div(xo.mul(e.mul(n).sub(1)));N("parabola",On);N("gain",kd);N("pcurve",Gd);N("sinc",Hd);const Ke=x(([n])=>n.fract().sub(.5).abs()),Rr=x(([n])=>f(Ke(n.z.add(Ke(n.y.mul(1)))),Ke(n.z.add(Ke(n.x.mul(1)))),Ke(n.y.add(Ke(n.x.mul(1)))))),qd=x(([n,e,t])=>{const s=f(n).toVar(),o=d(1.4).toVar(),i=d(0).toVar(),r=f(s).toVar();return Z({start:d(0),end:d(3),type:"float",condition:"<="},()=>{const a=f(Rr(r.mul(2))).toVar();s.addAssign(a.add(t.mul(d(.1).mul(e)))),r.mulAssign(1.8),o.mulAssign(1.5),s.mulAssign(1.2);const c=d(Ke(s.z.add(Ke(s.x.add(Ke(s.y)))))).toVar();i.addAssign(c.div(o)),r.addAssign(.14)}),i});Ke.setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]});Rr.setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]});qd.setLayout({name:"triNoise3D",type:"float",inputs:[{name:"p",type:"vec3"},{name:"spd",type:"float"},{name:"time",type:"float"}]});let ln;class Mr extends no{constructor(e){ln=ln||Hs("discard"),super(e,ln)}}const Wd=y(Mr),$d=n=>Wd(n).append();N("discard",$d);T("DiscardNode",Mr);class wr extends L{constructor(e=[],...t){super(),this.functionNodes=e,this.parametersNodes=t,this._candidateFnCall=null}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(e){const t=this.parametersNodes;let s=this._candidateFnCall;if(s===null){let o=null,i=-1;for(const r of this.functionNodes){const c=r.shaderNode.layout;if(c===null)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const u=c.inputs;if(t.length===u.length){let l=0;for(let p=0;p<t.length;p++){const g=t[p],V=u[p];g.getNodeType(e)===V.type?l++:l=0}l>i&&(o=r,i=l)}}this._candidateFnCall=s=o(...t)}return s}}const Xd=y(wr),ke=n=>(...e)=>Xd(n,...e);T("FunctionOverloadingNode",wr);class Er extends j{constructor(){super("vec2")}setup(){const e=f(se.z,0,se.x.negate()).normalize(),t=se.cross(e);return C(e.dot(oe),t.dot(oe)).mul(.495).add(.5)}}S(Er);T("MatcapUVNode",Er);class Me extends At{constructor(e=Me.LOCAL,t=1,s=0){super(s),this.scope=e,this.scale=t,this.updateType=$.FRAME}update(e){const t=this.scope,s=this.scale;t===Me.LOCAL?this.value+=e.deltaTime*s:t===Me.DELTA?this.value=e.deltaTime*s:t===Me.FRAME?this.value=e.frameId:this.value=e.time*s}serialize(e){super.serialize(e),e.scope=this.scope,e.scale=this.scale}deserialize(e){super.deserialize(e),this.scope=e.scope,this.scale=e.scale}}Me.LOCAL="local";Me.GLOBAL="global";Me.DELTA="delta";Me.FRAME="frame";const jd=(n,e=0)=>R(new Me(Me.LOCAL,n,e));S(Me,Me.FRAME).uint();T("TimerNode",Me);class de extends L{constructor(e=de.SINE,t=jd()){super(),this.method=e,this.timeNode=t}getNodeType(e){return this.timeNode.getNodeType(e)}setup(){const e=this.method,t=R(this.timeNode);let s=null;return e===de.SINE?s=t.add(.75).mul(Math.PI*2).sin().mul(.5).add(.5):e===de.SQUARE?s=t.fract().round():e===de.TRIANGLE?s=t.add(.5).fract().mul(2).sub(1).abs():e===de.SAWTOOTH&&(s=t.fract()),s}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}de.SINE="sine";de.SQUARE="square";de.TRIANGLE="triangle";de.SAWTOOTH="sawtooth";y(de,de.SINE);y(de,de.SQUARE);y(de,de.TRIANGLE);y(de,de.SAWTOOTH);T("OscNode",de);class et extends j{constructor(e,t){super(),this.scope=e,this.node=t}getNodeType(e){return this.node.getNodeType(e)}setup(){const{scope:e,node:t}=this;let s=null;return e===et.DIRECTION_TO_COLOR?s=t.mul(.5).add(.5):e===et.COLOR_TO_DIRECTION&&(s=t.mul(2).sub(1)),s}}et.DIRECTION_TO_COLOR="directionToColor";et.COLOR_TO_DIRECTION="colorToDirection";const Cr=y(et,et.DIRECTION_TO_COLOR),Yd=y(et,et.COLOR_TO_DIRECTION);N("directionToColor",Cr);N("colorToDirection",Yd);T("PackingNode",et);class oo extends L{constructor(e,t,s,o=d(0),i=d(1)){super(),this.node=e,this.inLowNode=t,this.inHighNode=s,this.outLowNode=o,this.outHighNode=i,this.doClamp=!0}setup(){const{node:e,inLowNode:t,inHighNode:s,outLowNode:o,outHighNode:i,doClamp:r}=this;let a=e.sub(t).div(s.sub(t));return r===!0&&(a=a.clamp()),a.mul(i.sub(o)).add(o)}}const Zd=y(oo,null,null,{doClamp:!1}),Kd=y(oo);N("remap",Zd);N("remapClamp",Kd);T("RemapNode",oo);class Lr extends j{constructor(e,t,s=C(.5)){super("vec2"),this.uvNode=e,this.rotationNode=t,this.centerNode=s}setup(){const{uvNode:e,rotationNode:t,centerNode:s}=this;return e.sub(s).rotate(t).add(s)}}const Jd=y(Lr);N("rotateUV",Jd);T("RotateUVNode",Lr);class Ir extends j{constructor(e,t){super(),this.positionNode=e,this.rotationNode=t}getNodeType(e){return this.positionNode.getNodeType(e)}setup(e){const{rotationNode:t,positionNode:s}=this;if(this.getNodeType(e)==="vec2"){const i=t.cos(),r=t.sin();return Xn(i,r,r.negate(),i).mul(s)}else{const i=t,r=Ot(w(1,0,0,0),w(0,rt(i.x),st(i.x).negate(),0),w(0,st(i.x),rt(i.x),0),w(0,0,0,1)),a=Ot(w(rt(i.y),0,st(i.y),0),w(0,1,0,0),w(st(i.y).negate(),0,rt(i.y),0),w(0,0,0,1)),c=Ot(w(rt(i.z),st(i.z).negate(),0,0),w(st(i.z),rt(i.z),0,0),w(0,0,1,0),w(0,0,0,1));return r.mul(a).mul(c).mul(w(s,1)).xyz}}}const Qd=y(Ir);N("rotate",Qd);T("RotateNode",Ir);class Or extends L{constructor(e,t=tt(),s=d(0)){super("vec2"),this.countNode=e,this.uvNode=t,this.frameNode=s}setup(){const{frameNode:e,uvNode:t,countNode:s}=this,{width:o,height:i}=s,r=e.mod(o.mul(i)).floor(),a=r.mod(o),c=i.sub(r.add(1).div(o).ceil()),u=s.reciprocal(),l=C(a,c);return t.add(l).mul(u)}}y(Or);T("SpriteSheetUVNode",Or);class br extends Gt{constructor(e,t){super(e,t),this.isStorageArrayElementNode=!0}set storageBufferNode(e){this.node=e}get storageBufferNode(){return this.node}setup(e){return e.isAvailable("storageBuffer")===!1&&!this.node.instanceIndex&&this.node.bufferObject===!0&&e.setupPBO(this.node),super.setup(e)}generate(e,t){let s;const o=e.context.assign;if(e.isAvailable("storageBuffer")===!1){const{node:i}=this;!i.instanceIndex&&this.node.bufferObject===!0&&o!==!0?s=e.generatePBO(this):s=i.build(e)}else s=super.generate(e);if(o!==!0){const i=this.getNodeType(e);s=e.format(s,i,t)}return s}}const zr=y(br);N("storageElement",zr);T("StorageArrayElementNode",br);class Dr extends L{constructor(e,t=null,s=null,o=d(1),i=Te,r=je){super("vec4"),this.textureXNode=e,this.textureYNode=t,this.textureZNode=s,this.scaleNode=o,this.positionNode=i,this.normalNode=r}setup(){const{textureXNode:e,textureYNode:t,textureZNode:s,scaleNode:o,positionNode:i,normalNode:r}=this;let a=r.abs().normalize();a=a.div(a.dot(f(1)));const c=i.yz.mul(o),u=i.zx.mul(o),l=i.xy.mul(o),p=e.value,g=t!==null?t.value:p,V=s!==null?s.value:p,A=be(p,c).mul(a.x),_=be(g,u).mul(a.y),I=be(V,l).mul(a.z);return ze(A,_,I)}}const eh=y(Dr),th=(...n)=>eh(...n);N("triplanarTexture",th);T("TriplanarTexturesNode",Dr);new pc;new He;new He;new He;new Wo;new He(0,0,-1);new lt;new He;new He;new lt;new we;new xt;C(is.x.oneMinus(),is.y);class sh extends Bs{constructor(e=0){super(null,"vec4"),this.isVertexColorNode=!0,this.index=e}getAttributeName(){const e=this.index;return"color"+(e>0?e:"")}generate(e){const t=this.getAttributeName(e),s=e.hasGeometryAttribute(t);let o;return s===!0?o=super.generate(e):o=e.generateConst(this.nodeType,new lt(1,1,1,1)),o}serialize(e){super.serialize(e),e.index=this.index}deserialize(e){super.deserialize(e),this.index=e.index}}T("VertexColorNode",sh);class Pr extends $t{constructor(e,t,s=null){super(e,t,s),this.renderer=s}updateReference(e){return this.reference=this.renderer!==null?this.renderer:e.renderer,this.reference}}const nh=(n,e,t)=>R(new Pr(n,e,t));T("RendererReferenceNode",Pr);const js=1/6,Fr=n=>U(js,U(n,U(n,n.negate().add(3)).sub(3)).add(1)),bn=n=>U(js,U(n,U(n,U(3,n).sub(6))).add(4)),Ur=n=>U(js,U(n,U(n,U(-3,n).add(3)).add(3)).add(1)),zn=n=>U(js,Je(n,3)),bo=n=>Fr(n).add(bn(n)),zo=n=>Ur(n).add(zn(n)),Do=n=>ze(-1,bn(n).div(Fr(n).add(bn(n)))),Po=n=>ze(1,zn(n).div(Ur(n).add(zn(n)))),Fo=(n,e,t)=>{const s=n.uvNode,o=U(s,e.zw).add(.5),i=Ht(o),r=Gs(o),a=bo(r.x),c=zo(r.x),u=Do(r.x),l=Po(r.x),p=Do(r.y),g=Po(r.y),V=C(i.x.add(u),i.y.add(p)).sub(.5).mul(e.xy),A=C(i.x.add(l),i.y.add(p)).sub(.5).mul(e.xy),_=C(i.x.add(u),i.y.add(g)).sub(.5).mul(e.xy),I=C(i.x.add(l),i.y.add(g)).sub(.5).mul(e.xy),E=bo(r.y).mul(ze(a.mul(n.uv(V).level(t)),c.mul(n.uv(A).level(t)))),z=zo(r.y).mul(ze(a.mul(n.uv(_).level(t)),c.mul(n.uv(I).level(t))));return E.add(z)},oh=(n,e)=>{const t=C(n.size(h(e))),s=C(n.size(h(e.add(1)))),o=dt(1,t),i=dt(1,s),r=Fo(n,w(o,t),Ht(e)),a=Fo(n,w(i,s),Ii(e));return Gs(e).mix(r,a)};class Br extends j{constructor(e,t=d(3)){super("vec4"),this.textureNode=e,this.blurNode=t}setup(){return oh(this.textureNode,this.blurNode)}}const ih=y(Br);N("bicubic",ih);T("TextureBicubicNode",Br);class kr extends L{constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}S(kr);T("PointUVNode",kr);class qe extends L{constructor(e=qe.BACKGROUND_BLURRINESS,t=null){super(),this.scope=e,this.scene=t}setup(e){const t=this.scope,s=this.scene!==null?this.scene:e.scene;let o;return t===qe.BACKGROUND_BLURRINESS?o=Xe("backgroundBlurriness","float",s):t===qe.BACKGROUND_INTENSITY?o=Xe("backgroundIntensity","float",s):console.error("THREE.SceneNode: Unknown scope:",t),o}}qe.BACKGROUND_BLURRINESS="backgroundBlurriness";qe.BACKGROUND_INTENSITY="backgroundIntensity";S(qe,qe.BACKGROUND_BLURRINESS);S(qe,qe.BACKGROUND_INTENSITY);T("SceneNode",qe);class rh extends qs{constructor(e,t,s=0){super(e,t,s),this.isStorageBufferNode=!0,this.bufferObject=!1,this._attribute=null,this._varying=null,e.isStorageBufferAttribute!==!0&&e.isStorageInstancedBufferAttribute!==!0&&(e.isInstancedBufferAttribute?e.isStorageInstancedBufferAttribute=!0:e.isStorageBufferAttribute=!0)}getInputType(){return"storageBuffer"}element(e){return zr(this,e)}setBufferObject(e){return this.bufferObject=e,this}generate(e){if(e.isAvailable("storageBuffer"))return super.generate(e);const t=this.getNodeType(e);this._attribute===null&&(this._attribute=Ws(this.value),this._varying=ne(this._attribute));const s=this._varying.build(e,t);return e.registerTransform(s,this._attribute),s}}T("StorageBufferNode",rh);class Gr extends Wt{constructor(e,t,s=null){super(e,t),this.storeNode=s,this.isStoreTextureNode=!0}getInputType(){return"storageTexture"}setup(e){super.setup(e);const t=e.getNodeProperties(this);t.storeNode=this.storeNode}generate(e,t){let s;return this.storeNode!==null?s=this.generateStore(e):s=super.generate(e,t),s}generateStore(e){const t=e.getNodeProperties(this),{uvNode:s,storeNode:o}=t,i=super.generate(e,"property"),r=s.build(e,"uvec2"),a=o.build(e,"vec4"),c=e.generateTextureStore(e,i,r,a);e.addLineFlowCode(c)}}y(Gr);T("TextureStoreNode",Gr);class ah extends $t{constructor(e,t,s=null){super(e,t,s),this.userData=s}update(e){this.reference=this.userData!==null?this.userData:e.object.userData,super.update(e)}}T("UserDataNode",ah);const ch=x(({base:n,blend:e})=>{const t=s=>e[s].lessThan(wi).cond(e[s],n[s].oneMinus().div(e[s]).oneMinus().max(0));return f(t("x"),t("y"),t("z"))}).setLayout({name:"burnColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),uh=x(({base:n,blend:e})=>{const t=s=>e[s].equal(1).cond(e[s],n[s].div(e[s].oneMinus()).max(0));return f(t("x"),t("y"),t("z"))}).setLayout({name:"dodgeColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),lh=x(({base:n,blend:e})=>{const t=s=>n[s].oneMinus().mul(e[s].oneMinus()).oneMinus();return f(t("x"),t("y"),t("z"))}).setLayout({name:"screenColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),dh=x(({base:n,blend:e})=>{const t=s=>n[s].lessThan(.5).cond(n[s].mul(e[s],2),n[s].oneMinus().mul(e[s].oneMinus()).oneMinus());return f(t("x"),t("y"),t("z"))}).setLayout({name:"overlayColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]});class me extends j{constructor(e,t,s){super(),this.blendMode=e,this.baseNode=t,this.blendNode=s}setup(){const{blendMode:e,baseNode:t,blendNode:s}=this,o={base:t,blend:s};let i=null;return e===me.BURN?i=ch(o):e===me.DODGE?i=uh(o):e===me.SCREEN?i=lh(o):e===me.OVERLAY&&(i=dh(o)),i}}me.BURN="burn";me.DODGE="dodge";me.SCREEN="screen";me.OVERLAY="overlay";const hh=y(me,me.BURN),ph=y(me,me.DODGE),mh=y(me,me.OVERLAY),gh=y(me,me.SCREEN);N("burn",hh);N("dodge",ph);N("overlay",mh);N("screen",gh);T("BlendModeNode",me);const fh=x(({textureNode:n,bumpScale:e})=>{const t=o=>n.cache().context({getUV:i=>o(i.uvNode||tt()),forceUVContext:!0}),s=d(t(o=>o));return C(d(t(o=>o.add(o.dFdx()))).sub(s),d(t(o=>o.add(o.dFdy()))).sub(s)).mul(e)}),Nh=x(n=>{const{surf_pos:e,surf_norm:t,dHdxy:s}=n,o=e.dFdx().normalize(),i=e.dFdy().normalize(),r=t,a=i.cross(r),c=r.cross(o),u=o.dot(a).mul(Is),l=u.sign().mul(s.x.mul(a).add(s.y.mul(c)));return u.abs().mul(t).sub(l).normalize()});class Hr extends j{constructor(e,t=null){super("vec3"),this.textureNode=e,this.scaleNode=t}setup(){const e=this.scaleNode!==null?this.scaleNode:1,t=fh({textureNode:this.textureNode,bumpScale:e});return Nh({surf_pos:Ie,surf_norm:ht,dHdxy:t})}}const yh=y(Hr);N("bumpMap",yh);T("BumpMapNode",Hr);const xh=x(({color:n,adjustment:e})=>e.mix(qr(n.rgb),n.rgb)),vh=x(({color:n,adjustment:e})=>{const t=ze(n.r,n.g,n.b).div(3),s=n.r.max(n.g.max(n.b)),o=s.sub(t).mul(e).mul(-3);return ye(n.rgb,s,o)}),Th=x(({color:n,adjustment:e})=>{const t=f(.57735,.57735,.57735),s=e.cos();return f(n.rgb.mul(s).add(t.cross(n.rgb).mul(e.sin()).add(t.mul(qt(t,n.rgb).mul(s.oneMinus())))))});class Ee extends j{constructor(e,t,s=d(1)){super("vec3"),this.method=e,this.colorNode=t,this.adjustmentNode=s}setup(){const{method:e,colorNode:t,adjustmentNode:s}=this,o={color:t,adjustment:s};let i=null;return e===Ee.SATURATION?i=xh(o):e===Ee.VIBRANCE?i=vh(o):e===Ee.HUE?i=Th(o):console.error(`${this.type}: Method "${this.method}" not supported!`),i}}Ee.SATURATION="saturation";Ee.VIBRANCE="vibrance";Ee.HUE="hue";const Sh=y(Ee,Ee.SATURATION),Ah=y(Ee,Ee.VIBRANCE),Vh=y(Ee,Ee.HUE),_h=f(.2125,.7154,.0721),qr=(n,e=_h)=>qt(n,e),Wr=(n,e)=>ye(f(0),n,qr(n).sub(e).max(0));N("saturation",Sh);N("vibrance",Ah);N("hue",Vh);N("threshold",Wr);T("ColorAdjustmentNode",Ee);const Rh=x(n=>{const{eye_pos:e,surf_norm:t,mapN:s,uv:o}=n,i=e.dFdx(),r=e.dFdy(),a=o.dFdx(),c=o.dFdy(),u=t,l=r.cross(u),p=u.cross(i),g=l.mul(a.x).add(p.mul(c.x)),V=l.mul(a.y).add(p.mul(c.y)),A=g.dot(g).max(V.dot(V)),_=Is.mul(A.inverseSqrt());return ze(g.mul(s.x,_),V.mul(s.y,_),u.mul(s.z)).normalize()});class $r extends j{constructor(e,t=null){super("vec3"),this.node=e,this.scaleNode=t,this.normalMapType=uo}setup(e){const{normalMapType:t,scaleNode:s}=this;let o=this.node.mul(2).sub(1);s!==null&&(o=f(o.xy.mul(s),o.z));let i=null;return t===mc?i=Wi.mul(o).normalize():t===uo&&(e.hasGeometryAttribute("tangent")===!0?i=Ct.mul(o).normalize():i=Rh({eye_pos:Ie,surf_norm:ht,mapN:o,uv:tt()})),i}}const Mh=y($r);N("normalMap",Mh);T("NormalMapNode",$r);class Xr extends j{constructor(e,t){super(),this.sourceNode=e,this.stepsNode=t}setup(){const{sourceNode:e,stepsNode:t}=this;return e.mul(t).floor().div(t)}}const wh=y(Xr);N("posterize",wh);T("PosterizeNode",Xr);const Eh=x(({color:n,exposure:e})=>n.mul(e).clamp()),Ch=x(({color:n,exposure:e})=>(n=n.mul(e),n.div(n.add(1)).clamp())),Lh=x(({color:n,exposure:e})=>{n=n.mul(e),n=n.sub(.004).max(0);const t=n.mul(n.mul(6.2).add(.5)),s=n.mul(n.mul(6.2).add(1.7)).add(.06);return t.div(s).pow(2.2)}),Ih=x(({color:n})=>{const e=n.mul(n.add(.0245786)).sub(90537e-9),t=n.mul(n.add(.432951).mul(.983729)).add(.238081);return e.div(t)}),Oh=x(({color:n,exposure:e})=>{const t=$e(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),s=$e(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return n=n.mul(e).div(.6),n=t.mul(n),n=Ih({color:n}),n=s.mul(n),n.clamp()}),bh=$e(f(1.6605,-.1246,-.0182),f(-.5876,1.1329,-.1006),f(-.0728,-.0083,1.1187)),zh=$e(f(.6274,.0691,.0164),f(.3293,.9195,.088),f(.0433,.0113,.8956)),Dh=x(([n])=>{const e=f(n).toVar(),t=f(e.mul(e)).toVar(),s=f(t.mul(t)).toVar();return d(15.5).mul(s.mul(t)).sub(U(40.14,s.mul(e))).add(U(31.96,s).sub(U(6.868,t.mul(e))).add(U(.4298,t).add(U(.1191,e).sub(.00232))))}),Ph=x(({color:n,exposure:e})=>{const t=f(n).toVar(),s=$e(f(.856627153315983,.137318972929847,.11189821299995),f(.0951212405381588,.761241990602591,.0767994186031903),f(.0482516061458583,.101439036467562,.811302368396859)),o=$e(f(1.1271005818144368,-.1413297634984383,-.14132976349843826),f(-.11060664309660323,1.157823702216272,-.11060664309660294),f(-.016493938717834573,-.016493938717834257,1.2519364065950405)),i=d(-12.47393),r=d(4.026069);return t.mulAssign(e),t.assign(zh.mul(t)),t.assign(s.mul(t)),t.assign(De(t,1e-10)),t.assign(ks(t)),t.assign(t.sub(i).div(r.sub(i))),t.assign(kt(t,0,1)),t.assign(Dh(t)),t.assign(o.mul(t)),t.assign(Je(De(f(0),t),f(2.2))),t.assign(bh.mul(t)),t.assign(kt(t,0,1)),t}),Fh={[gc]:Eh,[fc]:Ch,[Nc]:Lh,[yc]:Oh,[xc]:Ph};class jr extends j{constructor(e=Ts,t=Bh,s=null){super("vec3"),this.toneMapping=e,this.exposureNode=t,this.colorNode=s}getCacheKey(){let e=super.getCacheKey();return e="{toneMapping:"+this.toneMapping+",nodes:"+e+"}",e}setup(e){const t=this.colorNode||e.context.color,s=this.toneMapping;if(s===Ts)return t;const o={exposure:this.exposureNode,color:t},i=Fh[s];let r=null;return i?r=i(o):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",s),r=t),r}}const Uh=(n,e,t)=>R(new jr(n,R(e),R(t))),Bh=nh("toneMappingExposure","float");N("toneMapping",(n,e,t)=>Uh(e,t,n));T("ToneMappingNode",jr);let dn=null;class Yr extends ls{constructor(e=is,t=null){dn===null&&(dn=new Ko),super(e,t,dn)}updateReference(){return this}}const kh=y(Yr);N("viewportSharedTexture",kh);T("ViewportSharedTextureNode",Yr);class Dn extends Wt{constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class ds extends j{constructor(e,t,s){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this._pixelRatio=1,this._width=1,this._height=1;const o=new Bn;o.isRenderTargetTexture=!0,o.name="PostProcessingDepth";const i=new xt(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:vc});i.texture.name="PostProcessing",i.depthTexture=o,this.renderTarget=i,this.updateBeforeType=$.FRAME,this._textureNode=R(new Dn(this,i.texture)),this._depthTextureNode=R(new Dn(this,o)),this._depthNode=null,this._viewZNode=null,this._cameraNear=X(0),this._cameraFar=X(0),this.isPassNode=!0}isGlobal(){return!0}getTextureNode(){return this._textureNode}getTextureDepthNode(){return this._depthTextureNode}getViewZNode(){if(this._viewZNode===null){const e=this._cameraNear,t=this._cameraFar;this._viewZNode=Nr(this._depthTextureNode,e,t)}return this._viewZNode}getDepthNode(){if(this._depthNode===null){const e=this._cameraNear,t=this._cameraFar;this._depthNode=Ln(this.getViewZNode(),e,t)}return this._depthNode}setup(){return this.scope===ds.COLOR?this.getTextureNode():this.getDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s,camera:o}=this;this._pixelRatio=t.getPixelRatio();const i=t.getSize(new we);this.setSize(i.width,i.height);const r=t.toneMapping,a=t.toneMappingNode,c=t.getRenderTarget();this._cameraNear.value=o.near,this._cameraFar.value=o.far,t.toneMapping=Ts,t.toneMappingNode=null,t.setRenderTarget(this.renderTarget),t.render(s,o),t.toneMapping=r,t.toneMappingNode=a,t.setRenderTarget(c)}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,o=this._height*this._pixelRatio;this.renderTarget.setSize(s,o)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}ds.COLOR="color";ds.DEPTH="depth";const io=(n,e)=>R(new Dn(n,e));T("PassNode",ds);const hn=new Jo(-1,1,1,-1,0,1);class Gh extends Gn{constructor(e=!1){super();const t=e===!1?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new Ft([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Ft(t,2))}}const Hh=new Gh;class qh extends kn{constructor(e=null){super(Hh,e),this.camera=hn}renderAsync(e){return e.renderAsync(this,hn)}render(e){e.render(this,hn)}}const Ys=qh,Uo=new Ys,Bo=new Ys;class Wh extends j{constructor(e,t=2){super("vec4"),this.textureNode=e,this.sigma=t,this.directionNode=C(1),this._invSize=X(new we),this._passDirection=X(new we),this._horizontalRT=new xt,this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new xt,this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=io(this,this._verticalRT.texture),this.updateBeforeType=$.RENDER,this.resolution=new we(1,1)}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value,i=t.getRenderTarget(),r=s.value;Uo.material=this._material,Bo.material=this._material,this.setSize(o.image.width,o.image.height);const a=o.type;this._horizontalRT.texture.type=a,this._verticalRT.texture.type=a,t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),Uo.render(t),s.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),Bo.render(t),t.setRenderTarget(i),s.value=r}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode;if(t.isTextureNode!==!0)return console.error("GaussianBlurNode requires a TextureNode."),w();const s=t.uvNode||tt(),o=c=>t.cache().context({getUV:()=>c,forceUVContext:!0}),i=x(()=>{const c=3+2*this.sigma,u=this._getCoefficients(c),l=this._invSize,p=C(this.directionNode).mul(this._passDirection),g=d(u[0]).toVar(),V=w(o(s).mul(g)).toVar();for(let A=1;A<c;A++){const _=d(A),I=d(u[A]),E=C(p.mul(l.mul(_))).toVar(),z=w(o(s.add(E))),O=w(o(s.sub(E)));V.addAssign(z.add(O).mul(I)),g.addAssign(U(2,I))}return V.div(g)}),r=this._material||(this._material=e.createNodeMaterial());r.fragmentNode=i();const a=e.getNodeProperties(this);return a.textureNode=t,this._textureNode}_getCoefficients(e){const t=[];for(let s=0;s<e;s++)t.push(.39894*Math.exp(-.5*s*s/(e*e))/e);return t}}const $h=(n,e)=>R(new Wh(R(n),e));N("gaussianBlur",$h);const ko=new Ys;class Xh extends j{constructor(e,t=.96){super(e),this.textureNode=e,this.textureNodeOld=be(),this.damp=X(t),this._compRT=new xt,this._compRT.texture.name="AfterImageNode.comp",this._oldRT=new xt,this._oldRT.texture.name="AfterImageNode.old",this._textureNode=io(this,this._compRT.texture),this.updateBeforeType=$.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._compRT.setSize(e,t),this._oldRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value,i=o.type;this._compRT.texture.type=i,this._oldRT.texture.type=i;const r=t.getRenderTarget(),a=s.value;this.textureNodeOld.value=this._oldRT.texture,t.setRenderTarget(this._compRT),ko.render(t);const c=this._oldRT;this._oldRT=this._compRT,this._compRT=c,this.setSize(o.image.width,o.image.height),t.setRenderTarget(r),s.value=a}setup(e){const t=this.textureNode,s=this.textureNodeOld;if(t.isTextureNode!==!0)return console.error("AfterImageNode requires a TextureNode."),w();const o=t.uvNode||tt();s.uvNode=o;const i=l=>t.cache().context({getUV:()=>l,forceUVContext:!0}),r=x(([l,p])=>{const g=d(p).toVar(),V=w(l).toVar();return De(to(V.sub(g)),0)}),a=x(()=>{const l=w(s),p=w(i(o));return l.mulAssign(this.damp.mul(r(l,.1))),De(p,l)}),c=this._materialComposed||(this._materialComposed=e.createNodeMaterial());c.fragmentNode=a(),ko.material=c;const u=e.getNodeProperties(this);return u.textureNode=t,this._textureNode}}const jh=(n,e)=>R(new Xh(R(n),e));N("afterImage",jh);const Go=new Ys;class Yh extends j{constructor(e,t,s,o){super("vec4"),this.textureNode=e,this.tresholdNode=t,this.scaleNode=s,this.colorNode=f(.1,0,1),this.samples=o,this.resolution=new we(1,1),this._renderTarget=new xt,this._renderTarget.texture.name="anamorphic",this._invSize=X(new we),this._textureNode=io(this,this._renderTarget.texture),this.updateBeforeType=$.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._invSize.value.set(1/e,1/t),e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._renderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e,s=this.textureNode,o=s.value;this._renderTarget.texture.type=o.type;const i=t.getRenderTarget(),r=s.value;Go.material=this._material,this.setSize(o.image.width,o.image.height),t.setRenderTarget(this._renderTarget),Go.render(t),t.setRenderTarget(i),s.value=r}setup(e){const t=this.textureNode;if(t.isTextureNode!==!0)return console.error("AnamorphNode requires a TextureNode."),w();const s=t.uvNode||tt(),o=c=>t.cache().context({getUV:()=>c,forceUVContext:!0}),i=x(()=>{const c=this.samples,u=Math.floor(c/2),l=f(0).toVar();return Z({start:-u,end:u},({i:p})=>{const g=d(p).abs().div(u).oneMinus(),V=C(s.x.add(this._invSize.x.mul(p).mul(this.scaleNode)),s.y),A=o(V),_=Wr(A,this.tresholdNode).mul(g);l.addAssign(_)}),l.mul(this.colorNode)}),r=this._material||(this._material=e.createNodeMaterial());r.fragmentNode=i();const a=e.getNodeProperties(this);return a.textureNode=t,this._textureNode}}const Zh=(n,e=.9,t=3,s=32)=>R(new Yh(R(n),R(e),R(t),s));N("anamorphic",Zh);class Zr extends j{constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],s=this.functionNode,o=s.getInputs(e),i=this.parameters;if(Array.isArray(i))for(let a=0;a<i.length;a++){const c=o[a],u=i[a];t.push(u.build(e,c.type))}else for(const a of o){const c=i[a.name];if(c!==void 0)t.push(c.build(e,a.type));else throw new Error(`FunctionCallNode: Input '${a.name}' not found in FunctionNode.`)}return`${s.build(e,"property")}( ${t.join(", ")} )`}}const Kh=(n,...e)=>(e=e.length>1||e[0]&&e[0].isNode===!0?It(e):Us(e[0]),R(new Zr(R(n),e)));N("call",Kh);T("FunctionCallNode",Zr);class Kr extends L{constructor(e=null){super(),this._value=e,this._cache=null,this.inputType=null,this.outpuType=null,this.events=new $o,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return this.outputType!==null}set value(e){this._value!==e&&(this._cache&&this.inputType==="URL"&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=e,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const e=this.value;if(e&&this._cache===null&&this.inputType==="URL"&&e.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([e.value]));else if(e&&e.value!==null&&e.value!==void 0&&((this.inputType==="URL"||this.inputType==="String")&&typeof e.value=="string"||this.inputType==="Number"&&typeof e.value=="number"||this.inputType==="Vector2"&&e.value.isVector2||this.inputType==="Vector3"&&e.value.isVector3||this.inputType==="Vector4"&&e.value.isVector4||this.inputType==="Color"&&e.value.isColor||this.inputType==="Matrix3"&&e.value.isMatrix3||this.inputType==="Matrix4"&&e.value.isMatrix4))return e.value;return this._cache||e}getNodeType(e){return this.value&&this.value.isNode?this.value.getNodeType(e):"float"}setup(){return this.value&&this.value.isNode?this.value:d()}serialize(e){super.serialize(e),this.value!==null?this.inputType==="ArrayBuffer"?e.value=ii(this.value):e.value=this.value?this.value.toJSON(e.meta).uuid:null:e.value=null,e.inputType=this.inputType,e.outputType=this.outputType}deserialize(e){super.deserialize(e);let t=null;e.value!==null&&(e.inputType==="ArrayBuffer"?t=ri(e.value):e.inputType==="Texture"?t=e.meta.textures[e.value]:t=e.meta.nodes[e.value]||null),this.value=t,this.inputType=e.inputType,this.outputType=e.outputType}}const ys=y(Kr);N("scriptableValue",ys);T("ScriptableValueNode",Kr);class Jr extends Map{get(e,t=null,...s){if(this.has(e))return super.get(e);if(t!==null){const o=t(...s);return this.set(e,o),o}}}class Jh{constructor(e){this.scriptableNode=e}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(e){return this.scriptableNode.getInputLayout(e)}get(e){const t=this.parameters[e];return t?t.getValue():null}}const pn=new Jr;class Qr extends L{constructor(e=null,t={}){super(),this.codeNode=e,this.parameters=t,this._local=new Jr,this._output=ys(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(e,t){return this._local.set(e,t)}getLocal(e){return this._local.get(e)}onRefresh(){this._refresh()}getInputLayout(e){for(const t of this.getLayout())if(t.inputType&&(t.id===e||t.name===e))return t}getOutputLayout(e){for(const t of this.getLayout())if(t.outputType&&(t.id===e||t.name===e))return t}setOutput(e,t){const s=this._outputs;return s[e]===void 0?s[e]=ys(t):s[e].value=t,this}getOutput(e){return this._outputs[e]}getParameter(e){return this.parameters[e]}setParameter(e,t){const s=this.parameters;return t&&t.isScriptableNode?(this.deleteParameter(e),s[e]=t,s[e].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):t&&t.isScriptableValueNode?(this.deleteParameter(e),s[e]=t,s[e].events.addEventListener("refresh",this.onRefresh)):s[e]===void 0?(s[e]=ys(t),s[e].events.addEventListener("refresh",this.onRefresh)):s[e].value=t,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(e){let t=this.parameters[e];return t&&(t.isScriptableNode&&(t=t.getDefaultOutput()),t.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const e of Object.keys(this.parameters))this.deleteParameter(e);return this.needsUpdate=!0,this}call(e,...t){const o=this.getObject()[e];if(typeof o=="function")return o(...t)}async callAsync(e,...t){const o=this.getObject()[e];if(typeof o=="function")return o.constructor.name==="AsyncFunction"?await o(...t):o(...t)}getNodeType(e){return this.getDefaultOutputNode().getNodeType(e)}refresh(e=null){e!==null?this.getOutput(e).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),this._object!==null)return this._object;const e=()=>this.refresh(),t=(u,l)=>this.setOutput(u,l),s=new Jh(this),o=pn.get("THREE"),i=pn.get("TSL"),r=this.getMethod(this.codeNode),a=[s,this._local,pn,e,t,o,i];this._object=r(...a);const c=this._object.layout;if(c&&(c.cache===!1&&this._local.clear(),this._output.outputType=c.outputType||null,Array.isArray(c.elements)))for(const u of c.elements){const l=u.id||u.name;u.inputType&&(this.getParameter(l)===void 0&&this.setParameter(l,null),this.getParameter(l).inputType=u.inputType),u.outputType&&(this.getOutput(l)===void 0&&this.setOutput(l,null),this.getOutput(l).outputType=u.outputType)}return this._object}deserialize(e){super.deserialize(e);for(const t in this.parameters){let s=this.parameters[t];s.isScriptableNode&&(s=s.getDefaultOutput()),s.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const e=this.getDefaultOutput().value;return e&&e.isNode?e:d()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),this._method!==null)return this._method;const e=["parameters","local","global","refresh","setOutput","THREE","TSL"],s=["layout","init","main","dispose"].join(", "),o="var "+s+`; var output = {};
`,i=`
return { ...output, `+s+" };",r=o+this.codeNode.code+i;return this._method=new Function(...e,r),this._method}dispose(){this._method!==null&&(this._object&&typeof this._object.dispose=="function"&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}set needsUpdate(e){e===!0&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return this.codeNode===null?this:(this._needsOutputUpdate===!0&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value,this)}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const Qh=y(Qr);N("scriptable",Qh);T("ScriptableNode",Qr);class Zs extends L{constructor(e,t){super("float"),this.isFogNode=!0,this.colorNode=e,this.factorNode=t}getViewZNode(e){let t;const s=e.context.getViewZ;return s!==void 0&&(t=s(this)),(t||Ie.z).negate()}setup(){return this.factorNode}}const ep=y(Zs);N("fog",ep);T("FogNode",Zs);class ea extends Zs{constructor(e,t,s){super(e),this.isFogRangeNode=!0,this.nearNode=t,this.farNode=s}setup(e){const t=this.getViewZNode(e);return ot(this.nearNode,this.farNode,t)}}const tp=y(ea);N("rangeFog",tp);T("FogRangeNode",ea);class ta extends Zs{constructor(e,t){super(e),this.isFogExp2Node=!0,this.densityNode=t}setup(e){const t=this.getViewZNode(e),s=this.densityNode;return s.mul(s,t,t).negate().exp().oneMinus()}}const sp=y(ta);N("densityFog",sp);T("FogExp2Node",ta);let mt=null,gt=null;class sa extends L{constructor(e=d(),t=d()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(ct(this.minNode.value)),s=e.getTypeLength(ct(this.maxNode.value));return t>s?t:s}getNodeType(e){return e.object.isInstancedMesh===!0?e.getTypeFromLength(this.getVectorLength(e)):"float"}setup(e){const t=e.object;let s=null;if(t.isInstancedMesh===!0){const o=this.minNode.value,i=this.maxNode.value,r=e.getTypeLength(ct(o)),a=e.getTypeLength(ct(i));mt=mt||new lt,gt=gt||new lt,mt.setScalar(0),gt.setScalar(0),r===1?mt.setScalar(o):o.isColor?mt.set(o.r,o.g,o.b):mt.set(o.x,o.y,o.z||0,o.w||0),a===1?gt.setScalar(i):i.isColor?gt.set(i.r,i.g,i.b):gt.set(i.x,i.y,i.z||0,i.w||0);const c=4,u=c*t.count,l=new Float32Array(u);for(let g=0;g<u;g++){const V=g%c,A=mt.getComponent(V),_=gt.getComponent(V);l[g]=Xo.lerp(A,_,Math.random())}const p=this.getNodeType(e);s=so(l,"vec4",t.count).element(Ni).convert(p)}else s=d(0);return s}}y(sa);T("RangeNode",sa);class na extends L{constructor(e,t,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=e,this.count=t,this.workgroupSize=s,this.dispatchCount=0,this.version=1,this.updateBeforeType=$.OBJECT,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}updateDispatchCount(){const{count:e,workgroupSize:t}=this;let s=t[0];for(let o=1;o<t.length;o++)s*=t[o];this.dispatchCount=Math.ceil(e/s)}onInit(){}updateBefore({renderer:e}){e.compute(this)}generate(e){const{shaderStage:t}=e;if(t==="compute"){const s=this.computeNode.build(e,"void");s!==""&&e.addLineFlowCode(s)}}}const np=(n,e,t)=>R(new na(R(n),e,t));N("compute",np);T("ComputeNode",na);class St extends L{constructor(e=St.TARGET_DIRECTION,t=null){super(),this.scope=e,this.light=t}setup(){const{scope:e,light:t}=this;let s=null;return e===St.TARGET_DIRECTION&&(s=it.transformDirection(_n(t).sub(_n(t.target)))),s}serialize(e){super.serialize(e),e.scope=this.scope}deserialize(e){super.deserialize(e),this.scope=e.scope}}St.TARGET_DIRECTION="targetDirection";const oa=y(St,St.TARGET_DIRECTION);T("LightNode",St);const ia=x(n=>{const{lightDistance:e,cutoffDistance:t,decayExponent:s}=n,o=e.pow(s).max(.01).reciprocal();return t.greaterThan(0).cond(o.mul(e.div(t).pow4().oneMinus().clamp().pow2()),o)});class ra extends _t{constructor(e=null){super(e),this.cutoffDistanceNode=X(0),this.decayExponentNode=X(0)}update(e){const{light:t}=this;super.update(e),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}setup(e){const{colorNode:t,cutoffDistanceNode:s,decayExponentNode:o,light:i}=this,r=e.context.lightingModel,a=qi(i).sub(Ie),c=a.normalize(),u=a.length(),l=ia({lightDistance:u,cutoffDistance:s,decayExponent:o}),p=t.mul(l),g=e.context.reflectedLight;r.direct({lightDirection:c,lightColor:p,reflectedLight:g,shadowMask:this.shadowMaskNode},e.stack,e)}}T("PointLightNode",ra);Xt(Tc,ra);class aa extends _t{constructor(e=null){super(e)}setup(e){super.setup(e);const t=e.context.lightingModel,s=this.colorNode,o=oa(this.light),i=e.context.reflectedLight;t.direct({lightDirection:o,lightColor:s,reflectedLight:i,shadowMask:this.shadowMaskNode},e.stack,e)}}T("DirectionalLightNode",aa);Xt(Sc,aa);class ro extends _t{constructor(e=null){super(e),this.coneCosNode=X(0),this.penumbraCosNode=X(0),this.cutoffDistanceNode=X(0),this.decayExponentNode=X(0)}update(e){super.update(e);const{light:t}=this;this.coneCosNode.value=Math.cos(t.angle),this.penumbraCosNode.value=Math.cos(t.angle*(1-t.penumbra)),this.cutoffDistanceNode.value=t.distance,this.decayExponentNode.value=t.decay}getSpotAttenuation(e){const{coneCosNode:t,penumbraCosNode:s}=this;return ot(t,s,e)}setup(e){super.setup(e);const t=e.context.lightingModel,{colorNode:s,cutoffDistanceNode:o,decayExponentNode:i,light:r}=this,a=qi(r).sub(Ie),c=a.normalize(),u=c.dot(oa(r)),l=this.getSpotAttenuation(u),p=a.length(),g=ia({lightDistance:p,cutoffDistance:o,decayExponent:i}),V=s.mul(l).mul(g),A=e.context.reflectedLight;t.direct({lightDirection:c,lightColor:V,reflectedLight:A,shadowMask:this.shadowMaskNode},e.stack,e)}}T("SpotLightNode",ro);Xt(Qo,ro);class op extends Qo{constructor(e,t,s,o,i,r){super(e,t,s,o,i,r),this.iesMap=null}copy(e,t){return super.copy(e,t),this.iesMap=e.iesMap,this}}const ip=op;class ca extends ro{getSpotAttenuation(e){const t=this.light.iesMap;let s=null;if(t&&t.isTexture===!0){const o=e.acos().mul(1/Math.PI);s=be(t,C(o,0),0).r}else s=super.getSpotAttenuation(e);return s}}T("IESSpotLightNode",ca);Xt(ip,ca);class ua extends _t{constructor(e=null){super(e)}setup({context:e}){e.irradiance.addAssign(this.colorNode)}}T("AmbientLightNode",ua);Xt(Ac,ua);class la extends _t{constructor(e=null){super(e),this.lightPositionNode=_n(e),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=X(new ts)}update(e){const{light:t}=this;super.update(e),this.lightPositionNode.object3d=t,this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity)}setup(e){const{colorNode:t,groundColorNode:s,lightDirectionNode:o}=this,r=ht.dot(o).mul(.5).add(.5),a=ye(s,t,r);e.context.irradiance.addAssign(a)}}T("HemisphereLightNode",la);Xt(Vc,la);const rp=x(n=>{const e=n.uv.mul(2),t=e.x.floor(),s=e.y.floor();return t.add(s).mod(2).sign()});class da extends j{constructor(e=tt()){super("float"),this.uvNode=e}setup(){return rp({uv:this.uvNode})}}const ap=y(da);N("checker",ap);T("CheckerNode",da);const cp=new ei;class up extends Pe{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.pointWidth=1,this.pointColorNode=null,this.setDefaultValues(cp),this.setupShaders(),this.setValues(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor;this.vertexNode=x(()=>{ne(C(),"vUv").assign(tt());const s=ve("instancePosition"),o=ge("vec4","mvPos");o.assign(Tt.mul(w(s,1)));const i=Dt.z.div(Dt.w),r=Ze.mul(o),a=ge("vec2","offset");return a.assign(Ve.xy),a.assign(a.mul(ad)),a.assign(a.div(Dt.z)),a.y.assign(a.y.mul(i)),a.assign(a.mul(r.w)),r.assign(r.add(w(a,0,0))),r})(),this.fragmentNode=x(()=>{const s=ne(C(),"vUv"),o=ge("float","alpha");o.assign(1);const i=s.x,r=s.y,a=i.mul(i).add(r.mul(r));if(e){const u=ge("float","dlen");u.assign(a.fwidth()),o.assign(ot(u.oneMinus(),u.add(1),a).oneMinus())}else a.greaterThan(1).discard();let c;return this.pointColorNode?c=this.pointColorNode:t?c=ve("instanceColor").mul(os):c=os,w(c,o)})(),this.needsUpdate=!0}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.setupShaders())}}Ae("InstancedPointsNodeMaterial",up);const lp=new _c;class dp extends Pe{constructor(e){super(),this.isLineBasicNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(lp),this.setValues(e)}}Ae("LineBasicNodeMaterial",dp);const hp=new ti;class pp extends Pe{constructor(e){super(),this.isLineDashedNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(hp),this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setupVariants(){const e=this.offsetNode,t=this.dashScaleNode?d(this.dashScaleNode):Rn,s=this.dashSizeNode?d(this.dashSizeNode):Yi,o=this.dashSizeNode?d(this.dashGapNode):Zi;zt.assign(s),Ms.assign(o);const i=ne(ve("lineDistance").mul(t));(e?i.add(e):i).mod(zt.add(Ms)).greaterThan(zt).discard()}}Ae("LineDashedNodeMaterial",pp);const mp=new ti;class gp extends Pe{constructor(e={}){super(),this.normals=!1,this.lights=!1,this.setDefaultValues(mp),this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.useDash=e.dashed,this.useWorldUnits=!1,this.dashOffset=0,this.lineWidth=1,this.lineColorNode=null,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setup(e){this.setupShaders(),super.setup(e)}setupShaders(){const e=this.alphaToCoverage,t=this.useColor,s=this.dashed,o=this.worldUnits,i=x(({start:a,end:c})=>{const u=Ze.element(2).element(2),g=Ze.element(3).element(2).mul(-.5).div(u).sub(a.z).div(c.z.sub(a.z));return w(ye(a.xyz,c.xyz,g),c.w)});this.vertexNode=x(()=>{Ye("vec2","vUv").assign(tt());const a=ve("instanceStart"),c=ve("instanceEnd"),u=ge("vec4","start"),l=ge("vec4","end");u.assign(Tt.mul(w(a,1))),l.assign(Tt.mul(w(c,1))),o&&(Ye("vec3","worldStart").assign(u.xyz),Ye("vec3","worldEnd").assign(l.xyz));const p=Dt.z.div(Dt.w),g=Ze.element(2).element(3).equal(-1);P(g,()=>{P(u.z.lessThan(0).and(l.z.greaterThan(0)),()=>{l.assign(i({start:u,end:l}))}).elseif(l.z.lessThan(0).and(u.z.greaterThanEqual(0)),()=>{u.assign(i({start:l,end:u}))})});const V=Ze.mul(u),A=Ze.mul(l),_=V.xyz.div(V.w),I=A.xyz.div(A.w),E=I.xy.sub(_.xy).temp();E.x.assign(E.x.mul(p)),E.assign(E.normalize());const z=ss(w());if(o){const O=l.xyz.sub(u.xyz).normalize(),B=ye(u.xyz,l.xyz,.5).normalize(),K=O.cross(B).normalize(),F=O.cross(K),Y=Ye("vec4","worldPos");Y.assign(Ve.y.lessThan(.5).cond(u,l));const J=en.mul(.5);Y.addAssign(w(Ve.x.lessThan(0).cond(K.mul(J),K.mul(J).negate()),0)),s||(Y.addAssign(w(Ve.y.lessThan(.5).cond(O.mul(J).negate(),O.mul(J)),0)),Y.addAssign(w(F.mul(J),0)),P(Ve.y.greaterThan(1).or(Ve.y.lessThan(0)),()=>{Y.subAssign(w(F.mul(2).mul(J),0))})),z.assign(Ze.mul(Y));const Rt=ss(f());Rt.assign(Ve.y.lessThan(.5).cond(_,I)),z.z.assign(Rt.z.mul(z.w))}else{const O=ge("vec2","offset");O.assign(C(E.y,E.x.negate())),E.x.assign(E.x.div(p)),O.x.assign(O.x.div(p)),O.assign(Ve.x.lessThan(0).cond(O.negate(),O)),P(Ve.y.lessThan(0),()=>{O.assign(O.sub(E))}).elseif(Ve.y.greaterThan(1),()=>{O.assign(O.add(E))}),O.assign(O.mul(en)),O.assign(O.div(Dt.w)),z.assign(Ve.y.lessThan(.5).cond(V,A)),O.assign(O.mul(z.w)),z.assign(z.add(w(O,0,0)))}return z})();const r=x(({p1:a,p2:c,p3:u,p4:l})=>{const p=a.sub(u),g=l.sub(u),V=c.sub(a),A=p.dot(g),_=g.dot(V),I=p.dot(V),E=g.dot(g),O=V.dot(V).mul(E).sub(_.mul(_)),K=A.mul(_).sub(I.mul(E)).div(O).clamp(),F=A.add(_.mul(K)).div(E).clamp();return C(K,F)});this.fragmentNode=x(()=>{const a=Ye("vec2","vUv");if(s){const l=this.offsetNode?d(this.offsetNodeNode):Ao,p=this.dashScaleNode?d(this.dashScaleNode):Rn,g=this.dashSizeNode?d(this.dashSizeNode):Yi,V=this.dashSizeNode?d(this.dashGapNode):Zi;zt.assign(g),Ms.assign(V);const A=ve("instanceDistanceStart"),_=ve("instanceDistanceEnd"),I=Ve.y.lessThan(.5).cond(p.mul(A),Rn.mul(_)),E=ne(I.add(Ao)),z=l?E.add(l):E;a.y.lessThan(-1).or(a.y.greaterThan(1)).discard(),z.mod(zt.add(Ms)).greaterThan(zt).discard()}const c=ge("float","alpha");if(c.assign(1),o){const l=Ye("vec3","worldStart"),p=Ye("vec3","worldEnd"),g=Ye("vec4","worldPos").xyz.normalize().mul(1e5),V=p.sub(l),A=r({p1:l,p2:p,p3:f(0,0,0),p4:g}),_=l.add(V.mul(A.x)),I=g.mul(A.y),O=_.sub(I).length().div(en);if(!s)if(e){const B=O.fwidth();c.assign(ot(B.negate().add(.5),B.add(.5),O).oneMinus())}else O.greaterThan(.5).discard()}else if(e){const l=a.x,p=a.y.greaterThan(0).cond(a.y.sub(1),a.y.add(1)),g=l.mul(l).add(p.mul(p)),V=ge("float","dlen");V.assign(g.fwidth()),P(a.y.abs().greaterThan(1),()=>{c.assign(ot(V.oneMinus(),V.add(1),g).oneMinus())})}else P(a.y.abs().greaterThan(1),()=>{const l=a.x,p=a.y.greaterThan(0).cond(a.y.sub(1),a.y.add(1));l.mul(l).add(p.mul(p)).greaterThan(1).discard()});let u;if(this.lineColorNode)u=this.lineColorNode;else if(t){const l=ve("instanceColorStart"),p=ve("instanceColorEnd");u=Ve.y.lessThan(.5).cond(l,p).mul(os)}else u=os;return w(u,c)})()}get worldUnits(){return this.useWorldUnits}set worldUnits(e){this.useWorldUnits!==e&&(this.useWorldUnits=e,this.needsUpdate=!0)}get dashed(){return this.useDash}set dashed(e){this.useDash!==e&&(this.useDash=e,this.needsUpdate=!0)}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.needsUpdate=!0)}}Ae("Line2NodeMaterial",gp);const fp=new Rc;class Np extends Pe{constructor(e){super(),this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(fp),this.setValues(e)}setupDiffuseColor(){const e=this.opacityNode?d(this.opacityNode):ji;te.assign(w(Cr(oe),e))}}Ae("MeshNormalNodeMaterial",Np);const yp=new Mc;class xp extends Pe{constructor(e){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!1,this.setDefaultValues(yp),this.setValues(e)}}Ae("MeshBasicNodeMaterial",xp);const rs=x(({f0:n,f90:e,dotVH:t})=>{const s=t.mul(-5.55473).sub(6.98316).mul(t).exp2();return n.mul(s.oneMinus()).add(e.mul(s))}),Os=x(n=>n.diffuseColor.mul(1/Math.PI)),vp=()=>d(.25),Tp=x(({dotNH:n})=>Tn.mul(d(.5)).add(1).mul(d(1/Math.PI)).mul(n.pow(Tn))),Sp=x(({lightDirection:n})=>{const e=n.add(se).normalize(),t=oe.dot(e).clamp(),s=se.dot(e).clamp(),o=rs({f0:Ge,f90:1,dotVH:s}),i=vp(),r=Tp({dotNH:t});return o.mul(i).mul(r)});class ha extends Yn{constructor(e=!0){super(),this.specular=e}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const i=oe.dot(e).clamp().mul(t);s.directDiffuse.addAssign(i.mul(Os({diffuseColor:te.rgb}))),this.specular===!0&&s.directSpecular.addAssign(i.mul(Sp({lightDirection:e})).mul(Gl))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Os({diffuseColor:te})))}}const Ap=new wc;class Vp extends Pe{constructor(e){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(Ap),this.setValues(e)}setupLightingModel(){return new ha(!1)}}Ae("MeshLambertNodeMaterial",Vp);const _p=new Ec;class Rp extends Pe{constructor(e){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(_p),this.setValues(e)}setupLightingModel(){return new ha}setupVariants(){const e=(this.shininessNode?d(this.shininessNode):Fl).max(1e-4);Tn.assign(e);const t=this.specularNode||Bl;Ge.assign(t)}copy(e){return this.shininessNode=e.shininessNode,this.specularNode=e.specularNode,super.copy(e)}}Ae("MeshPhongNodeMaterial",Rp);const Mp=x(()=>{const n=ws.dFdx().abs().max(ws.dFdy().abs());return n.x.max(n.y).max(n.z)}),wp=x(n=>{const{roughness:e}=n,t=Mp();let s=e.max(.0525);return s=s.add(t),s=s.min(1),s}),Ep=x(({alpha:n,dotNL:e,dotNV:t})=>{const s=n.pow2(),o=e.mul(s.add(s.oneMinus().mul(t.pow2())).sqrt()),i=t.mul(s.add(s.oneMinus().mul(e.pow2())).sqrt());return dt(.5,o.add(i).max(wi))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),Cp=x(({alphaT:n,alphaB:e,dotTV:t,dotBV:s,dotTL:o,dotBL:i,dotNV:r,dotNL:a})=>{const c=a.mul(f(n.mul(t),e.mul(s),r).length()),u=r.mul(f(n.mul(o),e.mul(i),a).length());return dt(.5,c.add(u)).saturate()}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),Lp=x(({alpha:n,dotNH:e})=>{const t=n.pow2(),s=e.pow2().mul(t.oneMinus()).oneMinus();return t.div(s.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),Ip=d(1/Math.PI),Op=x(({alphaT:n,alphaB:e,dotNH:t,dotTH:s,dotBH:o})=>{const i=n.mul(e),r=f(e.mul(s),n.mul(o),i.mul(t)),a=r.dot(r),c=i.div(a);return Ip.mul(i.mul(c.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),Ho=x(n=>{const{lightDirection:e,f0:t,f90:s,roughness:o,f:i,USE_IRIDESCENCE:r,USE_ANISOTROPY:a}=n,c=n.normalView||oe,u=o.pow2(),l=e.add(se).normalize(),p=c.dot(e).clamp(),g=c.dot(se).clamp(),V=c.dot(l).clamp(),A=se.dot(l).clamp();let _=rs({f0:t,f90:s,dotVH:A}),I,E;if(No(r)&&(_=Kn.mix(_,i)),No(a)){const z=fs.dot(e),O=fs.dot(se),B=fs.dot(l),K=bt.dot(e),F=bt.dot(se),Y=bt.dot(l);I=Cp({alphaT:vn,alphaB:u,dotTV:O,dotBV:F,dotTL:z,dotBL:K,dotNV:g,dotNL:p}),E=Op({alphaT:vn,alphaB:u,dotNH:V,dotTH:B,dotBH:Y})}else I=Ep({alpha:u,dotNL:p,dotNV:g}),E=Lp({alpha:u,dotNH:V});return _.mul(I).mul(E)}),pa=x(({roughness:n,dotNV:e})=>{const t=w(-1,-.0275,-.572,.022),s=w(1,.0425,1.04,-.04),o=n.mul(t).add(s),i=o.x.mul(o.x).min(e.mul(-9.28).exp2()).mul(o.x).add(o.y);return C(-1.04,1.04).mul(i).add(o.zw)}).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),ma=x(n=>{const{dotNV:e,specularColor:t,specularF90:s,roughness:o}=n,i=pa({dotNV:e,roughness:o});return t.mul(i.x).add(s.mul(i.y))}),bp=x(({f:n,f90:e,dotVH:t})=>{const s=t.oneMinus().saturate(),o=s.mul(s),i=s.mul(o,o).clamp(0,.9999);return n.sub(f(e).mul(i)).div(i.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),zp=x(({roughness:n,dotNH:e})=>{const t=n.pow2(),s=d(1).div(t),i=e.pow2().oneMinus().max(.0078125);return d(2).add(s).mul(i.pow(s.mul(.5))).div(2*Math.PI)}).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),Dp=x(({dotNV:n,dotNL:e})=>d(1).div(d(4).mul(e.add(n).sub(e.mul(n))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),Pp=x(({lightDirection:n})=>{const e=n.add(se).normalize(),t=oe.dot(n).clamp(),s=oe.dot(se).clamp(),o=oe.dot(e).clamp(),i=zp({roughness:Zn,dotNH:o}),r=Dp({dotNV:s,dotNL:t});return wt.mul(i).mul(r)}),Fp=x(([n,e,t,s,o])=>{const i=f(Di(e.negate(),Se(n),dt(1,s))),r=f(es(o[0].xyz),es(o[1].xyz),es(o[2].xyz));return Se(i).mul(t.mul(r))}).setLayout({name:"getVolumeTransmissionRay",type:"vec3",inputs:[{name:"n",type:"vec3"},{name:"v",type:"vec3"},{name:"thickness",type:"float"},{name:"ior",type:"float"},{name:"modelMatrix",type:"mat4"}]}),Up=x(([n,e])=>n.mul(kt(e.mul(2).sub(2),0,1))).setLayout({name:"applyIorToRoughness",type:"float",inputs:[{name:"roughness",type:"float"},{name:"ior",type:"float"}]}),Bp=mr(),kp=x(([n,e,t])=>{const s=Bp.uv(n),o=ks(d(Cn.x)).mul(Up(e,t));return s.bicubic(o)}),Gp=x(([n,e,t])=>(P(t.notEqual(0),()=>{const s=Li(e).negate().div(t);return Ci(s.negate().mul(n))}),f(1))).setLayout({name:"volumeAttenuation",type:"vec3",inputs:[{name:"transmissionDistance",type:"float"},{name:"attenuationColor",type:"vec3"},{name:"attenuationDistance",type:"float"}]}),Hp=x(([n,e,t,s,o,i,r,a,c,u,l,p,g,V])=>{const A=Fp(n,e,p,l,a),_=r.add(A),I=u.mul(c.mul(w(_,1))),E=C(I.xy.div(I.w)).toVar();E.addAssign(1),E.divAssign(2),E.assign(C(E.x,E.y.oneMinus()));const z=kp(E,t,l),O=s.mul(Gp(es(A),g,V)),B=O.rgb.mul(z.rgb),K=n.dot(e).clamp(),F=f(ma({dotNV:K,specularColor:o,specularF90:i,roughness:t})),Y=O.r.add(O.g,O.b).div(3);return w(F.oneMinus().mul(B),z.a.oneMinus().mul(Y).oneMinus())}),qp=$e(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),Wp=n=>{const e=n.sqrt();return f(1).add(e).div(f(1).sub(e))},qo=(n,e)=>n.sub(e).div(n.add(e)).pow2(),$p=(n,e)=>{const t=n.mul(2*Math.PI*1e-9),s=f(54856e-17,44201e-17,52481e-17),o=f(1681e3,1795300,2208400),i=f(43278e5,93046e5,66121e5),r=d(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());let a=s.mul(i.mul(2*Math.PI).sqrt()).mul(o.mul(t).add(e).cos()).mul(t.pow2().negate().mul(i).exp());return a=f(a.x.add(r),a.y,a.z).div(10685e-11),qp.mul(a)},Xp=x(({outsideIOR:n,eta2:e,cosTheta1:t,thinFilmThickness:s,baseF0:o})=>{const i=ye(n,e,ot(0,.03,s)),r=n.div(i).pow2().mul(d(1).sub(t.pow2())),c=d(1).sub(r).sqrt(),u=qo(i,n),l=rs({f0:u,f90:1,dotVH:t}),p=l.oneMinus(),g=i.lessThan(n).cond(Math.PI,0),V=d(Math.PI).sub(g),A=Wp(o.clamp(0,.9999)),_=qo(A,i.vec3()),I=rs({f0:_,f90:1,dotVH:c}),E=f(A.x.lessThan(i).cond(Math.PI,0),A.y.lessThan(i).cond(Math.PI,0),A.z.lessThan(i).cond(Math.PI,0)),z=i.mul(s,c,2),O=f(V).add(E),B=l.mul(I).clamp(1e-5,.9999),K=B.sqrt(),F=p.pow2().mul(I).div(f(1).sub(B));let J=l.add(F),Rt=F.sub(p);for(let hs=1;hs<=2;++hs){Rt=Rt.mul(K);const Qa=$p(d(hs).mul(z),d(hs).mul(O)).mul(2);J=J.add(Rt.mul(Qa))}return J.max(f(0))}).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),jp=x(({normal:n,viewDir:e,roughness:t})=>{const s=n.dot(e).saturate(),o=t.pow2(),i=Oe(t.lessThan(.25),d(-339.2).mul(o).add(d(161.4).mul(t)).sub(25.9),d(-8.48).mul(o).add(d(14.3).mul(t)).sub(9.95)),r=Oe(t.lessThan(.25),d(44).mul(o).sub(d(23.7).mul(t)).add(3.26),d(1.97).mul(o).sub(d(3.27).mul(t)).add(.72));return Oe(t.lessThan(.25),0,d(.1).mul(t).sub(.025)).add(i.mul(s).add(r).exp()).mul(1/Math.PI).saturate()}),mn=f(.04),gn=f(1);class ao extends Yn{constructor(e=!1,t=!1,s=!1,o=!1,i=!1){super(),this.clearcoat=e,this.sheen=t,this.iridescence=s,this.anisotropy=o,this.transmission=i,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null}start(e){if(this.clearcoat===!0&&(this.clearcoatRadiance=f().temp("clearcoatRadiance"),this.clearcoatSpecularDirect=f().temp("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=f().temp("clearcoatSpecularIndirect")),this.sheen===!0&&(this.sheenSpecularDirect=f().temp("sheenSpecularDirect"),this.sheenSpecularIndirect=f().temp("sheenSpecularIndirect")),this.iridescence===!0){const t=oe.dot(se).clamp();this.iridescenceFresnel=Xp({outsideIOR:d(1),eta2:xi,cosTheta1:t,thinFilmThickness:vi,baseF0:Ge}),this.iridescenceF0=bp({f:this.iridescenceFresnel,f90:1,dotVH:t})}if(this.transmission===!0){const t=Mn,s=Dl.sub(Mn).normalize(),o=Xi;e.backdrop=Hp(o,s,ut,te,Ge,Rs,t,ns,it,Ze,Ns,Ti,Ai,Si),e.backdropAlpha=Sn,te.a.mulAssign(ye(1,e.backdrop.a,Sn))}}computeMultiscattering(e,t,s){const o=oe.dot(se).clamp(),i=pa({roughness:ut,dotNV:o}),a=(this.iridescenceF0?Kn.mix(Ge,this.iridescenceF0):Ge).mul(i.x).add(s.mul(i.y)),u=i.x.add(i.y).oneMinus(),l=Ge.add(Ge.oneMinus().mul(.047619)),p=a.mul(l).div(u.mul(l).oneMinus());e.addAssign(a),t.addAssign(p.mul(u))}direct({lightDirection:e,lightColor:t,reflectedLight:s}){const i=oe.dot(e).clamp().mul(t);if(this.sheen===!0&&this.sheenSpecularDirect.addAssign(i.mul(Pp({lightDirection:e}))),this.clearcoat===!0){const a=Et.dot(e).clamp().mul(t);this.clearcoatSpecularDirect.addAssign(a.mul(Ho({lightDirection:e,f0:mn,f90:gn,roughness:_s,normalView:Et})))}s.directDiffuse.addAssign(i.mul(Os({diffuseColor:te.rgb}))),s.directSpecular.addAssign(i.mul(Ho({lightDirection:e,f0:Ge,f90:1,roughness:ut,iridescence:this.iridescence,f:this.iridescenceFresnel,USE_IRIDESCENCE:this.iridescence,USE_ANISOTROPY:this.anisotropy})))}indirectDiffuse({irradiance:e,reflectedLight:t}){t.indirectDiffuse.addAssign(e.mul(Os({diffuseColor:te})))}indirectSpecular({radiance:e,iblIrradiance:t,reflectedLight:s}){if(this.sheen===!0&&this.sheenSpecularIndirect.addAssign(t.mul(wt,jp({normal:oe,viewDir:se,roughness:Zn}))),this.clearcoat===!0){const u=Et.dot(se).clamp(),l=ma({dotNV:u,specularColor:mn,specularF90:gn,roughness:_s});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(l))}const o=f().temp("singleScattering"),i=f().temp("multiScattering"),r=t.mul(1/Math.PI);this.computeMultiscattering(o,i,Rs);const a=o.add(i),c=te.mul(a.r.max(a.g).max(a.b).oneMinus());s.indirectSpecular.addAssign(e.mul(o)),s.indirectSpecular.addAssign(i.mul(r)),s.indirectDiffuse.addAssign(c.mul(r))}ambientOcclusion({ambientOcclusion:e,reflectedLight:t}){const o=oe.dot(se).clamp().add(e),i=ut.mul(-16).oneMinus().negate().exp2(),r=e.sub(o.pow(i).oneMinus()).clamp();this.clearcoat===!0&&this.clearcoatSpecularIndirect.mulAssign(e),this.sheen===!0&&this.sheenSpecularIndirect.mulAssign(e),t.indirectDiffuse.mulAssign(e),t.indirectSpecular.mulAssign(r)}finish(e){const{outgoingLight:t}=e;if(this.clearcoat===!0){const s=Et.dot(se).clamp(),o=rs({dotVH:s,f0:mn,f90:gn}),i=t.mul(xn.mul(o).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(xn));t.assign(i)}if(this.sheen===!0){const s=wt.r.max(wt.g).max(wt.b).mul(.157).oneMinus(),o=t.mul(s).add(this.sheenSpecularDirect,this.sheenSpecularIndirect);t.assign(o)}}}const Yp=new Cc;class ga extends Pe{constructor(e){super(),this.isMeshStandardNodeMaterial=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(Yp),this.setValues(e)}setupLightingModel(){return new ao}setupSpecular(){const e=ye(f(.04),te.rgb,Vs);Ge.assign(e),Rs.assign(1)}setupVariants(){const e=this.metalnessNode?d(this.metalnessNode):ql;Vs.assign(e);let t=this.roughnessNode?d(this.roughnessNode):Hl;t=wp({roughness:t}),ut.assign(t),this.setupSpecular(),te.assign(w(te.rgb.mul(e.oneMinus()),te.a))}copy(e){return this.emissiveNode=e.emissiveNode,this.metalnessNode=e.metalnessNode,this.roughnessNode=e.roughnessNode,super.copy(e)}}Ae("MeshStandardNodeMaterial",ga);const Zp=new Lc;class fa extends ga{constructor(e){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.iorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.anisotropyNode=null,this.setDefaultValues(Zp),this.setValues(e)}get useClearcoat(){return this.clearcoat>0||this.clearcoatNode!==null}get useIridescence(){return this.iridescence>0||this.iridescenceNode!==null}get useSheen(){return this.sheen>0||this.sheenNode!==null}get useAnisotropy(){return this.anisotropy>0||this.anisotropyNode!==null}get useTransmission(){return this.transmission>0||this.transmissionNode!==null}setupSpecular(){const e=this.iorNode?d(this.iorNode):od;Ns.assign(e),Ge.assign(ye(Bt(zi(Ns.sub(1).div(Ns.add(1))).mul(kl),f(1)).mul(So),te.rgb,Vs)),Rs.assign(ye(So,1,Vs))}setupLightingModel(){return new ao(this.useClearcoat,this.useSheen,this.useIridescence,this.useAnisotropy,this.useTransmission)}setupVariants(e){if(super.setupVariants(e),this.useClearcoat){const t=this.clearcoatNode?d(this.clearcoatNode):$l,s=this.clearcoatRoughnessNode?d(this.clearcoatRoughnessNode):Xl;xn.assign(t),_s.assign(s)}if(this.useSheen){const t=this.sheenNode?f(this.sheenNode):Zl,s=this.sheenRoughnessNode?d(this.sheenRoughnessNode):Kl;wt.assign(t),Zn.assign(s)}if(this.useIridescence){const t=this.iridescenceNode?d(this.iridescenceNode):Ql,s=this.iridescenceIORNode?d(this.iridescenceIORNode):ed,o=this.iridescenceThicknessNode?d(this.iridescenceThicknessNode):td;Kn.assign(t),xi.assign(s),vi.assign(o)}if(this.useAnisotropy){const t=(this.anisotropyNode?C(this.anisotropyNode):Jl).toVar();ft.assign(t.length()),P(ft.equal(0),()=>{t.assign(C(1,0))}).else(()=>{t.divAssign(ft),ft.assign(ft.saturate())}),vn.assign(ft.pow2().mix(ut.pow2(),1)),fs.assign(Ct[0].mul(t.x).add(Ct[1].mul(t.y))),bt.assign(Ct[1].mul(t.x).sub(Ct[0].mul(t.y)))}if(this.useTransmission){const t=this.transmissionNode?d(this.transmissionNode):sd,s=this.thicknessNode?d(this.thicknessNode):nd,o=this.attenuationDistanceNode?d(this.attenuationDistanceNode):id,i=this.attenuationColorNode?f(this.attenuationColorNode):rd;Sn.assign(t),Ti.assign(s),Si.assign(o),Ai.assign(i)}}setupNormal(e){super.setupNormal(e);const t=this.clearcoatNormalNode?f(this.clearcoatNormalNode):jl;Et.assign(t)}copy(e){return this.clearcoatNode=e.clearcoatNode,this.clearcoatRoughnessNode=e.clearcoatRoughnessNode,this.clearcoatNormalNode=e.clearcoatNormalNode,this.sheenNode=e.sheenNode,this.sheenRoughnessNode=e.sheenRoughnessNode,this.iridescenceNode=e.iridescenceNode,this.iridescenceIORNode=e.iridescenceIORNode,this.iridescenceThicknessNode=e.iridescenceThicknessNode,this.specularIntensityNode=e.specularIntensityNode,this.specularColorNode=e.specularColorNode,this.transmissionNode=e.transmissionNode,this.thicknessNode=e.thicknessNode,this.attenuationDistanceNode=e.attenuationDistanceNode,this.attenuationColorNode=e.attenuationColorNode,this.anisotropyNode=e.anisotropyNode,super.copy(e)}}Ae("MeshPhysicalNodeMaterial",fa);class Kp extends ao{constructor(e,t,s,o){super(e,t,s),this.useSSS=o}direct({lightDirection:e,lightColor:t,reflectedLight:s},o,i){if(this.useSSS===!0){const r=i.material,{thicknessColorNode:a,thicknessDistortionNode:c,thicknessAmbientNode:u,thicknessAttenuationNode:l,thicknessPowerNode:p,thicknessScaleNode:g}=r,V=e.add(oe.mul(c)).normalize(),A=d(se.dot(V.negate()).saturate().pow(p).mul(g)),_=f(A.add(u).mul(a));s.directDiffuse.addAssign(_.mul(l.mul(t)))}super.direct({lightDirection:e,lightColor:t,reflectedLight:s},o,i)}}class Jp extends fa{constructor(e){super(e),this.thicknessColorNode=null,this.thicknessDistortionNode=d(.1),this.thicknessAmbientNode=d(0),this.thicknessAttenuationNode=d(.1),this.thicknessPowerNode=d(2),this.thicknessScaleNode=d(10)}get useSSS(){return this.thicknessColorNode!==null}setupLightingModel(){return new Kp(this.useClearcoat,this.useSheen,this.useIridescence,this.useSSS)}copy(e){return this.thicknessColorNode=e.thicknessColorNode,this.thicknessDistortionNode=e.thicknessDistortionNode,this.thicknessAmbientNode=e.thicknessAmbientNode,this.thicknessAttenuationNode=e.thicknessAttenuationNode,this.thicknessPowerNode=e.thicknessPowerNode,this.thicknessScaleNode=e.thicknessScaleNode,super.copy(e)}}Ae("MeshSSSNodeMaterial",Jp);const Qp=new ei;class em extends Pe{constructor(e){super(),this.isPointsNodeMaterial=!0,this.lights=!1,this.normals=!1,this.transparent=!0,this.sizeNode=null,this.setDefaultValues(Qp),this.setValues(e)}copy(e){return this.sizeNode=e.sizeNode,super.copy(e)}}Ae("PointsNodeMaterial",em);const tm=new Ic;class sm extends Pe{constructor(e){super(),this.isSpriteNodeMaterial=!0,this.lights=!1,this.normals=!1,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.setDefaultValues(tm),this.setValues(e)}setupPosition({object:e,context:t}){const{positionNode:s,rotationNode:o,scaleNode:i}=this,r=Te;let a=Tt.mul(f(s||0)),c=C(ns[0].xyz.length(),ns[1].xyz.length());i!==null&&(c=c.mul(i));let u=r.xy;e.center&&e.center.isVector2===!0&&(u=u.sub(X(e.center).sub(.5))),u=u.mul(c);const l=d(o||Yl),p=u.rotate(l);a=w(a.xy.add(p),a.zw);const g=Ze.mul(a);return t.vertex=r,g}copy(e){return this.positionNode=e.positionNode,this.rotationNode=e.rotationNode,this.scaleNode=e.scaleNode,super.copy(e)}}Ae("SpriteNodeMaterial",sm);class nm extends Yn{constructor(){super(),this.shadowNode=d(1).toVar("shadowMask")}direct({shadowMask:e}){this.shadowNode.mulAssign(e)}finish(e){te.a.mulAssign(this.shadowNode.oneMinus()),e.outgoingLight.rgb.assign(te.rgb)}}const om=new Oc;class im extends Pe{constructor(e){super(),this.isShadowNodeMaterial=!0,this.lights=!0,this.setDefaultValues(om),this.setValues(e)}setupLightingModel(){return new nm}}Ae("ShadowNodeMaterial",im);const Pt=x(([n,e,t])=>{const s=d(t).toVar(),o=d(e).toVar(),i=vt(n).toVar();return Oe(i,o,s)}),as=x(([n,e])=>{const t=vt(e).toVar(),s=d(n).toVar();return Oe(t,s.negate(),s)}),ie=x(([n])=>{const e=d(n).toVar();return h(Ht(e))}),Q=x(([n,e])=>{const t=d(n).toVar();return e.assign(ie(t)),t.sub(d(e))}),Na=x(([n,e,t,s,o,i])=>{const r=d(i).toVar(),a=d(o).toVar(),c=d(s).toVar(),u=d(t).toVar(),l=d(e).toVar(),p=d(n).toVar(),g=d(re(1,a)).toVar();return re(1,r).mul(p.mul(g).add(l.mul(a))).add(r.mul(u.mul(g).add(c.mul(a))))}),ya=x(([n,e,t,s,o,i])=>{const r=d(i).toVar(),a=d(o).toVar(),c=f(s).toVar(),u=f(t).toVar(),l=f(e).toVar(),p=f(n).toVar(),g=d(re(1,a)).toVar();return re(1,r).mul(p.mul(g).add(l.mul(a))).add(r.mul(u.mul(g).add(c.mul(a))))}),xa=ke([Na,ya]),va=x(([n,e,t,s,o,i,r,a,c,u,l])=>{const p=d(l).toVar(),g=d(u).toVar(),V=d(c).toVar(),A=d(a).toVar(),_=d(r).toVar(),I=d(i).toVar(),E=d(o).toVar(),z=d(s).toVar(),O=d(t).toVar(),B=d(e).toVar(),K=d(n).toVar(),F=d(re(1,V)).toVar(),Y=d(re(1,g)).toVar();return d(re(1,p)).toVar().mul(Y.mul(K.mul(F).add(B.mul(V))).add(g.mul(O.mul(F).add(z.mul(V))))).add(p.mul(Y.mul(E.mul(F).add(I.mul(V))).add(g.mul(_.mul(F).add(A.mul(V))))))}),Ta=x(([n,e,t,s,o,i,r,a,c,u,l])=>{const p=d(l).toVar(),g=d(u).toVar(),V=d(c).toVar(),A=f(a).toVar(),_=f(r).toVar(),I=f(i).toVar(),E=f(o).toVar(),z=f(s).toVar(),O=f(t).toVar(),B=f(e).toVar(),K=f(n).toVar(),F=d(re(1,V)).toVar(),Y=d(re(1,g)).toVar();return d(re(1,p)).toVar().mul(Y.mul(K.mul(F).add(B.mul(V))).add(g.mul(O.mul(F).add(z.mul(V))))).add(p.mul(Y.mul(E.mul(F).add(I.mul(V))).add(g.mul(_.mul(F).add(A.mul(V))))))}),Sa=ke([va,Ta]),Aa=x(([n,e,t])=>{const s=d(t).toVar(),o=d(e).toVar(),i=M(n).toVar(),r=M(i.bitAnd(M(7))).toVar(),a=d(Pt(r.lessThan(M(4)),o,s)).toVar(),c=d(U(2,Pt(r.lessThan(M(4)),s,o))).toVar();return as(a,vt(r.bitAnd(M(1)))).add(as(c,vt(r.bitAnd(M(2)))))}),Va=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),r=d(e).toVar(),a=M(n).toVar(),c=M(a.bitAnd(M(15))).toVar(),u=d(Pt(c.lessThan(M(8)),r,i)).toVar(),l=d(Pt(c.lessThan(M(4)),i,Pt(c.equal(M(12)).or(c.equal(M(14))),r,o))).toVar();return as(u,vt(c.bitAnd(M(1)))).add(as(l,vt(c.bitAnd(M(2)))))}),pe=ke([Aa,Va]),_a=x(([n,e,t])=>{const s=d(t).toVar(),o=d(e).toVar(),i=cs(n).toVar();return f(pe(i.x,o,s),pe(i.y,o,s),pe(i.z,o,s))}),Ra=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),r=d(e).toVar(),a=cs(n).toVar();return f(pe(a.x,r,i,o),pe(a.y,r,i,o),pe(a.z,r,i,o))}),Fe=ke([_a,Ra]),Ma=x(([n])=>{const e=d(n).toVar();return U(.6616,e)}),wa=x(([n])=>{const e=d(n).toVar();return U(.982,e)}),Ea=x(([n])=>{const e=f(n).toVar();return U(.6616,e)}),Ca=ke([Ma,Ea]),La=x(([n])=>{const e=f(n).toVar();return U(.982,e)}),Ia=ke([wa,La]),Re=x(([n,e])=>{const t=h(e).toVar(),s=M(n).toVar();return s.shiftLeft(t).bitOr(s.shiftRight(h(32).sub(t)))}),Oa=x(([n,e,t])=>{n.subAssign(t),n.bitXorAssign(Re(t,h(4))),t.addAssign(e),e.subAssign(n),e.bitXorAssign(Re(n,h(6))),n.addAssign(t),t.subAssign(e),t.bitXorAssign(Re(e,h(8))),e.addAssign(n),n.subAssign(t),n.bitXorAssign(Re(t,h(16))),t.addAssign(e),e.subAssign(n),e.bitXorAssign(Re(n,h(19))),n.addAssign(t),t.subAssign(e),t.bitXorAssign(Re(e,h(4))),e.addAssign(n)}),jt=x(([n,e,t])=>{const s=M(t).toVar(),o=M(e).toVar(),i=M(n).toVar();return s.bitXorAssign(o),s.subAssign(Re(o,h(14))),i.bitXorAssign(s),i.subAssign(Re(s,h(11))),o.bitXorAssign(i),o.subAssign(Re(i,h(25))),s.bitXorAssign(o),s.subAssign(Re(o,h(16))),i.bitXorAssign(s),i.subAssign(Re(s,h(4))),o.bitXorAssign(i),o.subAssign(Re(i,h(14))),s.bitXorAssign(o),s.subAssign(Re(o,h(24))),s}),Ne=x(([n])=>{const e=M(n).toVar();return d(e).div(d(M(h(4294967295))))}),We=x(([n])=>{const e=d(n).toVar();return e.mul(e.mul(e.mul(e.mul(e.mul(6).sub(15)).add(10))))}),ba=x(([n])=>{const e=h(n).toVar(),t=M(M(1)).toVar(),s=M(M(h(3735928559)).add(t.shiftLeft(M(2)).add(M(13)))).toVar();return jt(s.add(M(e)),s,s)}),za=x(([n,e])=>{const t=h(e).toVar(),s=h(n).toVar(),o=M(M(2)).toVar(),i=M().toVar(),r=M().toVar(),a=M().toVar();return i.assign(r.assign(a.assign(M(h(3735928559)).add(o.shiftLeft(M(2)).add(M(13)))))),i.addAssign(M(s)),r.addAssign(M(t)),jt(i,r,a)}),Da=x(([n,e,t])=>{const s=h(t).toVar(),o=h(e).toVar(),i=h(n).toVar(),r=M(M(3)).toVar(),a=M().toVar(),c=M().toVar(),u=M().toVar();return a.assign(c.assign(u.assign(M(h(3735928559)).add(r.shiftLeft(M(2)).add(M(13)))))),a.addAssign(M(i)),c.addAssign(M(o)),u.addAssign(M(s)),jt(a,c,u)}),Pa=x(([n,e,t,s])=>{const o=h(s).toVar(),i=h(t).toVar(),r=h(e).toVar(),a=h(n).toVar(),c=M(M(4)).toVar(),u=M().toVar(),l=M().toVar(),p=M().toVar();return u.assign(l.assign(p.assign(M(h(3735928559)).add(c.shiftLeft(M(2)).add(M(13)))))),u.addAssign(M(a)),l.addAssign(M(r)),p.addAssign(M(i)),Oa(u,l,p),u.addAssign(M(o)),jt(u,l,p)}),Fa=x(([n,e,t,s,o])=>{const i=h(o).toVar(),r=h(s).toVar(),a=h(t).toVar(),c=h(e).toVar(),u=h(n).toVar(),l=M(M(5)).toVar(),p=M().toVar(),g=M().toVar(),V=M().toVar();return p.assign(g.assign(V.assign(M(h(3735928559)).add(l.shiftLeft(M(2)).add(M(13)))))),p.addAssign(M(u)),g.addAssign(M(c)),V.addAssign(M(a)),Oa(p,g,V),p.addAssign(M(r)),g.addAssign(M(i)),jt(p,g,V)}),G=ke([ba,za,Da,Pa,Fa]),Ua=x(([n,e])=>{const t=h(e).toVar(),s=h(n).toVar(),o=M(G(s,t)).toVar(),i=cs().toVar();return i.x.assign(o.bitAnd(h(255))),i.y.assign(o.shiftRight(h(8)).bitAnd(h(255))),i.z.assign(o.shiftRight(h(16)).bitAnd(h(255))),i}),Ba=x(([n,e,t])=>{const s=h(t).toVar(),o=h(e).toVar(),i=h(n).toVar(),r=M(G(i,o,s)).toVar(),a=cs().toVar();return a.x.assign(r.bitAnd(h(255))),a.y.assign(r.shiftRight(h(8)).bitAnd(h(255))),a.z.assign(r.shiftRight(h(16)).bitAnd(h(255))),a}),Ue=ke([Ua,Ba]),ka=x(([n])=>{const e=C(n).toVar(),t=h().toVar(),s=h().toVar(),o=d(Q(e.x,t)).toVar(),i=d(Q(e.y,s)).toVar(),r=d(We(o)).toVar(),a=d(We(i)).toVar(),c=d(xa(pe(G(t,s),o,i),pe(G(t.add(h(1)),s),o.sub(1),i),pe(G(t,s.add(h(1))),o,i.sub(1)),pe(G(t.add(h(1)),s.add(h(1))),o.sub(1),i.sub(1)),r,a)).toVar();return Ca(c)}),Ga=x(([n])=>{const e=f(n).toVar(),t=h().toVar(),s=h().toVar(),o=h().toVar(),i=d(Q(e.x,t)).toVar(),r=d(Q(e.y,s)).toVar(),a=d(Q(e.z,o)).toVar(),c=d(We(i)).toVar(),u=d(We(r)).toVar(),l=d(We(a)).toVar(),p=d(Sa(pe(G(t,s,o),i,r,a),pe(G(t.add(h(1)),s,o),i.sub(1),r,a),pe(G(t,s.add(h(1)),o),i,r.sub(1),a),pe(G(t.add(h(1)),s.add(h(1)),o),i.sub(1),r.sub(1),a),pe(G(t,s,o.add(h(1))),i,r,a.sub(1)),pe(G(t.add(h(1)),s,o.add(h(1))),i.sub(1),r,a.sub(1)),pe(G(t,s.add(h(1)),o.add(h(1))),i,r.sub(1),a.sub(1)),pe(G(t.add(h(1)),s.add(h(1)),o.add(h(1))),i.sub(1),r.sub(1),a.sub(1)),c,u,l)).toVar();return Ia(p)}),rm=ke([ka,Ga]),Ha=x(([n])=>{const e=C(n).toVar(),t=h().toVar(),s=h().toVar(),o=d(Q(e.x,t)).toVar(),i=d(Q(e.y,s)).toVar(),r=d(We(o)).toVar(),a=d(We(i)).toVar(),c=f(xa(Fe(Ue(t,s),o,i),Fe(Ue(t.add(h(1)),s),o.sub(1),i),Fe(Ue(t,s.add(h(1))),o,i.sub(1)),Fe(Ue(t.add(h(1)),s.add(h(1))),o.sub(1),i.sub(1)),r,a)).toVar();return Ca(c)}),qa=x(([n])=>{const e=f(n).toVar(),t=h().toVar(),s=h().toVar(),o=h().toVar(),i=d(Q(e.x,t)).toVar(),r=d(Q(e.y,s)).toVar(),a=d(Q(e.z,o)).toVar(),c=d(We(i)).toVar(),u=d(We(r)).toVar(),l=d(We(a)).toVar(),p=f(Sa(Fe(Ue(t,s,o),i,r,a),Fe(Ue(t.add(h(1)),s,o),i.sub(1),r,a),Fe(Ue(t,s.add(h(1)),o),i,r.sub(1),a),Fe(Ue(t.add(h(1)),s.add(h(1)),o),i.sub(1),r.sub(1),a),Fe(Ue(t,s,o.add(h(1))),i,r,a.sub(1)),Fe(Ue(t.add(h(1)),s,o.add(h(1))),i.sub(1),r,a.sub(1)),Fe(Ue(t,s.add(h(1)),o.add(h(1))),i,r.sub(1),a.sub(1)),Fe(Ue(t.add(h(1)),s.add(h(1)),o.add(h(1))),i.sub(1),r.sub(1),a.sub(1)),c,u,l)).toVar();return Ia(p)}),am=ke([Ha,qa]),cm=x(([n])=>{const e=d(n).toVar(),t=h(ie(e)).toVar();return Ne(G(t))}),um=x(([n])=>{const e=C(n).toVar(),t=h(ie(e.x)).toVar(),s=h(ie(e.y)).toVar();return Ne(G(t,s))}),lm=x(([n])=>{const e=f(n).toVar(),t=h(ie(e.x)).toVar(),s=h(ie(e.y)).toVar(),o=h(ie(e.z)).toVar();return Ne(G(t,s,o))}),dm=x(([n])=>{const e=w(n).toVar(),t=h(ie(e.x)).toVar(),s=h(ie(e.y)).toVar(),o=h(ie(e.z)).toVar(),i=h(ie(e.w)).toVar();return Ne(G(t,s,o,i))}),Wa=x(([n])=>{const e=d(n).toVar(),t=h(ie(e)).toVar();return f(Ne(G(t,h(0))),Ne(G(t,h(1))),Ne(G(t,h(2))))}),$a=x(([n])=>{const e=C(n).toVar(),t=h(ie(e.x)).toVar(),s=h(ie(e.y)).toVar();return f(Ne(G(t,s,h(0))),Ne(G(t,s,h(1))),Ne(G(t,s,h(2))))}),Xa=x(([n])=>{const e=f(n).toVar(),t=h(ie(e.x)).toVar(),s=h(ie(e.y)).toVar(),o=h(ie(e.z)).toVar();return f(Ne(G(t,s,o,h(0))),Ne(G(t,s,o,h(1))),Ne(G(t,s,o,h(2))))}),ja=x(([n])=>{const e=w(n).toVar(),t=h(ie(e.x)).toVar(),s=h(ie(e.y)).toVar(),o=h(ie(e.z)).toVar(),i=h(ie(e.w)).toVar();return f(Ne(G(t,s,o,i,h(0))),Ne(G(t,s,o,i,h(1))),Ne(G(t,s,o,i,h(2))))}),Ya=ke([Wa,$a,Xa,ja]),bs=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),r=h(e).toVar(),a=f(n).toVar(),c=d(0).toVar(),u=d(1).toVar();return Z({start:h(0),end:r},({i:l})=>{c.addAssign(u.mul(rm(a))),u.mulAssign(o),a.mulAssign(i)}),c}),Za=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),r=h(e).toVar(),a=f(n).toVar(),c=f(0).toVar(),u=d(1).toVar();return Z({start:h(0),end:r},({i:l})=>{c.addAssign(u.mul(am(a))),u.mulAssign(o),a.mulAssign(i)}),c}),hm=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),r=h(e).toVar(),a=f(n).toVar();return C(bs(a,r,i,o),bs(a.add(f(h(19),h(193),h(17))),r,i,o))}),pm=x(([n,e,t,s])=>{const o=d(s).toVar(),i=d(t).toVar(),r=h(e).toVar(),a=f(n).toVar(),c=f(Za(a,r,i,o)).toVar(),u=d(bs(a.add(f(h(19),h(193),h(17))),r,i,o)).toVar();return w(c,u)}),Ka=x(([n,e,t,s,o,i,r])=>{const a=h(r).toVar(),c=d(i).toVar(),u=h(o).toVar(),l=h(s).toVar(),p=h(t).toVar(),g=h(e).toVar(),V=C(n).toVar(),A=f(Ya(C(g.add(l),p.add(u)))).toVar(),_=C(A.x,A.y).toVar();_.subAssign(.5),_.mulAssign(c),_.addAssign(.5);const I=C(C(d(g),d(p)).add(_)).toVar(),E=C(I.sub(V)).toVar();return P(a.equal(h(2)),()=>ae(E.x).add(ae(E.y))),P(a.equal(h(3)),()=>De(ae(E.x),ae(E.y))),qt(E,E)}),Ja=x(([n,e,t,s,o,i,r,a,c])=>{const u=h(c).toVar(),l=d(a).toVar(),p=h(r).toVar(),g=h(i).toVar(),V=h(o).toVar(),A=h(s).toVar(),_=h(t).toVar(),I=h(e).toVar(),E=f(n).toVar(),z=f(Ya(f(I.add(V),_.add(g),A.add(p)))).toVar();z.subAssign(.5),z.mulAssign(l),z.addAssign(.5);const O=f(f(d(I),d(_),d(A)).add(z)).toVar(),B=f(O.sub(E)).toVar();return P(u.equal(h(2)),()=>ae(B.x).add(ae(B.y).add(ae(B.z)))),P(u.equal(h(3)),()=>De(De(ae(B.x),ae(B.y)),ae(B.z))),qt(B,B)}),Yt=ke([Ka,Ja]),mm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=C(n).toVar(),r=h().toVar(),a=h().toVar(),c=C(Q(i.x,r),Q(i.y,a)).toVar(),u=d(1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:l})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:p})=>{const g=d(Yt(c,l,p,r,a,o,s)).toVar();u.assign(Bt(u,g))})}),P(s.equal(h(0)),()=>{u.assign(Vt(u))}),u}),gm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=C(n).toVar(),r=h().toVar(),a=h().toVar(),c=C(Q(i.x,r),Q(i.y,a)).toVar(),u=C(1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:l})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:p})=>{const g=d(Yt(c,l,p,r,a,o,s)).toVar();P(g.lessThan(u.x),()=>{u.y.assign(u.x),u.x.assign(g)}).elseif(g.lessThan(u.y),()=>{u.y.assign(g)})})}),P(s.equal(h(0)),()=>{u.assign(Vt(u))}),u}),fm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=C(n).toVar(),r=h().toVar(),a=h().toVar(),c=C(Q(i.x,r),Q(i.y,a)).toVar(),u=f(1e6,1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:l})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:p})=>{const g=d(Yt(c,l,p,r,a,o,s)).toVar();P(g.lessThan(u.x),()=>{u.z.assign(u.y),u.y.assign(u.x),u.x.assign(g)}).elseif(g.lessThan(u.y),()=>{u.z.assign(u.y),u.y.assign(g)}).elseif(g.lessThan(u.z),()=>{u.z.assign(g)})})}),P(s.equal(h(0)),()=>{u.assign(Vt(u))}),u}),Nm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=f(n).toVar(),r=h().toVar(),a=h().toVar(),c=h().toVar(),u=f(Q(i.x,r),Q(i.y,a),Q(i.z,c)).toVar(),l=d(1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:p})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:g})=>{Z({start:-1,end:h(1),name:"z",condition:"<="},({z:V})=>{const A=d(Yt(u,p,g,V,r,a,c,o,s)).toVar();l.assign(Bt(l,A))})})}),P(s.equal(h(0)),()=>{l.assign(Vt(l))}),l}),ym=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=f(n).toVar(),r=h().toVar(),a=h().toVar(),c=h().toVar(),u=f(Q(i.x,r),Q(i.y,a),Q(i.z,c)).toVar(),l=C(1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:p})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:g})=>{Z({start:-1,end:h(1),name:"z",condition:"<="},({z:V})=>{const A=d(Yt(u,p,g,V,r,a,c,o,s)).toVar();P(A.lessThan(l.x),()=>{l.y.assign(l.x),l.x.assign(A)}).elseif(A.lessThan(l.y),()=>{l.y.assign(A)})})})}),P(s.equal(h(0)),()=>{l.assign(Vt(l))}),l}),xm=x(([n,e,t])=>{const s=h(t).toVar(),o=d(e).toVar(),i=f(n).toVar(),r=h().toVar(),a=h().toVar(),c=h().toVar(),u=f(Q(i.x,r),Q(i.y,a),Q(i.z,c)).toVar(),l=f(1e6,1e6,1e6).toVar();return Z({start:-1,end:h(1),name:"x",condition:"<="},({x:p})=>{Z({start:-1,end:h(1),name:"y",condition:"<="},({y:g})=>{Z({start:-1,end:h(1),name:"z",condition:"<="},({z:V})=>{const A=d(Yt(u,p,g,V,r,a,c,o,s)).toVar();P(A.lessThan(l.x),()=>{l.z.assign(l.y),l.y.assign(l.x),l.x.assign(A)}).elseif(A.lessThan(l.y),()=>{l.z.assign(l.y),l.y.assign(A)}).elseif(A.lessThan(l.z),()=>{l.z.assign(A)})})})}),P(s.equal(h(0)),()=>{l.assign(Vt(l))}),l});Pt.setLayout({name:"mx_select",type:"float",inputs:[{name:"b",type:"bool"},{name:"t",type:"float"},{name:"f",type:"float"}]});as.setLayout({name:"mx_negate_if",type:"float",inputs:[{name:"val",type:"float"},{name:"b",type:"bool"}]});ie.setLayout({name:"mx_floor",type:"int",inputs:[{name:"x",type:"float"}]});Na.setLayout({name:"mx_bilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"}]});ya.setLayout({name:"mx_bilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"}]});va.setLayout({name:"mx_trilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"v4",type:"float"},{name:"v5",type:"float"},{name:"v6",type:"float"},{name:"v7",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]});Ta.setLayout({name:"mx_trilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"v4",type:"vec3"},{name:"v5",type:"vec3"},{name:"v6",type:"vec3"},{name:"v7",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]});Aa.setLayout({name:"mx_gradient_float_0",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"}]});Va.setLayout({name:"mx_gradient_float_1",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]});_a.setLayout({name:"mx_gradient_vec3_0",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"}]});Ra.setLayout({name:"mx_gradient_vec3_1",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]});Ma.setLayout({name:"mx_gradient_scale2d_0",type:"float",inputs:[{name:"v",type:"float"}]});wa.setLayout({name:"mx_gradient_scale3d_0",type:"float",inputs:[{name:"v",type:"float"}]});Ea.setLayout({name:"mx_gradient_scale2d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]});La.setLayout({name:"mx_gradient_scale3d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]});Re.setLayout({name:"mx_rotl32",type:"uint",inputs:[{name:"x",type:"uint"},{name:"k",type:"int"}]});jt.setLayout({name:"mx_bjfinal",type:"uint",inputs:[{name:"a",type:"uint"},{name:"b",type:"uint"},{name:"c",type:"uint"}]});Ne.setLayout({name:"mx_bits_to_01",type:"float",inputs:[{name:"bits",type:"uint"}]});We.setLayout({name:"mx_fade",type:"float",inputs:[{name:"t",type:"float"}]});ba.setLayout({name:"mx_hash_int_0",type:"uint",inputs:[{name:"x",type:"int"}]});za.setLayout({name:"mx_hash_int_1",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]});Da.setLayout({name:"mx_hash_int_2",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]});Pa.setLayout({name:"mx_hash_int_3",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"}]});Fa.setLayout({name:"mx_hash_int_4",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"},{name:"yy",type:"int"}]});Ua.setLayout({name:"mx_hash_vec3_0",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]});Ba.setLayout({name:"mx_hash_vec3_1",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]});ka.setLayout({name:"mx_perlin_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"}]});Ga.setLayout({name:"mx_perlin_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"}]});Ha.setLayout({name:"mx_perlin_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"}]});qa.setLayout({name:"mx_perlin_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"}]});cm.setLayout({name:"mx_cell_noise_float_0",type:"float",inputs:[{name:"p",type:"float"}]});um.setLayout({name:"mx_cell_noise_float_1",type:"float",inputs:[{name:"p",type:"vec2"}]});lm.setLayout({name:"mx_cell_noise_float_2",type:"float",inputs:[{name:"p",type:"vec3"}]});dm.setLayout({name:"mx_cell_noise_float_3",type:"float",inputs:[{name:"p",type:"vec4"}]});Wa.setLayout({name:"mx_cell_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"float"}]});$a.setLayout({name:"mx_cell_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec2"}]});Xa.setLayout({name:"mx_cell_noise_vec3_2",type:"vec3",inputs:[{name:"p",type:"vec3"}]});ja.setLayout({name:"mx_cell_noise_vec3_3",type:"vec3",inputs:[{name:"p",type:"vec4"}]});bs.setLayout({name:"mx_fractal_noise_float",type:"float",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});Za.setLayout({name:"mx_fractal_noise_vec3",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});hm.setLayout({name:"mx_fractal_noise_vec2",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});pm.setLayout({name:"mx_fractal_noise_vec4",type:"vec4",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]});Ka.setLayout({name:"mx_worley_distance_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});Ja.setLayout({name:"mx_worley_distance_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"zoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});mm.setLayout({name:"mx_worley_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});gm.setLayout({name:"mx_worley_noise_vec2_0",type:"vec2",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});fm.setLayout({name:"mx_worley_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});Nm.setLayout({name:"mx_worley_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});ym.setLayout({name:"mx_worley_noise_vec2_1",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});xm.setLayout({name:"mx_worley_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]});const vm=x(([n])=>{const e=f(n).toVar(),t=d(e.x).toVar(),s=d(e.y).toVar(),o=d(e.z).toVar();P(s.lessThan(1e-4),()=>f(o,o,o)).else(()=>{t.assign(U(6,t.sub(Ht(t))));const i=h(Oi(t)).toVar(),r=d(t.sub(d(i))).toVar(),a=d(o.mul(re(1,s))).toVar(),c=d(o.mul(re(1,s.mul(r)))).toVar(),u=d(o.mul(re(1,s.mul(re(1,r))))).toVar();return P(i.equal(h(0)),()=>f(o,u,a)).elseif(i.equal(h(1)),()=>f(c,o,a)).elseif(i.equal(h(2)),()=>f(a,o,u)).elseif(i.equal(h(3)),()=>f(a,c,o)).elseif(i.equal(h(4)),()=>f(u,a,o)),f(o,a,c)})}),Tm=x(([n])=>{const e=f(n).toVar(),t=d(e.x).toVar(),s=d(e.y).toVar(),o=d(e.z).toVar(),i=d(Bt(t,Bt(s,o))).toVar(),r=d(De(t,De(s,o))).toVar(),a=d(r.sub(i)).toVar(),c=d().toVar(),u=d().toVar(),l=d().toVar();return l.assign(r),P(r.greaterThan(0),()=>{u.assign(a.div(r))}).else(()=>{u.assign(0)}),P(u.lessThanEqual(0),()=>{c.assign(0)}).else(()=>{P(t.greaterThanEqual(r),()=>{c.assign(s.sub(o).div(a))}).elseif(s.greaterThanEqual(r),()=>{c.assign(ze(2,o.sub(t).div(a)))}).else(()=>{c.assign(ze(4,t.sub(s).div(a)))}),c.mulAssign(1/6),P(c.lessThan(0),()=>{c.addAssign(1)})}),f(c,u,l)});vm.setLayout({name:"mx_hsvtorgb",type:"vec3",inputs:[{name:"hsv",type:"vec3"}]});Tm.setLayout({name:"mx_rgbtohsv",type:"vec3",inputs:[{name:"c",type:"vec3"}]});const Sm=x(([n])=>{const e=f(n).toVar(),t=di(Mi(e,f(.04045))).toVar(),s=f(e.div(12.92)).toVar(),o=f(Je(De(e.add(f(.055)),f(0)).div(1.055),f(2.4))).toVar();return ye(s,o,t)});Sm.setLayout({name:"mx_srgb_texture_to_lin_rec709",type:"vec3",inputs:[{name:"color",type:"vec3"}]});let at,co,Pn=!1,_e={color1:{value:"#0088cc",type:"color",displayName:"Bottom Base Color",onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uColor1.value.setHex(n.value.replace("#","0x"))}},color2:{value:"#fdd3e0",type:"color",displayName:"Top Base Color",onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uColor2.value.setHex(n.value.replace("#","0x"))}},pauseDistortion:{value:()=>{_e.pauseDistortion.params.label==="pause"?_e.pauseDistortion.params.label="play":_e.pauseDistortion.params.label="pause",he.uDebugSimulatorTexture.value=!he.uDebugSimulatorTexture.value},displayName:"Pause Distortion",params:{label:"pause"}},reset:{value:()=>{Pn=!1,he.uSetup.value=1},params:{label:"reset simulation"}},noiseSpeed:{value:.1,displayName:"Noise Speed",params:{min:0,max:1,step:.001},onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uNoiseSpeed.value=n.value}},noiseScale:{value:140,type:"number",displayName:"Noise Scale",onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uNoiseScale.value=n.value}},noiseDirection:{value:[0,1],displayName:"Noise Direction",onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uNoiseDirection.value.set(n.value[0],n.value[1])}},noiseAngle:{value:Math.PI*.5,type:"number",params:{min:-Math.PI,max:Math.PI,step:.01},displayName:"Noise Angle",onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uNoiseAngle.value=n.value},disabled:()=>_e.animationType.value===1},noiseBias:{value:.85,type:"number",displayName:"Noise Bias",params:{min:0,max:1,step:.01},onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uNoiseBias.value=n.value},disabled:()=>_e.animationType.value===1},animationType:{value:0,params:{min:0,max:1,step:1},displayName:"Animation Type",onChange:(n,{width:e,height:t,pixelRatio:s})=>{he.uAnimation.value=n.value}}},he={uResolution:{value:new we},uTime:{value:0},uDelta:{value:0},uTexture:{value:new bc},uSetup:{value:1},uColor1:{value:new ts().setHex(_e.color1.value.replace("#","0x"))},uColor2:{value:new ts().setHex(_e.color2.value.replace("#","0x"))},uDebugSimulatorTexture:{value:!1},uNoiseSpeed:{value:_e.noiseSpeed.value},uNoiseScale:{value:_e.noiseScale.value},uNoiseDirection:{value:new we(_e.noiseDirection.value[0],_e.noiseDirection.value[1])},uNoiseAngle:{value:_e.noiseAngle.value},uNoiseBias:{value:_e.noiseBias.value},uAnimation:{value:_e.animationType.value}},Lt,xs,Fn;function Am(){let n=new Gn;n.setAttribute("position",new Ft([-1,3,0,-1,-1,0,3,-1,0],3)),n.setAttribute("uv",new Ft([0,2,0,0,2,0],2));let e=new kn(n,new si({vertexShader:`
				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = vec4(position, 1.);
				}
        `,fragmentShader:Fc,uniforms:he}));co.add(e)}function Vm(n){let e=new Gn;e.setAttribute("position",new Ft([-1,3,0,-1,-1,0,3,-1,0],3)),e.setAttribute("uv",new Ft([0,2,0,0,2,0],2)),Fn=new si({vertexShader:`
			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = vec4(position, 1.);
			}
		`,fragmentShader:`
			precision highp float;
			uniform sampler2D uTexture;

			varying vec2 vUv;

			void main() {
				vec4 color = texture2D(uTexture, vUv);
				gl_FragColor = color;
			}
		`,uniforms:{uTexture:{value:null}}});let t=new kn(e,Fn);n.add(t)}let Rm=({scene:n,width:e,height:t})=>{co=new zc,Lt=new Dc(e,t,{minFilter:vs,magFilter:vs,format:Pc,type:jo,wrapS:lo,wrapT:lo}),xs=Lt.clone(),at=new Jo(1,1,1,1,1,1e3),Am(),Vm(n)},Mm=({renderer:n,scene:e,time:t,deltaTime:s})=>{he.uTime.value=t,he.uDelta.value=s,n.setRenderTarget(Lt),n.render(co,at),n.setRenderTarget(null),n.render(e,at);const o=Lt;Lt=xs,xs=o,Fn.uniforms.uTexture.value=Lt.texture,he.uTexture.value=xs.texture,Pn||(he.uSetup.value=0,Pn=!0)},wm=({width:n,height:e})=>{he.uResolution.value.x=n,he.uResolution.value.y=e,at.left=-n*.5,at.right=n*.5,at.top=e*.5,at.bottom=-e*.5,at.updateProjectionMatrix()},Em="three",Cm="./exports",Lm={gui:{output:!0,size:.2}};export{Lm as buildConfig,Cm as exportDir,Rm as init,_e as props,Em as rendering,wm as resize,Mm as update};
